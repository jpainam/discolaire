/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// @ts-nocheck
/*
 * WARNING: This is an internal file that is subject to change!
 *
 * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘
 *
 * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.
 * While this enables partial backward compatibility, it is not part of the stable public API.
 *
 * If you are looking for your Models, Enums, and Input Types, please import them from the respective
 * model files in the `model` directory!
 */

import * as runtime from "@prisma/client/runtime/client";

import type * as Prisma from "../models";
import { type PrismaClient } from "./class";

export type * from "../models";

export type DMMF = typeof runtime.DMMF;

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>;

/**
 * Prisma Errors
 */

export const PrismaClientKnownRequestError =
  runtime.PrismaClientKnownRequestError;
export type PrismaClientKnownRequestError =
  runtime.PrismaClientKnownRequestError;

export const PrismaClientUnknownRequestError =
  runtime.PrismaClientUnknownRequestError;
export type PrismaClientUnknownRequestError =
  runtime.PrismaClientUnknownRequestError;

export const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError;
export type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError;

export const PrismaClientInitializationError =
  runtime.PrismaClientInitializationError;
export type PrismaClientInitializationError =
  runtime.PrismaClientInitializationError;

export const PrismaClientValidationError = runtime.PrismaClientValidationError;
export type PrismaClientValidationError = runtime.PrismaClientValidationError;

/**
 * Re-export of sql-template-tag
 */
export const sql = runtime.sqltag;
export const empty = runtime.empty;
export const join = runtime.join;
export const raw = runtime.raw;
export const Sql = runtime.Sql;
export type Sql = runtime.Sql;

/**
 * Decimal.js
 */
export const Decimal = runtime.Decimal;
export type Decimal = runtime.Decimal;

export type DecimalJsLike = runtime.DecimalJsLike;

/**
 * Metrics
 */
export type Metrics = runtime.Metrics;
export type Metric<T> = runtime.Metric<T>;
export type MetricHistogram = runtime.MetricHistogram;
export type MetricHistogramBucket = runtime.MetricHistogramBucket;

/**
 * Extensions
 */
export type Extension = runtime.Types.Extensions.UserArgs;
export const getExtensionContext = runtime.Extensions.getExtensionContext;
export type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<
  T,
  F
>;
export type Payload<
  T,
  F extends runtime.Operation = never,
> = runtime.Types.Public.Payload<T, F>;
export type Result<
  T,
  A,
  F extends runtime.Operation,
> = runtime.Types.Public.Result<T, A, F>;
export type Exact<A, W> = runtime.Types.Public.Exact<A, W>;

export type PrismaVersion = {
  client: string;
  engine: string;
};

/**
 * Prisma Client JS version: 6.16.1
 * Query Engine version: 1c57fdcd7e44b29b9313256c76699e91c3ac3c43
 */
export const prismaVersion: PrismaVersion = {
  client: "6.16.1",
  engine: "1c57fdcd7e44b29b9313256c76699e91c3ac3c43",
};

/**
 * Utility Types
 */

export type JsonObject = runtime.JsonObject;
export type JsonArray = runtime.JsonArray;
export type JsonValue = runtime.JsonValue;
export type InputJsonObject = runtime.InputJsonObject;
export type InputJsonArray = runtime.InputJsonArray;
export type InputJsonValue = runtime.InputJsonValue;

export const NullTypes = {
  DbNull: runtime.objectEnumValues.classes.DbNull as new (
    secret: never,
  ) => typeof runtime.objectEnumValues.instances.DbNull,
  JsonNull: runtime.objectEnumValues.classes.JsonNull as new (
    secret: never,
  ) => typeof runtime.objectEnumValues.instances.JsonNull,
  AnyNull: runtime.objectEnumValues.classes.AnyNull as new (
    secret: never,
  ) => typeof runtime.objectEnumValues.instances.AnyNull,
};

/**
 * Helper for filtering JSON entries that have `null` on the database (empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const DbNull = runtime.objectEnumValues.instances.DbNull;

/**
 * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const JsonNull = runtime.objectEnumValues.instances.JsonNull;

/**
 * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const AnyNull = runtime.objectEnumValues.instances.AnyNull;

type SelectAndInclude = {
  select: any;
  include: any;
};

type SelectAndOmit = {
  select: any;
  omit: any;
};

/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Prisma__Pick<T, K extends keyof T> = {
  [P in K]: T[P];
};

export type Enumerable<T> = T | Array<T>;

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};

/**
 * SelectSubset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
 * Additionally, it validates, if both select and include are present. If the case, it errors.
 */
export type SelectSubset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
} & (T extends SelectAndInclude
  ? "Please either choose `select` or `include`."
  : T extends SelectAndOmit
    ? "Please either choose `select` or `omit`."
    : {});

/**
 * Subset + Intersection
 * @desc From `T` pick properties that exist in `U` and intersect `K`
 */
export type SubsetIntersection<T, U, K> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
} & K;

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
export type XOR<T, U> = T extends object
  ? U extends object
    ? (Without<T, U> & U) | (Without<U, T> & T)
    : U
  : T;

/**
 * Is T a Record?
 */
type IsObject<T extends any> =
  T extends Array<any>
    ? False
    : T extends Date
      ? False
      : T extends Uint8Array
        ? False
        : T extends BigInt
          ? False
          : T extends object
            ? True
            : False;

/**
 * If it's T[], return T
 */
export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T;

/**
 * From ts-toolbelt
 */

type __Either<O extends object, K extends Key> = Omit<O, K> &
  {
    // Merge all but K
    [P in K]: Prisma__Pick<O, P & keyof O>; // With K possibilities
  }[K];

type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>;

type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>;

type _Either<O extends object, K extends Key, strict extends Boolean> = {
  1: EitherStrict<O, K>;
  0: EitherLoose<O, K>;
}[strict];

export type Either<
  O extends object,
  K extends Key,
  strict extends Boolean = 1,
> = O extends unknown ? _Either<O, K, strict> : never;

export type Union = any;

export type PatchUndefined<O extends object, O1 extends object> = {
  [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K];
} & {};

/** Helper Types for "Merge" **/
export type IntersectOf<U extends Union> = (
  U extends unknown ? (k: U) => void : never
) extends (k: infer I) => void
  ? I
  : never;

export type Overwrite<O extends object, O1 extends object> = {
  [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
} & {};

type _Merge<U extends object> = IntersectOf<
  Overwrite<
    U,
    {
      [K in keyof U]-?: At<U, K>;
    }
  >
>;

type Key = string | number | symbol;
type AtStrict<O extends object, K extends Key> = O[K & keyof O];
type AtLoose<O extends object, K extends Key> = O extends unknown
  ? AtStrict<O, K>
  : never;
export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
  1: AtStrict<O, K>;
  0: AtLoose<O, K>;
}[strict];

export type ComputeRaw<A extends any> = A extends Function
  ? A
  : {
      [K in keyof A]: A[K];
    } & {};

export type OptionalFlat<O> = {
  [K in keyof O]?: O[K];
} & {};

type _Record<K extends keyof any, T> = {
  [P in K]: T;
};

// cause typescript not to expand types and preserve names
type NoExpand<T> = T extends unknown ? T : never;

// this type assumes the passed object is entirely optional
export type AtLeast<O extends object, K extends string> = NoExpand<
  O extends unknown
    ?
        | (K extends keyof O ? { [P in K]: O[P] } & O : O)
        | ({ [P in keyof O as P extends K ? P : never]-?: O[P] } & O)
    : never
>;

type _Strict<U, _U = U> = U extends unknown
  ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>>
  : never;

export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
/** End Helper Types for "Merge" **/

export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

export type Boolean = True | False;

export type True = 1;

export type False = 0;

export type Not<B extends Boolean> = {
  0: 1;
  1: 0;
}[B];

export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
  ? 0 // anything `never` is false
  : A1 extends A2
    ? 1
    : 0;

export type Has<U extends Union, U1 extends Union> = Not<
  Extends<Exclude<U1, U>, U1>
>;

export type Or<B1 extends Boolean, B2 extends Boolean> = {
  0: {
    0: 0;
    1: 1;
  };
  1: {
    0: 1;
    1: 1;
  };
}[B1][B2];

export type Keys<U extends Union> = U extends unknown ? keyof U : never;

export type GetScalarType<T, O> = O extends object
  ? {
      [P in keyof T]: P extends keyof O ? O[P] : never;
    }
  : never;

type FieldPaths<T, U = Omit<T, "_avg" | "_sum" | "_count" | "_min" | "_max">> =
  IsObject<T> extends True ? U : T;

export type GetHavingFields<T> = {
  [K in keyof T]: Or<
    Or<Extends<"OR", K>, Extends<"AND", K>>,
    Extends<"NOT", K>
  > extends True
    ? // infer is only needed to not hit TS limit
      // based on the brilliant idea of Pierre-Antoine Mills
      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
      T[K] extends infer TK
      ? GetHavingFields<
          UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never
        >
      : never
    : {} extends FieldPaths<T[K]>
      ? never
      : K;
}[keyof T];

/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never;
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>;
export type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T;

/**
 * Like `Pick`, but additionally can also accept an array of keys
 */
export type PickEnumerable<
  T,
  K extends Enumerable<keyof T> | keyof T,
> = Prisma__Pick<T, MaybeTupleToUnion<K>>;

/**
 * Exclude all keys with underscores
 */
export type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}`
  ? never
  : T;

export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>;

type FieldRefInputType<Model, FieldType> = Model extends never
  ? never
  : FieldRef<Model, FieldType>;

export const ModelName = {
  AiChat: "AiChat",
  AiMessage: "AiMessage",
  Vote: "Vote",
  AiDocument: "AiDocument",
  AiSuggestion: "AiSuggestion",
  Stream: "Stream",
  Absence: "Absence",
  AbsenceJustification: "AbsenceJustification",
  Lateness: "Lateness",
  LatenessJustification: "LatenessJustification",
  Chatter: "Chatter",
  Consigne: "Consigne",
  Exclusion: "Exclusion",
  PreventedAbsence: "PreventedAbsence",
  Convocation: "Convocation",
  TimetableCategory: "TimetableCategory",
  SubjectTimetable: "SubjectTimetable",
  PeriodicAttendance: "PeriodicAttendance",
  BibleText: "BibleText",
  InventoryAsset: "InventoryAsset",
  InventoryConsumable: "InventoryConsumable",
  InventoryAssetUsage: "InventoryAssetUsage",
  InventoryConsumableUsage: "InventoryConsumableUsage",
  InventoryUnit: "InventoryUnit",
  InventoryStockMovement: "InventoryStockMovement",
  Book: "Book",
  BookCategory: "BookCategory",
  BorrowedBook: "BorrowedBook",
  Shortcut: "Shortcut",
  Email: "Email",
  EmailRecipient: "EmailRecipient",
  Attachment: "Attachment",
  CommunicationChannel: "CommunicationChannel",
  RecipientGroup: "RecipientGroup",
  Feedback: "Feedback",
  Recipient: "Recipient",
  Announcement: "Announcement",
  Policy: "Policy",
  Appreciation: "Appreciation",
  ReportCard: "ReportCard",
  Report: "Report",
  HealthVisit: "HealthVisit",
  Classroom: "Classroom",
  Enrollment: "Enrollment",
  Reporting: "Reporting",
  ClassroomLevel: "ClassroomLevel",
  CalendarType: "CalendarType",
  CalendarEvent: "CalendarEvent",
  GradeSheet: "GradeSheet",
  Grade: "Grade",
  AssignmentCategory: "AssignmentCategory",
  AppreciationCategory: "AppreciationCategory",
  Assignment: "Assignment",
  Event: "Event",
  Term: "Term",
  ContactRelationship: "ContactRelationship",
  StaffDegree: "StaffDegree",
  Staff: "Staff",
  Document: "Document",
  Student: "Student",
  StudentSibling: "StudentSibling",
  RequiredFeeTransaction: "RequiredFeeTransaction",
  Fee: "Fee",
  StudentContact: "StudentContact",
  Contact: "Contact",
  Country: "Country",
  School: "School",
  RequiredAccountingJournal: "RequiredAccountingJournal",
  FormerSchool: "FormerSchool",
  Subject: "Subject",
  SubjectGroup: "SubjectGroup",
  Course: "Course",
  SchoolYear: "SchoolYear",
  ClassroomCycle: "ClassroomCycle",
  ClassroomSection: "ClassroomSection",
  UserRole: "UserRole",
  Token: "Token",
  MenuItem: "MenuItem",
  ProgramCategory: "ProgramCategory",
  Program: "Program",
  TeachingSessionProgram: "TeachingSessionProgram",
  TeachingSession: "TeachingSession",
  SMSTemplate: "SMSTemplate",
  SMSHistory: "SMSHistory",
  SMSHistoryDetail: "SMSHistoryDetail",
  Photo: "Photo",
  ReportQueue: "ReportQueue",
  Religion: "Religion",
  Club: "Club",
  StudentClub: "StudentClub",
  StudentSport: "StudentSport",
  Invite: "Invite",
  Sport: "Sport",
  Transaction: "Transaction",
  AccountingJournal: "AccountingJournal",
  ScheduleTask: "ScheduleTask",
  GradeAppreciation: "GradeAppreciation",
  ClassroomGradeAppreciation: "ClassroomGradeAppreciation",
  HealthRecord: "HealthRecord",
  HealthDrug: "HealthDrug",
  User: "User",
  Role: "Role",
  RolePolicy: "RolePolicy",
  UserPolicy: "UserPolicy",
  NotificationPreference: "NotificationPreference",
  Subscription: "Subscription",
  LogActivity: "LogActivity",
  SchoolYearEvent: "SchoolYearEvent",
  SchoolYearEventType: "SchoolYearEventType",
  Session: "Session",
  Account: "Account",
  Verification: "Verification",
  Apikey: "Apikey",
  UserNotification: "UserNotification",
  AppreciationRuleSet: "AppreciationRuleSet",
  AppreciationRule: "AppreciationRule",
  ScheduleDivision: "ScheduleDivision",
} as const;

export type ModelName = (typeof ModelName)[keyof typeof ModelName];

export interface TypeMapCb<GlobalOmitOptions = {}>
  extends runtime.Types.Utils.Fn<
    { extArgs: runtime.Types.Extensions.InternalArgs },
    runtime.Types.Utils.Record<string, any>
  > {
  returns: TypeMap<this["params"]["extArgs"], GlobalOmitOptions>;
}

export type TypeMap<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
  GlobalOmitOptions = {},
> = {
  globalOmitOptions: {
    omit: GlobalOmitOptions;
  };
  meta: {
    modelProps:
      | "aiChat"
      | "aiMessage"
      | "vote"
      | "aiDocument"
      | "aiSuggestion"
      | "stream"
      | "absence"
      | "absenceJustification"
      | "lateness"
      | "latenessJustification"
      | "chatter"
      | "consigne"
      | "exclusion"
      | "preventedAbsence"
      | "convocation"
      | "timetableCategory"
      | "subjectTimetable"
      | "periodicAttendance"
      | "bibleText"
      | "inventoryAsset"
      | "inventoryConsumable"
      | "inventoryAssetUsage"
      | "inventoryConsumableUsage"
      | "inventoryUnit"
      | "inventoryStockMovement"
      | "book"
      | "bookCategory"
      | "borrowedBook"
      | "shortcut"
      | "email"
      | "emailRecipient"
      | "attachment"
      | "communicationChannel"
      | "recipientGroup"
      | "feedback"
      | "recipient"
      | "announcement"
      | "policy"
      | "appreciation"
      | "reportCard"
      | "report"
      | "healthVisit"
      | "classroom"
      | "enrollment"
      | "reporting"
      | "classroomLevel"
      | "calendarType"
      | "calendarEvent"
      | "gradeSheet"
      | "grade"
      | "assignmentCategory"
      | "appreciationCategory"
      | "assignment"
      | "event"
      | "term"
      | "contactRelationship"
      | "staffDegree"
      | "staff"
      | "document"
      | "student"
      | "studentSibling"
      | "requiredFeeTransaction"
      | "fee"
      | "studentContact"
      | "contact"
      | "country"
      | "school"
      | "requiredAccountingJournal"
      | "formerSchool"
      | "subject"
      | "subjectGroup"
      | "course"
      | "schoolYear"
      | "classroomCycle"
      | "classroomSection"
      | "userRole"
      | "token"
      | "menuItem"
      | "programCategory"
      | "program"
      | "teachingSessionProgram"
      | "teachingSession"
      | "sMSTemplate"
      | "sMSHistory"
      | "sMSHistoryDetail"
      | "photo"
      | "reportQueue"
      | "religion"
      | "club"
      | "studentClub"
      | "studentSport"
      | "invite"
      | "sport"
      | "transaction"
      | "accountingJournal"
      | "scheduleTask"
      | "gradeAppreciation"
      | "classroomGradeAppreciation"
      | "healthRecord"
      | "healthDrug"
      | "user"
      | "role"
      | "rolePolicy"
      | "userPolicy"
      | "notificationPreference"
      | "subscription"
      | "logActivity"
      | "schoolYearEvent"
      | "schoolYearEventType"
      | "session"
      | "account"
      | "verification"
      | "apikey"
      | "userNotification"
      | "appreciationRuleSet"
      | "appreciationRule"
      | "scheduleDivision";
    txIsolationLevel: TransactionIsolationLevel;
  };
  model: {
    AiChat: {
      payload: Prisma.$AiChatPayload<ExtArgs>;
      fields: Prisma.AiChatFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.AiChatFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiChatPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.AiChatFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiChatPayload>;
        };
        findFirst: {
          args: Prisma.AiChatFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiChatPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.AiChatFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiChatPayload>;
        };
        findMany: {
          args: Prisma.AiChatFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiChatPayload>[];
        };
        create: {
          args: Prisma.AiChatCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiChatPayload>;
        };
        createMany: {
          args: Prisma.AiChatCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.AiChatCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiChatPayload>[];
        };
        delete: {
          args: Prisma.AiChatDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiChatPayload>;
        };
        update: {
          args: Prisma.AiChatUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiChatPayload>;
        };
        deleteMany: {
          args: Prisma.AiChatDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.AiChatUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.AiChatUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiChatPayload>[];
        };
        upsert: {
          args: Prisma.AiChatUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiChatPayload>;
        };
        aggregate: {
          args: Prisma.AiChatAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateAiChat>;
        };
        groupBy: {
          args: Prisma.AiChatGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AiChatGroupByOutputType>[];
        };
        count: {
          args: Prisma.AiChatCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.AiChatCountAggregateOutputType>
            | number;
        };
      };
    };
    AiMessage: {
      payload: Prisma.$AiMessagePayload<ExtArgs>;
      fields: Prisma.AiMessageFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.AiMessageFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiMessagePayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.AiMessageFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiMessagePayload>;
        };
        findFirst: {
          args: Prisma.AiMessageFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiMessagePayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.AiMessageFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiMessagePayload>;
        };
        findMany: {
          args: Prisma.AiMessageFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiMessagePayload>[];
        };
        create: {
          args: Prisma.AiMessageCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiMessagePayload>;
        };
        createMany: {
          args: Prisma.AiMessageCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.AiMessageCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiMessagePayload>[];
        };
        delete: {
          args: Prisma.AiMessageDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiMessagePayload>;
        };
        update: {
          args: Prisma.AiMessageUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiMessagePayload>;
        };
        deleteMany: {
          args: Prisma.AiMessageDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.AiMessageUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.AiMessageUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiMessagePayload>[];
        };
        upsert: {
          args: Prisma.AiMessageUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiMessagePayload>;
        };
        aggregate: {
          args: Prisma.AiMessageAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateAiMessage>;
        };
        groupBy: {
          args: Prisma.AiMessageGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AiMessageGroupByOutputType>[];
        };
        count: {
          args: Prisma.AiMessageCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.AiMessageCountAggregateOutputType>
            | number;
        };
      };
    };
    Vote: {
      payload: Prisma.$VotePayload<ExtArgs>;
      fields: Prisma.VoteFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.VoteFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VotePayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.VoteFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VotePayload>;
        };
        findFirst: {
          args: Prisma.VoteFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VotePayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.VoteFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VotePayload>;
        };
        findMany: {
          args: Prisma.VoteFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VotePayload>[];
        };
        create: {
          args: Prisma.VoteCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VotePayload>;
        };
        createMany: {
          args: Prisma.VoteCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.VoteCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VotePayload>[];
        };
        delete: {
          args: Prisma.VoteDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VotePayload>;
        };
        update: {
          args: Prisma.VoteUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VotePayload>;
        };
        deleteMany: {
          args: Prisma.VoteDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.VoteUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.VoteUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VotePayload>[];
        };
        upsert: {
          args: Prisma.VoteUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VotePayload>;
        };
        aggregate: {
          args: Prisma.VoteAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateVote>;
        };
        groupBy: {
          args: Prisma.VoteGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.VoteGroupByOutputType>[];
        };
        count: {
          args: Prisma.VoteCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.VoteCountAggregateOutputType>
            | number;
        };
      };
    };
    AiDocument: {
      payload: Prisma.$AiDocumentPayload<ExtArgs>;
      fields: Prisma.AiDocumentFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.AiDocumentFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiDocumentPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.AiDocumentFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiDocumentPayload>;
        };
        findFirst: {
          args: Prisma.AiDocumentFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiDocumentPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.AiDocumentFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiDocumentPayload>;
        };
        findMany: {
          args: Prisma.AiDocumentFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiDocumentPayload>[];
        };
        create: {
          args: Prisma.AiDocumentCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiDocumentPayload>;
        };
        createMany: {
          args: Prisma.AiDocumentCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.AiDocumentCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiDocumentPayload>[];
        };
        delete: {
          args: Prisma.AiDocumentDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiDocumentPayload>;
        };
        update: {
          args: Prisma.AiDocumentUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiDocumentPayload>;
        };
        deleteMany: {
          args: Prisma.AiDocumentDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.AiDocumentUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.AiDocumentUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiDocumentPayload>[];
        };
        upsert: {
          args: Prisma.AiDocumentUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiDocumentPayload>;
        };
        aggregate: {
          args: Prisma.AiDocumentAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateAiDocument>;
        };
        groupBy: {
          args: Prisma.AiDocumentGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AiDocumentGroupByOutputType>[];
        };
        count: {
          args: Prisma.AiDocumentCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.AiDocumentCountAggregateOutputType>
            | number;
        };
      };
    };
    AiSuggestion: {
      payload: Prisma.$AiSuggestionPayload<ExtArgs>;
      fields: Prisma.AiSuggestionFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.AiSuggestionFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiSuggestionPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.AiSuggestionFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiSuggestionPayload>;
        };
        findFirst: {
          args: Prisma.AiSuggestionFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiSuggestionPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.AiSuggestionFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiSuggestionPayload>;
        };
        findMany: {
          args: Prisma.AiSuggestionFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiSuggestionPayload>[];
        };
        create: {
          args: Prisma.AiSuggestionCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiSuggestionPayload>;
        };
        createMany: {
          args: Prisma.AiSuggestionCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.AiSuggestionCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiSuggestionPayload>[];
        };
        delete: {
          args: Prisma.AiSuggestionDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiSuggestionPayload>;
        };
        update: {
          args: Prisma.AiSuggestionUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiSuggestionPayload>;
        };
        deleteMany: {
          args: Prisma.AiSuggestionDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.AiSuggestionUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.AiSuggestionUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiSuggestionPayload>[];
        };
        upsert: {
          args: Prisma.AiSuggestionUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiSuggestionPayload>;
        };
        aggregate: {
          args: Prisma.AiSuggestionAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateAiSuggestion>;
        };
        groupBy: {
          args: Prisma.AiSuggestionGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AiSuggestionGroupByOutputType>[];
        };
        count: {
          args: Prisma.AiSuggestionCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.AiSuggestionCountAggregateOutputType>
            | number;
        };
      };
    };
    Stream: {
      payload: Prisma.$StreamPayload<ExtArgs>;
      fields: Prisma.StreamFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.StreamFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StreamPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.StreamFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StreamPayload>;
        };
        findFirst: {
          args: Prisma.StreamFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StreamPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.StreamFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StreamPayload>;
        };
        findMany: {
          args: Prisma.StreamFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StreamPayload>[];
        };
        create: {
          args: Prisma.StreamCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StreamPayload>;
        };
        createMany: {
          args: Prisma.StreamCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.StreamCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StreamPayload>[];
        };
        delete: {
          args: Prisma.StreamDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StreamPayload>;
        };
        update: {
          args: Prisma.StreamUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StreamPayload>;
        };
        deleteMany: {
          args: Prisma.StreamDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.StreamUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.StreamUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StreamPayload>[];
        };
        upsert: {
          args: Prisma.StreamUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StreamPayload>;
        };
        aggregate: {
          args: Prisma.StreamAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateStream>;
        };
        groupBy: {
          args: Prisma.StreamGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.StreamGroupByOutputType>[];
        };
        count: {
          args: Prisma.StreamCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.StreamCountAggregateOutputType>
            | number;
        };
      };
    };
    Absence: {
      payload: Prisma.$AbsencePayload<ExtArgs>;
      fields: Prisma.AbsenceFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.AbsenceFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AbsencePayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.AbsenceFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AbsencePayload>;
        };
        findFirst: {
          args: Prisma.AbsenceFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AbsencePayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.AbsenceFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AbsencePayload>;
        };
        findMany: {
          args: Prisma.AbsenceFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AbsencePayload>[];
        };
        create: {
          args: Prisma.AbsenceCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AbsencePayload>;
        };
        createMany: {
          args: Prisma.AbsenceCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.AbsenceCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AbsencePayload>[];
        };
        delete: {
          args: Prisma.AbsenceDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AbsencePayload>;
        };
        update: {
          args: Prisma.AbsenceUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AbsencePayload>;
        };
        deleteMany: {
          args: Prisma.AbsenceDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.AbsenceUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.AbsenceUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AbsencePayload>[];
        };
        upsert: {
          args: Prisma.AbsenceUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AbsencePayload>;
        };
        aggregate: {
          args: Prisma.AbsenceAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateAbsence>;
        };
        groupBy: {
          args: Prisma.AbsenceGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AbsenceGroupByOutputType>[];
        };
        count: {
          args: Prisma.AbsenceCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.AbsenceCountAggregateOutputType>
            | number;
        };
      };
    };
    AbsenceJustification: {
      payload: Prisma.$AbsenceJustificationPayload<ExtArgs>;
      fields: Prisma.AbsenceJustificationFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.AbsenceJustificationFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AbsenceJustificationPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.AbsenceJustificationFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AbsenceJustificationPayload>;
        };
        findFirst: {
          args: Prisma.AbsenceJustificationFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AbsenceJustificationPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.AbsenceJustificationFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AbsenceJustificationPayload>;
        };
        findMany: {
          args: Prisma.AbsenceJustificationFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AbsenceJustificationPayload>[];
        };
        create: {
          args: Prisma.AbsenceJustificationCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AbsenceJustificationPayload>;
        };
        createMany: {
          args: Prisma.AbsenceJustificationCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.AbsenceJustificationCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AbsenceJustificationPayload>[];
        };
        delete: {
          args: Prisma.AbsenceJustificationDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AbsenceJustificationPayload>;
        };
        update: {
          args: Prisma.AbsenceJustificationUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AbsenceJustificationPayload>;
        };
        deleteMany: {
          args: Prisma.AbsenceJustificationDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.AbsenceJustificationUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.AbsenceJustificationUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AbsenceJustificationPayload>[];
        };
        upsert: {
          args: Prisma.AbsenceJustificationUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AbsenceJustificationPayload>;
        };
        aggregate: {
          args: Prisma.AbsenceJustificationAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateAbsenceJustification>;
        };
        groupBy: {
          args: Prisma.AbsenceJustificationGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AbsenceJustificationGroupByOutputType>[];
        };
        count: {
          args: Prisma.AbsenceJustificationCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.AbsenceJustificationCountAggregateOutputType>
            | number;
        };
      };
    };
    Lateness: {
      payload: Prisma.$LatenessPayload<ExtArgs>;
      fields: Prisma.LatenessFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.LatenessFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LatenessPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.LatenessFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LatenessPayload>;
        };
        findFirst: {
          args: Prisma.LatenessFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LatenessPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.LatenessFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LatenessPayload>;
        };
        findMany: {
          args: Prisma.LatenessFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LatenessPayload>[];
        };
        create: {
          args: Prisma.LatenessCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LatenessPayload>;
        };
        createMany: {
          args: Prisma.LatenessCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.LatenessCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LatenessPayload>[];
        };
        delete: {
          args: Prisma.LatenessDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LatenessPayload>;
        };
        update: {
          args: Prisma.LatenessUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LatenessPayload>;
        };
        deleteMany: {
          args: Prisma.LatenessDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.LatenessUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.LatenessUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LatenessPayload>[];
        };
        upsert: {
          args: Prisma.LatenessUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LatenessPayload>;
        };
        aggregate: {
          args: Prisma.LatenessAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateLateness>;
        };
        groupBy: {
          args: Prisma.LatenessGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.LatenessGroupByOutputType>[];
        };
        count: {
          args: Prisma.LatenessCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.LatenessCountAggregateOutputType>
            | number;
        };
      };
    };
    LatenessJustification: {
      payload: Prisma.$LatenessJustificationPayload<ExtArgs>;
      fields: Prisma.LatenessJustificationFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.LatenessJustificationFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LatenessJustificationPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.LatenessJustificationFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LatenessJustificationPayload>;
        };
        findFirst: {
          args: Prisma.LatenessJustificationFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LatenessJustificationPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.LatenessJustificationFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LatenessJustificationPayload>;
        };
        findMany: {
          args: Prisma.LatenessJustificationFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LatenessJustificationPayload>[];
        };
        create: {
          args: Prisma.LatenessJustificationCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LatenessJustificationPayload>;
        };
        createMany: {
          args: Prisma.LatenessJustificationCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.LatenessJustificationCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LatenessJustificationPayload>[];
        };
        delete: {
          args: Prisma.LatenessJustificationDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LatenessJustificationPayload>;
        };
        update: {
          args: Prisma.LatenessJustificationUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LatenessJustificationPayload>;
        };
        deleteMany: {
          args: Prisma.LatenessJustificationDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.LatenessJustificationUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.LatenessJustificationUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LatenessJustificationPayload>[];
        };
        upsert: {
          args: Prisma.LatenessJustificationUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LatenessJustificationPayload>;
        };
        aggregate: {
          args: Prisma.LatenessJustificationAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateLatenessJustification>;
        };
        groupBy: {
          args: Prisma.LatenessJustificationGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.LatenessJustificationGroupByOutputType>[];
        };
        count: {
          args: Prisma.LatenessJustificationCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.LatenessJustificationCountAggregateOutputType>
            | number;
        };
      };
    };
    Chatter: {
      payload: Prisma.$ChatterPayload<ExtArgs>;
      fields: Prisma.ChatterFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.ChatterFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatterPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.ChatterFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatterPayload>;
        };
        findFirst: {
          args: Prisma.ChatterFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatterPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.ChatterFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatterPayload>;
        };
        findMany: {
          args: Prisma.ChatterFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatterPayload>[];
        };
        create: {
          args: Prisma.ChatterCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatterPayload>;
        };
        createMany: {
          args: Prisma.ChatterCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.ChatterCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatterPayload>[];
        };
        delete: {
          args: Prisma.ChatterDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatterPayload>;
        };
        update: {
          args: Prisma.ChatterUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatterPayload>;
        };
        deleteMany: {
          args: Prisma.ChatterDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.ChatterUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.ChatterUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatterPayload>[];
        };
        upsert: {
          args: Prisma.ChatterUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatterPayload>;
        };
        aggregate: {
          args: Prisma.ChatterAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateChatter>;
        };
        groupBy: {
          args: Prisma.ChatterGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.ChatterGroupByOutputType>[];
        };
        count: {
          args: Prisma.ChatterCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.ChatterCountAggregateOutputType>
            | number;
        };
      };
    };
    Consigne: {
      payload: Prisma.$ConsignePayload<ExtArgs>;
      fields: Prisma.ConsigneFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.ConsigneFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsignePayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.ConsigneFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsignePayload>;
        };
        findFirst: {
          args: Prisma.ConsigneFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsignePayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.ConsigneFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsignePayload>;
        };
        findMany: {
          args: Prisma.ConsigneFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsignePayload>[];
        };
        create: {
          args: Prisma.ConsigneCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsignePayload>;
        };
        createMany: {
          args: Prisma.ConsigneCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.ConsigneCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsignePayload>[];
        };
        delete: {
          args: Prisma.ConsigneDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsignePayload>;
        };
        update: {
          args: Prisma.ConsigneUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsignePayload>;
        };
        deleteMany: {
          args: Prisma.ConsigneDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.ConsigneUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.ConsigneUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsignePayload>[];
        };
        upsert: {
          args: Prisma.ConsigneUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConsignePayload>;
        };
        aggregate: {
          args: Prisma.ConsigneAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateConsigne>;
        };
        groupBy: {
          args: Prisma.ConsigneGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.ConsigneGroupByOutputType>[];
        };
        count: {
          args: Prisma.ConsigneCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.ConsigneCountAggregateOutputType>
            | number;
        };
      };
    };
    Exclusion: {
      payload: Prisma.$ExclusionPayload<ExtArgs>;
      fields: Prisma.ExclusionFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.ExclusionFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExclusionPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.ExclusionFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExclusionPayload>;
        };
        findFirst: {
          args: Prisma.ExclusionFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExclusionPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.ExclusionFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExclusionPayload>;
        };
        findMany: {
          args: Prisma.ExclusionFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExclusionPayload>[];
        };
        create: {
          args: Prisma.ExclusionCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExclusionPayload>;
        };
        createMany: {
          args: Prisma.ExclusionCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.ExclusionCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExclusionPayload>[];
        };
        delete: {
          args: Prisma.ExclusionDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExclusionPayload>;
        };
        update: {
          args: Prisma.ExclusionUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExclusionPayload>;
        };
        deleteMany: {
          args: Prisma.ExclusionDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.ExclusionUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.ExclusionUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExclusionPayload>[];
        };
        upsert: {
          args: Prisma.ExclusionUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExclusionPayload>;
        };
        aggregate: {
          args: Prisma.ExclusionAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateExclusion>;
        };
        groupBy: {
          args: Prisma.ExclusionGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.ExclusionGroupByOutputType>[];
        };
        count: {
          args: Prisma.ExclusionCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.ExclusionCountAggregateOutputType>
            | number;
        };
      };
    };
    PreventedAbsence: {
      payload: Prisma.$PreventedAbsencePayload<ExtArgs>;
      fields: Prisma.PreventedAbsenceFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.PreventedAbsenceFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PreventedAbsencePayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.PreventedAbsenceFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PreventedAbsencePayload>;
        };
        findFirst: {
          args: Prisma.PreventedAbsenceFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PreventedAbsencePayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.PreventedAbsenceFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PreventedAbsencePayload>;
        };
        findMany: {
          args: Prisma.PreventedAbsenceFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PreventedAbsencePayload>[];
        };
        create: {
          args: Prisma.PreventedAbsenceCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PreventedAbsencePayload>;
        };
        createMany: {
          args: Prisma.PreventedAbsenceCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.PreventedAbsenceCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PreventedAbsencePayload>[];
        };
        delete: {
          args: Prisma.PreventedAbsenceDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PreventedAbsencePayload>;
        };
        update: {
          args: Prisma.PreventedAbsenceUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PreventedAbsencePayload>;
        };
        deleteMany: {
          args: Prisma.PreventedAbsenceDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.PreventedAbsenceUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.PreventedAbsenceUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PreventedAbsencePayload>[];
        };
        upsert: {
          args: Prisma.PreventedAbsenceUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PreventedAbsencePayload>;
        };
        aggregate: {
          args: Prisma.PreventedAbsenceAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregatePreventedAbsence>;
        };
        groupBy: {
          args: Prisma.PreventedAbsenceGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.PreventedAbsenceGroupByOutputType>[];
        };
        count: {
          args: Prisma.PreventedAbsenceCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.PreventedAbsenceCountAggregateOutputType>
            | number;
        };
      };
    };
    Convocation: {
      payload: Prisma.$ConvocationPayload<ExtArgs>;
      fields: Prisma.ConvocationFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.ConvocationFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConvocationPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.ConvocationFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConvocationPayload>;
        };
        findFirst: {
          args: Prisma.ConvocationFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConvocationPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.ConvocationFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConvocationPayload>;
        };
        findMany: {
          args: Prisma.ConvocationFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConvocationPayload>[];
        };
        create: {
          args: Prisma.ConvocationCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConvocationPayload>;
        };
        createMany: {
          args: Prisma.ConvocationCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.ConvocationCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConvocationPayload>[];
        };
        delete: {
          args: Prisma.ConvocationDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConvocationPayload>;
        };
        update: {
          args: Prisma.ConvocationUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConvocationPayload>;
        };
        deleteMany: {
          args: Prisma.ConvocationDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.ConvocationUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.ConvocationUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConvocationPayload>[];
        };
        upsert: {
          args: Prisma.ConvocationUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConvocationPayload>;
        };
        aggregate: {
          args: Prisma.ConvocationAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateConvocation>;
        };
        groupBy: {
          args: Prisma.ConvocationGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.ConvocationGroupByOutputType>[];
        };
        count: {
          args: Prisma.ConvocationCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.ConvocationCountAggregateOutputType>
            | number;
        };
      };
    };
    TimetableCategory: {
      payload: Prisma.$TimetableCategoryPayload<ExtArgs>;
      fields: Prisma.TimetableCategoryFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.TimetableCategoryFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimetableCategoryPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.TimetableCategoryFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimetableCategoryPayload>;
        };
        findFirst: {
          args: Prisma.TimetableCategoryFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimetableCategoryPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.TimetableCategoryFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimetableCategoryPayload>;
        };
        findMany: {
          args: Prisma.TimetableCategoryFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimetableCategoryPayload>[];
        };
        create: {
          args: Prisma.TimetableCategoryCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimetableCategoryPayload>;
        };
        createMany: {
          args: Prisma.TimetableCategoryCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.TimetableCategoryCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimetableCategoryPayload>[];
        };
        delete: {
          args: Prisma.TimetableCategoryDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimetableCategoryPayload>;
        };
        update: {
          args: Prisma.TimetableCategoryUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimetableCategoryPayload>;
        };
        deleteMany: {
          args: Prisma.TimetableCategoryDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.TimetableCategoryUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.TimetableCategoryUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimetableCategoryPayload>[];
        };
        upsert: {
          args: Prisma.TimetableCategoryUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimetableCategoryPayload>;
        };
        aggregate: {
          args: Prisma.TimetableCategoryAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateTimetableCategory>;
        };
        groupBy: {
          args: Prisma.TimetableCategoryGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.TimetableCategoryGroupByOutputType>[];
        };
        count: {
          args: Prisma.TimetableCategoryCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.TimetableCategoryCountAggregateOutputType>
            | number;
        };
      };
    };
    SubjectTimetable: {
      payload: Prisma.$SubjectTimetablePayload<ExtArgs>;
      fields: Prisma.SubjectTimetableFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.SubjectTimetableFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubjectTimetablePayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.SubjectTimetableFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubjectTimetablePayload>;
        };
        findFirst: {
          args: Prisma.SubjectTimetableFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubjectTimetablePayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.SubjectTimetableFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubjectTimetablePayload>;
        };
        findMany: {
          args: Prisma.SubjectTimetableFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubjectTimetablePayload>[];
        };
        create: {
          args: Prisma.SubjectTimetableCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubjectTimetablePayload>;
        };
        createMany: {
          args: Prisma.SubjectTimetableCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.SubjectTimetableCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubjectTimetablePayload>[];
        };
        delete: {
          args: Prisma.SubjectTimetableDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubjectTimetablePayload>;
        };
        update: {
          args: Prisma.SubjectTimetableUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubjectTimetablePayload>;
        };
        deleteMany: {
          args: Prisma.SubjectTimetableDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.SubjectTimetableUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.SubjectTimetableUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubjectTimetablePayload>[];
        };
        upsert: {
          args: Prisma.SubjectTimetableUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubjectTimetablePayload>;
        };
        aggregate: {
          args: Prisma.SubjectTimetableAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateSubjectTimetable>;
        };
        groupBy: {
          args: Prisma.SubjectTimetableGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.SubjectTimetableGroupByOutputType>[];
        };
        count: {
          args: Prisma.SubjectTimetableCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.SubjectTimetableCountAggregateOutputType>
            | number;
        };
      };
    };
    PeriodicAttendance: {
      payload: Prisma.$PeriodicAttendancePayload<ExtArgs>;
      fields: Prisma.PeriodicAttendanceFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.PeriodicAttendanceFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodicAttendancePayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.PeriodicAttendanceFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodicAttendancePayload>;
        };
        findFirst: {
          args: Prisma.PeriodicAttendanceFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodicAttendancePayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.PeriodicAttendanceFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodicAttendancePayload>;
        };
        findMany: {
          args: Prisma.PeriodicAttendanceFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodicAttendancePayload>[];
        };
        create: {
          args: Prisma.PeriodicAttendanceCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodicAttendancePayload>;
        };
        createMany: {
          args: Prisma.PeriodicAttendanceCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.PeriodicAttendanceCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodicAttendancePayload>[];
        };
        delete: {
          args: Prisma.PeriodicAttendanceDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodicAttendancePayload>;
        };
        update: {
          args: Prisma.PeriodicAttendanceUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodicAttendancePayload>;
        };
        deleteMany: {
          args: Prisma.PeriodicAttendanceDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.PeriodicAttendanceUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.PeriodicAttendanceUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodicAttendancePayload>[];
        };
        upsert: {
          args: Prisma.PeriodicAttendanceUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodicAttendancePayload>;
        };
        aggregate: {
          args: Prisma.PeriodicAttendanceAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregatePeriodicAttendance>;
        };
        groupBy: {
          args: Prisma.PeriodicAttendanceGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.PeriodicAttendanceGroupByOutputType>[];
        };
        count: {
          args: Prisma.PeriodicAttendanceCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.PeriodicAttendanceCountAggregateOutputType>
            | number;
        };
      };
    };
    BibleText: {
      payload: Prisma.$BibleTextPayload<ExtArgs>;
      fields: Prisma.BibleTextFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.BibleTextFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BibleTextPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.BibleTextFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BibleTextPayload>;
        };
        findFirst: {
          args: Prisma.BibleTextFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BibleTextPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.BibleTextFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BibleTextPayload>;
        };
        findMany: {
          args: Prisma.BibleTextFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BibleTextPayload>[];
        };
        create: {
          args: Prisma.BibleTextCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BibleTextPayload>;
        };
        createMany: {
          args: Prisma.BibleTextCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.BibleTextCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BibleTextPayload>[];
        };
        delete: {
          args: Prisma.BibleTextDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BibleTextPayload>;
        };
        update: {
          args: Prisma.BibleTextUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BibleTextPayload>;
        };
        deleteMany: {
          args: Prisma.BibleTextDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.BibleTextUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.BibleTextUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BibleTextPayload>[];
        };
        upsert: {
          args: Prisma.BibleTextUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BibleTextPayload>;
        };
        aggregate: {
          args: Prisma.BibleTextAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateBibleText>;
        };
        groupBy: {
          args: Prisma.BibleTextGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.BibleTextGroupByOutputType>[];
        };
        count: {
          args: Prisma.BibleTextCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.BibleTextCountAggregateOutputType>
            | number;
        };
      };
    };
    InventoryAsset: {
      payload: Prisma.$InventoryAssetPayload<ExtArgs>;
      fields: Prisma.InventoryAssetFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.InventoryAssetFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryAssetPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.InventoryAssetFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryAssetPayload>;
        };
        findFirst: {
          args: Prisma.InventoryAssetFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryAssetPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.InventoryAssetFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryAssetPayload>;
        };
        findMany: {
          args: Prisma.InventoryAssetFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryAssetPayload>[];
        };
        create: {
          args: Prisma.InventoryAssetCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryAssetPayload>;
        };
        createMany: {
          args: Prisma.InventoryAssetCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.InventoryAssetCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryAssetPayload>[];
        };
        delete: {
          args: Prisma.InventoryAssetDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryAssetPayload>;
        };
        update: {
          args: Prisma.InventoryAssetUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryAssetPayload>;
        };
        deleteMany: {
          args: Prisma.InventoryAssetDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.InventoryAssetUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.InventoryAssetUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryAssetPayload>[];
        };
        upsert: {
          args: Prisma.InventoryAssetUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryAssetPayload>;
        };
        aggregate: {
          args: Prisma.InventoryAssetAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateInventoryAsset>;
        };
        groupBy: {
          args: Prisma.InventoryAssetGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.InventoryAssetGroupByOutputType>[];
        };
        count: {
          args: Prisma.InventoryAssetCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.InventoryAssetCountAggregateOutputType>
            | number;
        };
      };
    };
    InventoryConsumable: {
      payload: Prisma.$InventoryConsumablePayload<ExtArgs>;
      fields: Prisma.InventoryConsumableFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.InventoryConsumableFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryConsumablePayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.InventoryConsumableFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryConsumablePayload>;
        };
        findFirst: {
          args: Prisma.InventoryConsumableFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryConsumablePayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.InventoryConsumableFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryConsumablePayload>;
        };
        findMany: {
          args: Prisma.InventoryConsumableFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryConsumablePayload>[];
        };
        create: {
          args: Prisma.InventoryConsumableCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryConsumablePayload>;
        };
        createMany: {
          args: Prisma.InventoryConsumableCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.InventoryConsumableCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryConsumablePayload>[];
        };
        delete: {
          args: Prisma.InventoryConsumableDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryConsumablePayload>;
        };
        update: {
          args: Prisma.InventoryConsumableUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryConsumablePayload>;
        };
        deleteMany: {
          args: Prisma.InventoryConsumableDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.InventoryConsumableUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.InventoryConsumableUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryConsumablePayload>[];
        };
        upsert: {
          args: Prisma.InventoryConsumableUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryConsumablePayload>;
        };
        aggregate: {
          args: Prisma.InventoryConsumableAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateInventoryConsumable>;
        };
        groupBy: {
          args: Prisma.InventoryConsumableGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.InventoryConsumableGroupByOutputType>[];
        };
        count: {
          args: Prisma.InventoryConsumableCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.InventoryConsumableCountAggregateOutputType>
            | number;
        };
      };
    };
    InventoryAssetUsage: {
      payload: Prisma.$InventoryAssetUsagePayload<ExtArgs>;
      fields: Prisma.InventoryAssetUsageFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.InventoryAssetUsageFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryAssetUsagePayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.InventoryAssetUsageFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryAssetUsagePayload>;
        };
        findFirst: {
          args: Prisma.InventoryAssetUsageFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryAssetUsagePayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.InventoryAssetUsageFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryAssetUsagePayload>;
        };
        findMany: {
          args: Prisma.InventoryAssetUsageFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryAssetUsagePayload>[];
        };
        create: {
          args: Prisma.InventoryAssetUsageCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryAssetUsagePayload>;
        };
        createMany: {
          args: Prisma.InventoryAssetUsageCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.InventoryAssetUsageCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryAssetUsagePayload>[];
        };
        delete: {
          args: Prisma.InventoryAssetUsageDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryAssetUsagePayload>;
        };
        update: {
          args: Prisma.InventoryAssetUsageUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryAssetUsagePayload>;
        };
        deleteMany: {
          args: Prisma.InventoryAssetUsageDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.InventoryAssetUsageUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.InventoryAssetUsageUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryAssetUsagePayload>[];
        };
        upsert: {
          args: Prisma.InventoryAssetUsageUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryAssetUsagePayload>;
        };
        aggregate: {
          args: Prisma.InventoryAssetUsageAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateInventoryAssetUsage>;
        };
        groupBy: {
          args: Prisma.InventoryAssetUsageGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.InventoryAssetUsageGroupByOutputType>[];
        };
        count: {
          args: Prisma.InventoryAssetUsageCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.InventoryAssetUsageCountAggregateOutputType>
            | number;
        };
      };
    };
    InventoryConsumableUsage: {
      payload: Prisma.$InventoryConsumableUsagePayload<ExtArgs>;
      fields: Prisma.InventoryConsumableUsageFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.InventoryConsumableUsageFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryConsumableUsagePayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.InventoryConsumableUsageFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryConsumableUsagePayload>;
        };
        findFirst: {
          args: Prisma.InventoryConsumableUsageFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryConsumableUsagePayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.InventoryConsumableUsageFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryConsumableUsagePayload>;
        };
        findMany: {
          args: Prisma.InventoryConsumableUsageFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryConsumableUsagePayload>[];
        };
        create: {
          args: Prisma.InventoryConsumableUsageCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryConsumableUsagePayload>;
        };
        createMany: {
          args: Prisma.InventoryConsumableUsageCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.InventoryConsumableUsageCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryConsumableUsagePayload>[];
        };
        delete: {
          args: Prisma.InventoryConsumableUsageDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryConsumableUsagePayload>;
        };
        update: {
          args: Prisma.InventoryConsumableUsageUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryConsumableUsagePayload>;
        };
        deleteMany: {
          args: Prisma.InventoryConsumableUsageDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.InventoryConsumableUsageUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.InventoryConsumableUsageUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryConsumableUsagePayload>[];
        };
        upsert: {
          args: Prisma.InventoryConsumableUsageUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryConsumableUsagePayload>;
        };
        aggregate: {
          args: Prisma.InventoryConsumableUsageAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateInventoryConsumableUsage>;
        };
        groupBy: {
          args: Prisma.InventoryConsumableUsageGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.InventoryConsumableUsageGroupByOutputType>[];
        };
        count: {
          args: Prisma.InventoryConsumableUsageCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.InventoryConsumableUsageCountAggregateOutputType>
            | number;
        };
      };
    };
    InventoryUnit: {
      payload: Prisma.$InventoryUnitPayload<ExtArgs>;
      fields: Prisma.InventoryUnitFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.InventoryUnitFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryUnitPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.InventoryUnitFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryUnitPayload>;
        };
        findFirst: {
          args: Prisma.InventoryUnitFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryUnitPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.InventoryUnitFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryUnitPayload>;
        };
        findMany: {
          args: Prisma.InventoryUnitFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryUnitPayload>[];
        };
        create: {
          args: Prisma.InventoryUnitCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryUnitPayload>;
        };
        createMany: {
          args: Prisma.InventoryUnitCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.InventoryUnitCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryUnitPayload>[];
        };
        delete: {
          args: Prisma.InventoryUnitDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryUnitPayload>;
        };
        update: {
          args: Prisma.InventoryUnitUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryUnitPayload>;
        };
        deleteMany: {
          args: Prisma.InventoryUnitDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.InventoryUnitUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.InventoryUnitUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryUnitPayload>[];
        };
        upsert: {
          args: Prisma.InventoryUnitUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryUnitPayload>;
        };
        aggregate: {
          args: Prisma.InventoryUnitAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateInventoryUnit>;
        };
        groupBy: {
          args: Prisma.InventoryUnitGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.InventoryUnitGroupByOutputType>[];
        };
        count: {
          args: Prisma.InventoryUnitCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.InventoryUnitCountAggregateOutputType>
            | number;
        };
      };
    };
    InventoryStockMovement: {
      payload: Prisma.$InventoryStockMovementPayload<ExtArgs>;
      fields: Prisma.InventoryStockMovementFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.InventoryStockMovementFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryStockMovementPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.InventoryStockMovementFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryStockMovementPayload>;
        };
        findFirst: {
          args: Prisma.InventoryStockMovementFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryStockMovementPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.InventoryStockMovementFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryStockMovementPayload>;
        };
        findMany: {
          args: Prisma.InventoryStockMovementFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryStockMovementPayload>[];
        };
        create: {
          args: Prisma.InventoryStockMovementCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryStockMovementPayload>;
        };
        createMany: {
          args: Prisma.InventoryStockMovementCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.InventoryStockMovementCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryStockMovementPayload>[];
        };
        delete: {
          args: Prisma.InventoryStockMovementDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryStockMovementPayload>;
        };
        update: {
          args: Prisma.InventoryStockMovementUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryStockMovementPayload>;
        };
        deleteMany: {
          args: Prisma.InventoryStockMovementDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.InventoryStockMovementUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.InventoryStockMovementUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryStockMovementPayload>[];
        };
        upsert: {
          args: Prisma.InventoryStockMovementUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryStockMovementPayload>;
        };
        aggregate: {
          args: Prisma.InventoryStockMovementAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateInventoryStockMovement>;
        };
        groupBy: {
          args: Prisma.InventoryStockMovementGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.InventoryStockMovementGroupByOutputType>[];
        };
        count: {
          args: Prisma.InventoryStockMovementCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.InventoryStockMovementCountAggregateOutputType>
            | number;
        };
      };
    };
    Book: {
      payload: Prisma.$BookPayload<ExtArgs>;
      fields: Prisma.BookFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.BookFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BookPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.BookFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BookPayload>;
        };
        findFirst: {
          args: Prisma.BookFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BookPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.BookFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BookPayload>;
        };
        findMany: {
          args: Prisma.BookFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BookPayload>[];
        };
        create: {
          args: Prisma.BookCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BookPayload>;
        };
        createMany: {
          args: Prisma.BookCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.BookCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BookPayload>[];
        };
        delete: {
          args: Prisma.BookDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BookPayload>;
        };
        update: {
          args: Prisma.BookUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BookPayload>;
        };
        deleteMany: {
          args: Prisma.BookDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.BookUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.BookUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BookPayload>[];
        };
        upsert: {
          args: Prisma.BookUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BookPayload>;
        };
        aggregate: {
          args: Prisma.BookAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateBook>;
        };
        groupBy: {
          args: Prisma.BookGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.BookGroupByOutputType>[];
        };
        count: {
          args: Prisma.BookCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.BookCountAggregateOutputType>
            | number;
        };
      };
    };
    BookCategory: {
      payload: Prisma.$BookCategoryPayload<ExtArgs>;
      fields: Prisma.BookCategoryFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.BookCategoryFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BookCategoryPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.BookCategoryFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BookCategoryPayload>;
        };
        findFirst: {
          args: Prisma.BookCategoryFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BookCategoryPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.BookCategoryFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BookCategoryPayload>;
        };
        findMany: {
          args: Prisma.BookCategoryFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BookCategoryPayload>[];
        };
        create: {
          args: Prisma.BookCategoryCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BookCategoryPayload>;
        };
        createMany: {
          args: Prisma.BookCategoryCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.BookCategoryCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BookCategoryPayload>[];
        };
        delete: {
          args: Prisma.BookCategoryDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BookCategoryPayload>;
        };
        update: {
          args: Prisma.BookCategoryUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BookCategoryPayload>;
        };
        deleteMany: {
          args: Prisma.BookCategoryDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.BookCategoryUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.BookCategoryUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BookCategoryPayload>[];
        };
        upsert: {
          args: Prisma.BookCategoryUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BookCategoryPayload>;
        };
        aggregate: {
          args: Prisma.BookCategoryAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateBookCategory>;
        };
        groupBy: {
          args: Prisma.BookCategoryGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.BookCategoryGroupByOutputType>[];
        };
        count: {
          args: Prisma.BookCategoryCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.BookCategoryCountAggregateOutputType>
            | number;
        };
      };
    };
    BorrowedBook: {
      payload: Prisma.$BorrowedBookPayload<ExtArgs>;
      fields: Prisma.BorrowedBookFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.BorrowedBookFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BorrowedBookPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.BorrowedBookFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BorrowedBookPayload>;
        };
        findFirst: {
          args: Prisma.BorrowedBookFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BorrowedBookPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.BorrowedBookFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BorrowedBookPayload>;
        };
        findMany: {
          args: Prisma.BorrowedBookFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BorrowedBookPayload>[];
        };
        create: {
          args: Prisma.BorrowedBookCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BorrowedBookPayload>;
        };
        createMany: {
          args: Prisma.BorrowedBookCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.BorrowedBookCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BorrowedBookPayload>[];
        };
        delete: {
          args: Prisma.BorrowedBookDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BorrowedBookPayload>;
        };
        update: {
          args: Prisma.BorrowedBookUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BorrowedBookPayload>;
        };
        deleteMany: {
          args: Prisma.BorrowedBookDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.BorrowedBookUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.BorrowedBookUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BorrowedBookPayload>[];
        };
        upsert: {
          args: Prisma.BorrowedBookUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BorrowedBookPayload>;
        };
        aggregate: {
          args: Prisma.BorrowedBookAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateBorrowedBook>;
        };
        groupBy: {
          args: Prisma.BorrowedBookGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.BorrowedBookGroupByOutputType>[];
        };
        count: {
          args: Prisma.BorrowedBookCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.BorrowedBookCountAggregateOutputType>
            | number;
        };
      };
    };
    Shortcut: {
      payload: Prisma.$ShortcutPayload<ExtArgs>;
      fields: Prisma.ShortcutFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.ShortcutFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShortcutPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.ShortcutFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShortcutPayload>;
        };
        findFirst: {
          args: Prisma.ShortcutFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShortcutPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.ShortcutFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShortcutPayload>;
        };
        findMany: {
          args: Prisma.ShortcutFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShortcutPayload>[];
        };
        create: {
          args: Prisma.ShortcutCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShortcutPayload>;
        };
        createMany: {
          args: Prisma.ShortcutCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.ShortcutCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShortcutPayload>[];
        };
        delete: {
          args: Prisma.ShortcutDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShortcutPayload>;
        };
        update: {
          args: Prisma.ShortcutUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShortcutPayload>;
        };
        deleteMany: {
          args: Prisma.ShortcutDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.ShortcutUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.ShortcutUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShortcutPayload>[];
        };
        upsert: {
          args: Prisma.ShortcutUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShortcutPayload>;
        };
        aggregate: {
          args: Prisma.ShortcutAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateShortcut>;
        };
        groupBy: {
          args: Prisma.ShortcutGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.ShortcutGroupByOutputType>[];
        };
        count: {
          args: Prisma.ShortcutCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.ShortcutCountAggregateOutputType>
            | number;
        };
      };
    };
    Email: {
      payload: Prisma.$EmailPayload<ExtArgs>;
      fields: Prisma.EmailFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.EmailFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.EmailFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailPayload>;
        };
        findFirst: {
          args: Prisma.EmailFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.EmailFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailPayload>;
        };
        findMany: {
          args: Prisma.EmailFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailPayload>[];
        };
        create: {
          args: Prisma.EmailCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailPayload>;
        };
        createMany: {
          args: Prisma.EmailCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.EmailCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailPayload>[];
        };
        delete: {
          args: Prisma.EmailDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailPayload>;
        };
        update: {
          args: Prisma.EmailUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailPayload>;
        };
        deleteMany: {
          args: Prisma.EmailDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.EmailUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.EmailUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailPayload>[];
        };
        upsert: {
          args: Prisma.EmailUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailPayload>;
        };
        aggregate: {
          args: Prisma.EmailAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateEmail>;
        };
        groupBy: {
          args: Prisma.EmailGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.EmailGroupByOutputType>[];
        };
        count: {
          args: Prisma.EmailCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.EmailCountAggregateOutputType>
            | number;
        };
      };
    };
    EmailRecipient: {
      payload: Prisma.$EmailRecipientPayload<ExtArgs>;
      fields: Prisma.EmailRecipientFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.EmailRecipientFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailRecipientPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.EmailRecipientFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailRecipientPayload>;
        };
        findFirst: {
          args: Prisma.EmailRecipientFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailRecipientPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.EmailRecipientFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailRecipientPayload>;
        };
        findMany: {
          args: Prisma.EmailRecipientFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailRecipientPayload>[];
        };
        create: {
          args: Prisma.EmailRecipientCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailRecipientPayload>;
        };
        createMany: {
          args: Prisma.EmailRecipientCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.EmailRecipientCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailRecipientPayload>[];
        };
        delete: {
          args: Prisma.EmailRecipientDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailRecipientPayload>;
        };
        update: {
          args: Prisma.EmailRecipientUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailRecipientPayload>;
        };
        deleteMany: {
          args: Prisma.EmailRecipientDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.EmailRecipientUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.EmailRecipientUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailRecipientPayload>[];
        };
        upsert: {
          args: Prisma.EmailRecipientUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailRecipientPayload>;
        };
        aggregate: {
          args: Prisma.EmailRecipientAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateEmailRecipient>;
        };
        groupBy: {
          args: Prisma.EmailRecipientGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.EmailRecipientGroupByOutputType>[];
        };
        count: {
          args: Prisma.EmailRecipientCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.EmailRecipientCountAggregateOutputType>
            | number;
        };
      };
    };
    Attachment: {
      payload: Prisma.$AttachmentPayload<ExtArgs>;
      fields: Prisma.AttachmentFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.AttachmentFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttachmentPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.AttachmentFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttachmentPayload>;
        };
        findFirst: {
          args: Prisma.AttachmentFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttachmentPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.AttachmentFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttachmentPayload>;
        };
        findMany: {
          args: Prisma.AttachmentFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttachmentPayload>[];
        };
        create: {
          args: Prisma.AttachmentCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttachmentPayload>;
        };
        createMany: {
          args: Prisma.AttachmentCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.AttachmentCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttachmentPayload>[];
        };
        delete: {
          args: Prisma.AttachmentDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttachmentPayload>;
        };
        update: {
          args: Prisma.AttachmentUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttachmentPayload>;
        };
        deleteMany: {
          args: Prisma.AttachmentDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.AttachmentUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.AttachmentUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttachmentPayload>[];
        };
        upsert: {
          args: Prisma.AttachmentUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttachmentPayload>;
        };
        aggregate: {
          args: Prisma.AttachmentAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateAttachment>;
        };
        groupBy: {
          args: Prisma.AttachmentGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AttachmentGroupByOutputType>[];
        };
        count: {
          args: Prisma.AttachmentCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.AttachmentCountAggregateOutputType>
            | number;
        };
      };
    };
    CommunicationChannel: {
      payload: Prisma.$CommunicationChannelPayload<ExtArgs>;
      fields: Prisma.CommunicationChannelFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.CommunicationChannelFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationChannelPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.CommunicationChannelFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationChannelPayload>;
        };
        findFirst: {
          args: Prisma.CommunicationChannelFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationChannelPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.CommunicationChannelFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationChannelPayload>;
        };
        findMany: {
          args: Prisma.CommunicationChannelFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationChannelPayload>[];
        };
        create: {
          args: Prisma.CommunicationChannelCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationChannelPayload>;
        };
        createMany: {
          args: Prisma.CommunicationChannelCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.CommunicationChannelCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationChannelPayload>[];
        };
        delete: {
          args: Prisma.CommunicationChannelDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationChannelPayload>;
        };
        update: {
          args: Prisma.CommunicationChannelUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationChannelPayload>;
        };
        deleteMany: {
          args: Prisma.CommunicationChannelDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.CommunicationChannelUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.CommunicationChannelUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationChannelPayload>[];
        };
        upsert: {
          args: Prisma.CommunicationChannelUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationChannelPayload>;
        };
        aggregate: {
          args: Prisma.CommunicationChannelAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateCommunicationChannel>;
        };
        groupBy: {
          args: Prisma.CommunicationChannelGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.CommunicationChannelGroupByOutputType>[];
        };
        count: {
          args: Prisma.CommunicationChannelCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.CommunicationChannelCountAggregateOutputType>
            | number;
        };
      };
    };
    RecipientGroup: {
      payload: Prisma.$RecipientGroupPayload<ExtArgs>;
      fields: Prisma.RecipientGroupFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.RecipientGroupFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecipientGroupPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.RecipientGroupFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecipientGroupPayload>;
        };
        findFirst: {
          args: Prisma.RecipientGroupFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecipientGroupPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.RecipientGroupFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecipientGroupPayload>;
        };
        findMany: {
          args: Prisma.RecipientGroupFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecipientGroupPayload>[];
        };
        create: {
          args: Prisma.RecipientGroupCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecipientGroupPayload>;
        };
        createMany: {
          args: Prisma.RecipientGroupCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.RecipientGroupCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecipientGroupPayload>[];
        };
        delete: {
          args: Prisma.RecipientGroupDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecipientGroupPayload>;
        };
        update: {
          args: Prisma.RecipientGroupUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecipientGroupPayload>;
        };
        deleteMany: {
          args: Prisma.RecipientGroupDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.RecipientGroupUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.RecipientGroupUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecipientGroupPayload>[];
        };
        upsert: {
          args: Prisma.RecipientGroupUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecipientGroupPayload>;
        };
        aggregate: {
          args: Prisma.RecipientGroupAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateRecipientGroup>;
        };
        groupBy: {
          args: Prisma.RecipientGroupGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.RecipientGroupGroupByOutputType>[];
        };
        count: {
          args: Prisma.RecipientGroupCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.RecipientGroupCountAggregateOutputType>
            | number;
        };
      };
    };
    Feedback: {
      payload: Prisma.$FeedbackPayload<ExtArgs>;
      fields: Prisma.FeedbackFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.FeedbackFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.FeedbackFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackPayload>;
        };
        findFirst: {
          args: Prisma.FeedbackFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.FeedbackFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackPayload>;
        };
        findMany: {
          args: Prisma.FeedbackFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackPayload>[];
        };
        create: {
          args: Prisma.FeedbackCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackPayload>;
        };
        createMany: {
          args: Prisma.FeedbackCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.FeedbackCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackPayload>[];
        };
        delete: {
          args: Prisma.FeedbackDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackPayload>;
        };
        update: {
          args: Prisma.FeedbackUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackPayload>;
        };
        deleteMany: {
          args: Prisma.FeedbackDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.FeedbackUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.FeedbackUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackPayload>[];
        };
        upsert: {
          args: Prisma.FeedbackUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackPayload>;
        };
        aggregate: {
          args: Prisma.FeedbackAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateFeedback>;
        };
        groupBy: {
          args: Prisma.FeedbackGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.FeedbackGroupByOutputType>[];
        };
        count: {
          args: Prisma.FeedbackCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.FeedbackCountAggregateOutputType>
            | number;
        };
      };
    };
    Recipient: {
      payload: Prisma.$RecipientPayload<ExtArgs>;
      fields: Prisma.RecipientFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.RecipientFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecipientPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.RecipientFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecipientPayload>;
        };
        findFirst: {
          args: Prisma.RecipientFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecipientPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.RecipientFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecipientPayload>;
        };
        findMany: {
          args: Prisma.RecipientFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecipientPayload>[];
        };
        create: {
          args: Prisma.RecipientCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecipientPayload>;
        };
        createMany: {
          args: Prisma.RecipientCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.RecipientCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecipientPayload>[];
        };
        delete: {
          args: Prisma.RecipientDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecipientPayload>;
        };
        update: {
          args: Prisma.RecipientUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecipientPayload>;
        };
        deleteMany: {
          args: Prisma.RecipientDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.RecipientUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.RecipientUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecipientPayload>[];
        };
        upsert: {
          args: Prisma.RecipientUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecipientPayload>;
        };
        aggregate: {
          args: Prisma.RecipientAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateRecipient>;
        };
        groupBy: {
          args: Prisma.RecipientGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.RecipientGroupByOutputType>[];
        };
        count: {
          args: Prisma.RecipientCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.RecipientCountAggregateOutputType>
            | number;
        };
      };
    };
    Announcement: {
      payload: Prisma.$AnnouncementPayload<ExtArgs>;
      fields: Prisma.AnnouncementFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.AnnouncementFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.AnnouncementFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload>;
        };
        findFirst: {
          args: Prisma.AnnouncementFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.AnnouncementFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload>;
        };
        findMany: {
          args: Prisma.AnnouncementFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload>[];
        };
        create: {
          args: Prisma.AnnouncementCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload>;
        };
        createMany: {
          args: Prisma.AnnouncementCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.AnnouncementCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload>[];
        };
        delete: {
          args: Prisma.AnnouncementDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload>;
        };
        update: {
          args: Prisma.AnnouncementUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload>;
        };
        deleteMany: {
          args: Prisma.AnnouncementDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.AnnouncementUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.AnnouncementUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload>[];
        };
        upsert: {
          args: Prisma.AnnouncementUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload>;
        };
        aggregate: {
          args: Prisma.AnnouncementAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateAnnouncement>;
        };
        groupBy: {
          args: Prisma.AnnouncementGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AnnouncementGroupByOutputType>[];
        };
        count: {
          args: Prisma.AnnouncementCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.AnnouncementCountAggregateOutputType>
            | number;
        };
      };
    };
    Policy: {
      payload: Prisma.$PolicyPayload<ExtArgs>;
      fields: Prisma.PolicyFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.PolicyFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PolicyPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.PolicyFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PolicyPayload>;
        };
        findFirst: {
          args: Prisma.PolicyFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PolicyPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.PolicyFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PolicyPayload>;
        };
        findMany: {
          args: Prisma.PolicyFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PolicyPayload>[];
        };
        create: {
          args: Prisma.PolicyCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PolicyPayload>;
        };
        createMany: {
          args: Prisma.PolicyCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.PolicyCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PolicyPayload>[];
        };
        delete: {
          args: Prisma.PolicyDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PolicyPayload>;
        };
        update: {
          args: Prisma.PolicyUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PolicyPayload>;
        };
        deleteMany: {
          args: Prisma.PolicyDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.PolicyUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.PolicyUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PolicyPayload>[];
        };
        upsert: {
          args: Prisma.PolicyUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PolicyPayload>;
        };
        aggregate: {
          args: Prisma.PolicyAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregatePolicy>;
        };
        groupBy: {
          args: Prisma.PolicyGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.PolicyGroupByOutputType>[];
        };
        count: {
          args: Prisma.PolicyCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.PolicyCountAggregateOutputType>
            | number;
        };
      };
    };
    Appreciation: {
      payload: Prisma.$AppreciationPayload<ExtArgs>;
      fields: Prisma.AppreciationFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.AppreciationFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.AppreciationFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationPayload>;
        };
        findFirst: {
          args: Prisma.AppreciationFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.AppreciationFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationPayload>;
        };
        findMany: {
          args: Prisma.AppreciationFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationPayload>[];
        };
        create: {
          args: Prisma.AppreciationCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationPayload>;
        };
        createMany: {
          args: Prisma.AppreciationCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.AppreciationCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationPayload>[];
        };
        delete: {
          args: Prisma.AppreciationDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationPayload>;
        };
        update: {
          args: Prisma.AppreciationUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationPayload>;
        };
        deleteMany: {
          args: Prisma.AppreciationDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.AppreciationUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.AppreciationUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationPayload>[];
        };
        upsert: {
          args: Prisma.AppreciationUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationPayload>;
        };
        aggregate: {
          args: Prisma.AppreciationAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateAppreciation>;
        };
        groupBy: {
          args: Prisma.AppreciationGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AppreciationGroupByOutputType>[];
        };
        count: {
          args: Prisma.AppreciationCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.AppreciationCountAggregateOutputType>
            | number;
        };
      };
    };
    ReportCard: {
      payload: Prisma.$ReportCardPayload<ExtArgs>;
      fields: Prisma.ReportCardFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.ReportCardFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportCardPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.ReportCardFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportCardPayload>;
        };
        findFirst: {
          args: Prisma.ReportCardFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportCardPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.ReportCardFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportCardPayload>;
        };
        findMany: {
          args: Prisma.ReportCardFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportCardPayload>[];
        };
        create: {
          args: Prisma.ReportCardCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportCardPayload>;
        };
        createMany: {
          args: Prisma.ReportCardCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.ReportCardCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportCardPayload>[];
        };
        delete: {
          args: Prisma.ReportCardDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportCardPayload>;
        };
        update: {
          args: Prisma.ReportCardUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportCardPayload>;
        };
        deleteMany: {
          args: Prisma.ReportCardDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.ReportCardUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.ReportCardUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportCardPayload>[];
        };
        upsert: {
          args: Prisma.ReportCardUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportCardPayload>;
        };
        aggregate: {
          args: Prisma.ReportCardAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateReportCard>;
        };
        groupBy: {
          args: Prisma.ReportCardGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.ReportCardGroupByOutputType>[];
        };
        count: {
          args: Prisma.ReportCardCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.ReportCardCountAggregateOutputType>
            | number;
        };
      };
    };
    Report: {
      payload: Prisma.$ReportPayload<ExtArgs>;
      fields: Prisma.ReportFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.ReportFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.ReportFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>;
        };
        findFirst: {
          args: Prisma.ReportFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.ReportFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>;
        };
        findMany: {
          args: Prisma.ReportFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>[];
        };
        create: {
          args: Prisma.ReportCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>;
        };
        createMany: {
          args: Prisma.ReportCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.ReportCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>[];
        };
        delete: {
          args: Prisma.ReportDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>;
        };
        update: {
          args: Prisma.ReportUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>;
        };
        deleteMany: {
          args: Prisma.ReportDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.ReportUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.ReportUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>[];
        };
        upsert: {
          args: Prisma.ReportUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>;
        };
        aggregate: {
          args: Prisma.ReportAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateReport>;
        };
        groupBy: {
          args: Prisma.ReportGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.ReportGroupByOutputType>[];
        };
        count: {
          args: Prisma.ReportCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.ReportCountAggregateOutputType>
            | number;
        };
      };
    };
    HealthVisit: {
      payload: Prisma.$HealthVisitPayload<ExtArgs>;
      fields: Prisma.HealthVisitFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.HealthVisitFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HealthVisitPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.HealthVisitFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HealthVisitPayload>;
        };
        findFirst: {
          args: Prisma.HealthVisitFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HealthVisitPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.HealthVisitFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HealthVisitPayload>;
        };
        findMany: {
          args: Prisma.HealthVisitFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HealthVisitPayload>[];
        };
        create: {
          args: Prisma.HealthVisitCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HealthVisitPayload>;
        };
        createMany: {
          args: Prisma.HealthVisitCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.HealthVisitCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HealthVisitPayload>[];
        };
        delete: {
          args: Prisma.HealthVisitDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HealthVisitPayload>;
        };
        update: {
          args: Prisma.HealthVisitUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HealthVisitPayload>;
        };
        deleteMany: {
          args: Prisma.HealthVisitDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.HealthVisitUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.HealthVisitUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HealthVisitPayload>[];
        };
        upsert: {
          args: Prisma.HealthVisitUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HealthVisitPayload>;
        };
        aggregate: {
          args: Prisma.HealthVisitAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateHealthVisit>;
        };
        groupBy: {
          args: Prisma.HealthVisitGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.HealthVisitGroupByOutputType>[];
        };
        count: {
          args: Prisma.HealthVisitCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.HealthVisitCountAggregateOutputType>
            | number;
        };
      };
    };
    Classroom: {
      payload: Prisma.$ClassroomPayload<ExtArgs>;
      fields: Prisma.ClassroomFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.ClassroomFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.ClassroomFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomPayload>;
        };
        findFirst: {
          args: Prisma.ClassroomFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.ClassroomFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomPayload>;
        };
        findMany: {
          args: Prisma.ClassroomFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomPayload>[];
        };
        create: {
          args: Prisma.ClassroomCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomPayload>;
        };
        createMany: {
          args: Prisma.ClassroomCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.ClassroomCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomPayload>[];
        };
        delete: {
          args: Prisma.ClassroomDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomPayload>;
        };
        update: {
          args: Prisma.ClassroomUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomPayload>;
        };
        deleteMany: {
          args: Prisma.ClassroomDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.ClassroomUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.ClassroomUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomPayload>[];
        };
        upsert: {
          args: Prisma.ClassroomUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomPayload>;
        };
        aggregate: {
          args: Prisma.ClassroomAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateClassroom>;
        };
        groupBy: {
          args: Prisma.ClassroomGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.ClassroomGroupByOutputType>[];
        };
        count: {
          args: Prisma.ClassroomCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.ClassroomCountAggregateOutputType>
            | number;
        };
      };
    };
    Enrollment: {
      payload: Prisma.$EnrollmentPayload<ExtArgs>;
      fields: Prisma.EnrollmentFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.EnrollmentFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EnrollmentPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.EnrollmentFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EnrollmentPayload>;
        };
        findFirst: {
          args: Prisma.EnrollmentFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EnrollmentPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.EnrollmentFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EnrollmentPayload>;
        };
        findMany: {
          args: Prisma.EnrollmentFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EnrollmentPayload>[];
        };
        create: {
          args: Prisma.EnrollmentCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EnrollmentPayload>;
        };
        createMany: {
          args: Prisma.EnrollmentCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.EnrollmentCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EnrollmentPayload>[];
        };
        delete: {
          args: Prisma.EnrollmentDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EnrollmentPayload>;
        };
        update: {
          args: Prisma.EnrollmentUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EnrollmentPayload>;
        };
        deleteMany: {
          args: Prisma.EnrollmentDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.EnrollmentUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.EnrollmentUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EnrollmentPayload>[];
        };
        upsert: {
          args: Prisma.EnrollmentUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EnrollmentPayload>;
        };
        aggregate: {
          args: Prisma.EnrollmentAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateEnrollment>;
        };
        groupBy: {
          args: Prisma.EnrollmentGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.EnrollmentGroupByOutputType>[];
        };
        count: {
          args: Prisma.EnrollmentCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.EnrollmentCountAggregateOutputType>
            | number;
        };
      };
    };
    Reporting: {
      payload: Prisma.$ReportingPayload<ExtArgs>;
      fields: Prisma.ReportingFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.ReportingFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportingPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.ReportingFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportingPayload>;
        };
        findFirst: {
          args: Prisma.ReportingFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportingPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.ReportingFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportingPayload>;
        };
        findMany: {
          args: Prisma.ReportingFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportingPayload>[];
        };
        create: {
          args: Prisma.ReportingCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportingPayload>;
        };
        createMany: {
          args: Prisma.ReportingCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.ReportingCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportingPayload>[];
        };
        delete: {
          args: Prisma.ReportingDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportingPayload>;
        };
        update: {
          args: Prisma.ReportingUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportingPayload>;
        };
        deleteMany: {
          args: Prisma.ReportingDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.ReportingUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.ReportingUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportingPayload>[];
        };
        upsert: {
          args: Prisma.ReportingUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportingPayload>;
        };
        aggregate: {
          args: Prisma.ReportingAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateReporting>;
        };
        groupBy: {
          args: Prisma.ReportingGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.ReportingGroupByOutputType>[];
        };
        count: {
          args: Prisma.ReportingCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.ReportingCountAggregateOutputType>
            | number;
        };
      };
    };
    ClassroomLevel: {
      payload: Prisma.$ClassroomLevelPayload<ExtArgs>;
      fields: Prisma.ClassroomLevelFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.ClassroomLevelFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomLevelPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.ClassroomLevelFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomLevelPayload>;
        };
        findFirst: {
          args: Prisma.ClassroomLevelFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomLevelPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.ClassroomLevelFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomLevelPayload>;
        };
        findMany: {
          args: Prisma.ClassroomLevelFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomLevelPayload>[];
        };
        create: {
          args: Prisma.ClassroomLevelCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomLevelPayload>;
        };
        createMany: {
          args: Prisma.ClassroomLevelCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.ClassroomLevelCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomLevelPayload>[];
        };
        delete: {
          args: Prisma.ClassroomLevelDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomLevelPayload>;
        };
        update: {
          args: Prisma.ClassroomLevelUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomLevelPayload>;
        };
        deleteMany: {
          args: Prisma.ClassroomLevelDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.ClassroomLevelUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.ClassroomLevelUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomLevelPayload>[];
        };
        upsert: {
          args: Prisma.ClassroomLevelUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomLevelPayload>;
        };
        aggregate: {
          args: Prisma.ClassroomLevelAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateClassroomLevel>;
        };
        groupBy: {
          args: Prisma.ClassroomLevelGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.ClassroomLevelGroupByOutputType>[];
        };
        count: {
          args: Prisma.ClassroomLevelCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.ClassroomLevelCountAggregateOutputType>
            | number;
        };
      };
    };
    CalendarType: {
      payload: Prisma.$CalendarTypePayload<ExtArgs>;
      fields: Prisma.CalendarTypeFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.CalendarTypeFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarTypePayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.CalendarTypeFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarTypePayload>;
        };
        findFirst: {
          args: Prisma.CalendarTypeFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarTypePayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.CalendarTypeFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarTypePayload>;
        };
        findMany: {
          args: Prisma.CalendarTypeFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarTypePayload>[];
        };
        create: {
          args: Prisma.CalendarTypeCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarTypePayload>;
        };
        createMany: {
          args: Prisma.CalendarTypeCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.CalendarTypeCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarTypePayload>[];
        };
        delete: {
          args: Prisma.CalendarTypeDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarTypePayload>;
        };
        update: {
          args: Prisma.CalendarTypeUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarTypePayload>;
        };
        deleteMany: {
          args: Prisma.CalendarTypeDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.CalendarTypeUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.CalendarTypeUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarTypePayload>[];
        };
        upsert: {
          args: Prisma.CalendarTypeUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarTypePayload>;
        };
        aggregate: {
          args: Prisma.CalendarTypeAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateCalendarType>;
        };
        groupBy: {
          args: Prisma.CalendarTypeGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.CalendarTypeGroupByOutputType>[];
        };
        count: {
          args: Prisma.CalendarTypeCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.CalendarTypeCountAggregateOutputType>
            | number;
        };
      };
    };
    CalendarEvent: {
      payload: Prisma.$CalendarEventPayload<ExtArgs>;
      fields: Prisma.CalendarEventFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.CalendarEventFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarEventPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.CalendarEventFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarEventPayload>;
        };
        findFirst: {
          args: Prisma.CalendarEventFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarEventPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.CalendarEventFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarEventPayload>;
        };
        findMany: {
          args: Prisma.CalendarEventFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarEventPayload>[];
        };
        create: {
          args: Prisma.CalendarEventCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarEventPayload>;
        };
        createMany: {
          args: Prisma.CalendarEventCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.CalendarEventCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarEventPayload>[];
        };
        delete: {
          args: Prisma.CalendarEventDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarEventPayload>;
        };
        update: {
          args: Prisma.CalendarEventUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarEventPayload>;
        };
        deleteMany: {
          args: Prisma.CalendarEventDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.CalendarEventUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.CalendarEventUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarEventPayload>[];
        };
        upsert: {
          args: Prisma.CalendarEventUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarEventPayload>;
        };
        aggregate: {
          args: Prisma.CalendarEventAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateCalendarEvent>;
        };
        groupBy: {
          args: Prisma.CalendarEventGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.CalendarEventGroupByOutputType>[];
        };
        count: {
          args: Prisma.CalendarEventCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.CalendarEventCountAggregateOutputType>
            | number;
        };
      };
    };
    GradeSheet: {
      payload: Prisma.$GradeSheetPayload<ExtArgs>;
      fields: Prisma.GradeSheetFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.GradeSheetFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GradeSheetPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.GradeSheetFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GradeSheetPayload>;
        };
        findFirst: {
          args: Prisma.GradeSheetFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GradeSheetPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.GradeSheetFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GradeSheetPayload>;
        };
        findMany: {
          args: Prisma.GradeSheetFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GradeSheetPayload>[];
        };
        create: {
          args: Prisma.GradeSheetCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GradeSheetPayload>;
        };
        createMany: {
          args: Prisma.GradeSheetCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.GradeSheetCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GradeSheetPayload>[];
        };
        delete: {
          args: Prisma.GradeSheetDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GradeSheetPayload>;
        };
        update: {
          args: Prisma.GradeSheetUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GradeSheetPayload>;
        };
        deleteMany: {
          args: Prisma.GradeSheetDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.GradeSheetUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.GradeSheetUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GradeSheetPayload>[];
        };
        upsert: {
          args: Prisma.GradeSheetUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GradeSheetPayload>;
        };
        aggregate: {
          args: Prisma.GradeSheetAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateGradeSheet>;
        };
        groupBy: {
          args: Prisma.GradeSheetGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.GradeSheetGroupByOutputType>[];
        };
        count: {
          args: Prisma.GradeSheetCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.GradeSheetCountAggregateOutputType>
            | number;
        };
      };
    };
    Grade: {
      payload: Prisma.$GradePayload<ExtArgs>;
      fields: Prisma.GradeFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.GradeFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GradePayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.GradeFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GradePayload>;
        };
        findFirst: {
          args: Prisma.GradeFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GradePayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.GradeFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GradePayload>;
        };
        findMany: {
          args: Prisma.GradeFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GradePayload>[];
        };
        create: {
          args: Prisma.GradeCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GradePayload>;
        };
        createMany: {
          args: Prisma.GradeCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.GradeCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GradePayload>[];
        };
        delete: {
          args: Prisma.GradeDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GradePayload>;
        };
        update: {
          args: Prisma.GradeUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GradePayload>;
        };
        deleteMany: {
          args: Prisma.GradeDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.GradeUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.GradeUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GradePayload>[];
        };
        upsert: {
          args: Prisma.GradeUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GradePayload>;
        };
        aggregate: {
          args: Prisma.GradeAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateGrade>;
        };
        groupBy: {
          args: Prisma.GradeGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.GradeGroupByOutputType>[];
        };
        count: {
          args: Prisma.GradeCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.GradeCountAggregateOutputType>
            | number;
        };
      };
    };
    AssignmentCategory: {
      payload: Prisma.$AssignmentCategoryPayload<ExtArgs>;
      fields: Prisma.AssignmentCategoryFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.AssignmentCategoryFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentCategoryPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.AssignmentCategoryFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentCategoryPayload>;
        };
        findFirst: {
          args: Prisma.AssignmentCategoryFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentCategoryPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.AssignmentCategoryFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentCategoryPayload>;
        };
        findMany: {
          args: Prisma.AssignmentCategoryFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentCategoryPayload>[];
        };
        create: {
          args: Prisma.AssignmentCategoryCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentCategoryPayload>;
        };
        createMany: {
          args: Prisma.AssignmentCategoryCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.AssignmentCategoryCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentCategoryPayload>[];
        };
        delete: {
          args: Prisma.AssignmentCategoryDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentCategoryPayload>;
        };
        update: {
          args: Prisma.AssignmentCategoryUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentCategoryPayload>;
        };
        deleteMany: {
          args: Prisma.AssignmentCategoryDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.AssignmentCategoryUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.AssignmentCategoryUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentCategoryPayload>[];
        };
        upsert: {
          args: Prisma.AssignmentCategoryUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentCategoryPayload>;
        };
        aggregate: {
          args: Prisma.AssignmentCategoryAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateAssignmentCategory>;
        };
        groupBy: {
          args: Prisma.AssignmentCategoryGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AssignmentCategoryGroupByOutputType>[];
        };
        count: {
          args: Prisma.AssignmentCategoryCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.AssignmentCategoryCountAggregateOutputType>
            | number;
        };
      };
    };
    AppreciationCategory: {
      payload: Prisma.$AppreciationCategoryPayload<ExtArgs>;
      fields: Prisma.AppreciationCategoryFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.AppreciationCategoryFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationCategoryPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.AppreciationCategoryFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationCategoryPayload>;
        };
        findFirst: {
          args: Prisma.AppreciationCategoryFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationCategoryPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.AppreciationCategoryFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationCategoryPayload>;
        };
        findMany: {
          args: Prisma.AppreciationCategoryFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationCategoryPayload>[];
        };
        create: {
          args: Prisma.AppreciationCategoryCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationCategoryPayload>;
        };
        createMany: {
          args: Prisma.AppreciationCategoryCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.AppreciationCategoryCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationCategoryPayload>[];
        };
        delete: {
          args: Prisma.AppreciationCategoryDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationCategoryPayload>;
        };
        update: {
          args: Prisma.AppreciationCategoryUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationCategoryPayload>;
        };
        deleteMany: {
          args: Prisma.AppreciationCategoryDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.AppreciationCategoryUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.AppreciationCategoryUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationCategoryPayload>[];
        };
        upsert: {
          args: Prisma.AppreciationCategoryUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationCategoryPayload>;
        };
        aggregate: {
          args: Prisma.AppreciationCategoryAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateAppreciationCategory>;
        };
        groupBy: {
          args: Prisma.AppreciationCategoryGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AppreciationCategoryGroupByOutputType>[];
        };
        count: {
          args: Prisma.AppreciationCategoryCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.AppreciationCategoryCountAggregateOutputType>
            | number;
        };
      };
    };
    Assignment: {
      payload: Prisma.$AssignmentPayload<ExtArgs>;
      fields: Prisma.AssignmentFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.AssignmentFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.AssignmentFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentPayload>;
        };
        findFirst: {
          args: Prisma.AssignmentFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.AssignmentFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentPayload>;
        };
        findMany: {
          args: Prisma.AssignmentFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentPayload>[];
        };
        create: {
          args: Prisma.AssignmentCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentPayload>;
        };
        createMany: {
          args: Prisma.AssignmentCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.AssignmentCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentPayload>[];
        };
        delete: {
          args: Prisma.AssignmentDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentPayload>;
        };
        update: {
          args: Prisma.AssignmentUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentPayload>;
        };
        deleteMany: {
          args: Prisma.AssignmentDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.AssignmentUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.AssignmentUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentPayload>[];
        };
        upsert: {
          args: Prisma.AssignmentUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentPayload>;
        };
        aggregate: {
          args: Prisma.AssignmentAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateAssignment>;
        };
        groupBy: {
          args: Prisma.AssignmentGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AssignmentGroupByOutputType>[];
        };
        count: {
          args: Prisma.AssignmentCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.AssignmentCountAggregateOutputType>
            | number;
        };
      };
    };
    Event: {
      payload: Prisma.$EventPayload<ExtArgs>;
      fields: Prisma.EventFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.EventFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.EventFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>;
        };
        findFirst: {
          args: Prisma.EventFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.EventFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>;
        };
        findMany: {
          args: Prisma.EventFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>[];
        };
        create: {
          args: Prisma.EventCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>;
        };
        createMany: {
          args: Prisma.EventCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.EventCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>[];
        };
        delete: {
          args: Prisma.EventDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>;
        };
        update: {
          args: Prisma.EventUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>;
        };
        deleteMany: {
          args: Prisma.EventDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.EventUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.EventUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>[];
        };
        upsert: {
          args: Prisma.EventUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>;
        };
        aggregate: {
          args: Prisma.EventAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateEvent>;
        };
        groupBy: {
          args: Prisma.EventGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.EventGroupByOutputType>[];
        };
        count: {
          args: Prisma.EventCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.EventCountAggregateOutputType>
            | number;
        };
      };
    };
    Term: {
      payload: Prisma.$TermPayload<ExtArgs>;
      fields: Prisma.TermFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.TermFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TermPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.TermFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TermPayload>;
        };
        findFirst: {
          args: Prisma.TermFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TermPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.TermFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TermPayload>;
        };
        findMany: {
          args: Prisma.TermFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TermPayload>[];
        };
        create: {
          args: Prisma.TermCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TermPayload>;
        };
        createMany: {
          args: Prisma.TermCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.TermCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TermPayload>[];
        };
        delete: {
          args: Prisma.TermDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TermPayload>;
        };
        update: {
          args: Prisma.TermUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TermPayload>;
        };
        deleteMany: {
          args: Prisma.TermDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.TermUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.TermUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TermPayload>[];
        };
        upsert: {
          args: Prisma.TermUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TermPayload>;
        };
        aggregate: {
          args: Prisma.TermAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateTerm>;
        };
        groupBy: {
          args: Prisma.TermGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.TermGroupByOutputType>[];
        };
        count: {
          args: Prisma.TermCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.TermCountAggregateOutputType>
            | number;
        };
      };
    };
    ContactRelationship: {
      payload: Prisma.$ContactRelationshipPayload<ExtArgs>;
      fields: Prisma.ContactRelationshipFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.ContactRelationshipFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactRelationshipPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.ContactRelationshipFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactRelationshipPayload>;
        };
        findFirst: {
          args: Prisma.ContactRelationshipFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactRelationshipPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.ContactRelationshipFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactRelationshipPayload>;
        };
        findMany: {
          args: Prisma.ContactRelationshipFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactRelationshipPayload>[];
        };
        create: {
          args: Prisma.ContactRelationshipCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactRelationshipPayload>;
        };
        createMany: {
          args: Prisma.ContactRelationshipCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.ContactRelationshipCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactRelationshipPayload>[];
        };
        delete: {
          args: Prisma.ContactRelationshipDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactRelationshipPayload>;
        };
        update: {
          args: Prisma.ContactRelationshipUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactRelationshipPayload>;
        };
        deleteMany: {
          args: Prisma.ContactRelationshipDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.ContactRelationshipUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.ContactRelationshipUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactRelationshipPayload>[];
        };
        upsert: {
          args: Prisma.ContactRelationshipUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactRelationshipPayload>;
        };
        aggregate: {
          args: Prisma.ContactRelationshipAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateContactRelationship>;
        };
        groupBy: {
          args: Prisma.ContactRelationshipGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.ContactRelationshipGroupByOutputType>[];
        };
        count: {
          args: Prisma.ContactRelationshipCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.ContactRelationshipCountAggregateOutputType>
            | number;
        };
      };
    };
    StaffDegree: {
      payload: Prisma.$StaffDegreePayload<ExtArgs>;
      fields: Prisma.StaffDegreeFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.StaffDegreeFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffDegreePayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.StaffDegreeFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffDegreePayload>;
        };
        findFirst: {
          args: Prisma.StaffDegreeFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffDegreePayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.StaffDegreeFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffDegreePayload>;
        };
        findMany: {
          args: Prisma.StaffDegreeFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffDegreePayload>[];
        };
        create: {
          args: Prisma.StaffDegreeCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffDegreePayload>;
        };
        createMany: {
          args: Prisma.StaffDegreeCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.StaffDegreeCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffDegreePayload>[];
        };
        delete: {
          args: Prisma.StaffDegreeDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffDegreePayload>;
        };
        update: {
          args: Prisma.StaffDegreeUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffDegreePayload>;
        };
        deleteMany: {
          args: Prisma.StaffDegreeDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.StaffDegreeUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.StaffDegreeUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffDegreePayload>[];
        };
        upsert: {
          args: Prisma.StaffDegreeUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffDegreePayload>;
        };
        aggregate: {
          args: Prisma.StaffDegreeAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateStaffDegree>;
        };
        groupBy: {
          args: Prisma.StaffDegreeGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.StaffDegreeGroupByOutputType>[];
        };
        count: {
          args: Prisma.StaffDegreeCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.StaffDegreeCountAggregateOutputType>
            | number;
        };
      };
    };
    Staff: {
      payload: Prisma.$StaffPayload<ExtArgs>;
      fields: Prisma.StaffFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.StaffFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.StaffFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffPayload>;
        };
        findFirst: {
          args: Prisma.StaffFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.StaffFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffPayload>;
        };
        findMany: {
          args: Prisma.StaffFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffPayload>[];
        };
        create: {
          args: Prisma.StaffCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffPayload>;
        };
        createMany: {
          args: Prisma.StaffCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.StaffCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffPayload>[];
        };
        delete: {
          args: Prisma.StaffDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffPayload>;
        };
        update: {
          args: Prisma.StaffUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffPayload>;
        };
        deleteMany: {
          args: Prisma.StaffDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.StaffUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.StaffUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffPayload>[];
        };
        upsert: {
          args: Prisma.StaffUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffPayload>;
        };
        aggregate: {
          args: Prisma.StaffAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateStaff>;
        };
        groupBy: {
          args: Prisma.StaffGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.StaffGroupByOutputType>[];
        };
        count: {
          args: Prisma.StaffCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.StaffCountAggregateOutputType>
            | number;
        };
      };
    };
    Document: {
      payload: Prisma.$DocumentPayload<ExtArgs>;
      fields: Prisma.DocumentFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.DocumentFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload>;
        };
        findFirst: {
          args: Prisma.DocumentFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload>;
        };
        findMany: {
          args: Prisma.DocumentFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload>[];
        };
        create: {
          args: Prisma.DocumentCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload>;
        };
        createMany: {
          args: Prisma.DocumentCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.DocumentCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload>[];
        };
        delete: {
          args: Prisma.DocumentDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload>;
        };
        update: {
          args: Prisma.DocumentUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload>;
        };
        deleteMany: {
          args: Prisma.DocumentDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.DocumentUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.DocumentUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload>[];
        };
        upsert: {
          args: Prisma.DocumentUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload>;
        };
        aggregate: {
          args: Prisma.DocumentAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateDocument>;
        };
        groupBy: {
          args: Prisma.DocumentGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.DocumentGroupByOutputType>[];
        };
        count: {
          args: Prisma.DocumentCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.DocumentCountAggregateOutputType>
            | number;
        };
      };
    };
    Student: {
      payload: Prisma.$StudentPayload<ExtArgs>;
      fields: Prisma.StudentFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.StudentFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.StudentFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentPayload>;
        };
        findFirst: {
          args: Prisma.StudentFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.StudentFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentPayload>;
        };
        findMany: {
          args: Prisma.StudentFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentPayload>[];
        };
        create: {
          args: Prisma.StudentCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentPayload>;
        };
        createMany: {
          args: Prisma.StudentCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.StudentCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentPayload>[];
        };
        delete: {
          args: Prisma.StudentDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentPayload>;
        };
        update: {
          args: Prisma.StudentUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentPayload>;
        };
        deleteMany: {
          args: Prisma.StudentDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.StudentUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.StudentUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentPayload>[];
        };
        upsert: {
          args: Prisma.StudentUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentPayload>;
        };
        aggregate: {
          args: Prisma.StudentAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateStudent>;
        };
        groupBy: {
          args: Prisma.StudentGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.StudentGroupByOutputType>[];
        };
        count: {
          args: Prisma.StudentCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.StudentCountAggregateOutputType>
            | number;
        };
      };
    };
    StudentSibling: {
      payload: Prisma.$StudentSiblingPayload<ExtArgs>;
      fields: Prisma.StudentSiblingFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.StudentSiblingFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentSiblingPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.StudentSiblingFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentSiblingPayload>;
        };
        findFirst: {
          args: Prisma.StudentSiblingFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentSiblingPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.StudentSiblingFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentSiblingPayload>;
        };
        findMany: {
          args: Prisma.StudentSiblingFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentSiblingPayload>[];
        };
        create: {
          args: Prisma.StudentSiblingCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentSiblingPayload>;
        };
        createMany: {
          args: Prisma.StudentSiblingCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.StudentSiblingCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentSiblingPayload>[];
        };
        delete: {
          args: Prisma.StudentSiblingDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentSiblingPayload>;
        };
        update: {
          args: Prisma.StudentSiblingUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentSiblingPayload>;
        };
        deleteMany: {
          args: Prisma.StudentSiblingDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.StudentSiblingUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.StudentSiblingUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentSiblingPayload>[];
        };
        upsert: {
          args: Prisma.StudentSiblingUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentSiblingPayload>;
        };
        aggregate: {
          args: Prisma.StudentSiblingAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateStudentSibling>;
        };
        groupBy: {
          args: Prisma.StudentSiblingGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.StudentSiblingGroupByOutputType>[];
        };
        count: {
          args: Prisma.StudentSiblingCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.StudentSiblingCountAggregateOutputType>
            | number;
        };
      };
    };
    RequiredFeeTransaction: {
      payload: Prisma.$RequiredFeeTransactionPayload<ExtArgs>;
      fields: Prisma.RequiredFeeTransactionFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.RequiredFeeTransactionFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequiredFeeTransactionPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.RequiredFeeTransactionFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequiredFeeTransactionPayload>;
        };
        findFirst: {
          args: Prisma.RequiredFeeTransactionFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequiredFeeTransactionPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.RequiredFeeTransactionFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequiredFeeTransactionPayload>;
        };
        findMany: {
          args: Prisma.RequiredFeeTransactionFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequiredFeeTransactionPayload>[];
        };
        create: {
          args: Prisma.RequiredFeeTransactionCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequiredFeeTransactionPayload>;
        };
        createMany: {
          args: Prisma.RequiredFeeTransactionCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.RequiredFeeTransactionCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequiredFeeTransactionPayload>[];
        };
        delete: {
          args: Prisma.RequiredFeeTransactionDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequiredFeeTransactionPayload>;
        };
        update: {
          args: Prisma.RequiredFeeTransactionUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequiredFeeTransactionPayload>;
        };
        deleteMany: {
          args: Prisma.RequiredFeeTransactionDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.RequiredFeeTransactionUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.RequiredFeeTransactionUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequiredFeeTransactionPayload>[];
        };
        upsert: {
          args: Prisma.RequiredFeeTransactionUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequiredFeeTransactionPayload>;
        };
        aggregate: {
          args: Prisma.RequiredFeeTransactionAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateRequiredFeeTransaction>;
        };
        groupBy: {
          args: Prisma.RequiredFeeTransactionGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.RequiredFeeTransactionGroupByOutputType>[];
        };
        count: {
          args: Prisma.RequiredFeeTransactionCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.RequiredFeeTransactionCountAggregateOutputType>
            | number;
        };
      };
    };
    Fee: {
      payload: Prisma.$FeePayload<ExtArgs>;
      fields: Prisma.FeeFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.FeeFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeePayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.FeeFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeePayload>;
        };
        findFirst: {
          args: Prisma.FeeFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeePayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.FeeFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeePayload>;
        };
        findMany: {
          args: Prisma.FeeFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeePayload>[];
        };
        create: {
          args: Prisma.FeeCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeePayload>;
        };
        createMany: {
          args: Prisma.FeeCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.FeeCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeePayload>[];
        };
        delete: {
          args: Prisma.FeeDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeePayload>;
        };
        update: {
          args: Prisma.FeeUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeePayload>;
        };
        deleteMany: {
          args: Prisma.FeeDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.FeeUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.FeeUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeePayload>[];
        };
        upsert: {
          args: Prisma.FeeUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeePayload>;
        };
        aggregate: {
          args: Prisma.FeeAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateFee>;
        };
        groupBy: {
          args: Prisma.FeeGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.FeeGroupByOutputType>[];
        };
        count: {
          args: Prisma.FeeCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.FeeCountAggregateOutputType>
            | number;
        };
      };
    };
    StudentContact: {
      payload: Prisma.$StudentContactPayload<ExtArgs>;
      fields: Prisma.StudentContactFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.StudentContactFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentContactPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.StudentContactFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentContactPayload>;
        };
        findFirst: {
          args: Prisma.StudentContactFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentContactPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.StudentContactFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentContactPayload>;
        };
        findMany: {
          args: Prisma.StudentContactFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentContactPayload>[];
        };
        create: {
          args: Prisma.StudentContactCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentContactPayload>;
        };
        createMany: {
          args: Prisma.StudentContactCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.StudentContactCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentContactPayload>[];
        };
        delete: {
          args: Prisma.StudentContactDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentContactPayload>;
        };
        update: {
          args: Prisma.StudentContactUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentContactPayload>;
        };
        deleteMany: {
          args: Prisma.StudentContactDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.StudentContactUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.StudentContactUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentContactPayload>[];
        };
        upsert: {
          args: Prisma.StudentContactUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentContactPayload>;
        };
        aggregate: {
          args: Prisma.StudentContactAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateStudentContact>;
        };
        groupBy: {
          args: Prisma.StudentContactGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.StudentContactGroupByOutputType>[];
        };
        count: {
          args: Prisma.StudentContactCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.StudentContactCountAggregateOutputType>
            | number;
        };
      };
    };
    Contact: {
      payload: Prisma.$ContactPayload<ExtArgs>;
      fields: Prisma.ContactFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.ContactFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.ContactFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactPayload>;
        };
        findFirst: {
          args: Prisma.ContactFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.ContactFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactPayload>;
        };
        findMany: {
          args: Prisma.ContactFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactPayload>[];
        };
        create: {
          args: Prisma.ContactCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactPayload>;
        };
        createMany: {
          args: Prisma.ContactCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.ContactCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactPayload>[];
        };
        delete: {
          args: Prisma.ContactDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactPayload>;
        };
        update: {
          args: Prisma.ContactUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactPayload>;
        };
        deleteMany: {
          args: Prisma.ContactDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.ContactUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.ContactUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactPayload>[];
        };
        upsert: {
          args: Prisma.ContactUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactPayload>;
        };
        aggregate: {
          args: Prisma.ContactAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateContact>;
        };
        groupBy: {
          args: Prisma.ContactGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.ContactGroupByOutputType>[];
        };
        count: {
          args: Prisma.ContactCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.ContactCountAggregateOutputType>
            | number;
        };
      };
    };
    Country: {
      payload: Prisma.$CountryPayload<ExtArgs>;
      fields: Prisma.CountryFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.CountryFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CountryPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.CountryFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CountryPayload>;
        };
        findFirst: {
          args: Prisma.CountryFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CountryPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.CountryFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CountryPayload>;
        };
        findMany: {
          args: Prisma.CountryFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CountryPayload>[];
        };
        create: {
          args: Prisma.CountryCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CountryPayload>;
        };
        createMany: {
          args: Prisma.CountryCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.CountryCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CountryPayload>[];
        };
        delete: {
          args: Prisma.CountryDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CountryPayload>;
        };
        update: {
          args: Prisma.CountryUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CountryPayload>;
        };
        deleteMany: {
          args: Prisma.CountryDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.CountryUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.CountryUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CountryPayload>[];
        };
        upsert: {
          args: Prisma.CountryUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CountryPayload>;
        };
        aggregate: {
          args: Prisma.CountryAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateCountry>;
        };
        groupBy: {
          args: Prisma.CountryGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.CountryGroupByOutputType>[];
        };
        count: {
          args: Prisma.CountryCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.CountryCountAggregateOutputType>
            | number;
        };
      };
    };
    School: {
      payload: Prisma.$SchoolPayload<ExtArgs>;
      fields: Prisma.SchoolFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.SchoolFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SchoolPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.SchoolFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SchoolPayload>;
        };
        findFirst: {
          args: Prisma.SchoolFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SchoolPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.SchoolFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SchoolPayload>;
        };
        findMany: {
          args: Prisma.SchoolFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SchoolPayload>[];
        };
        create: {
          args: Prisma.SchoolCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SchoolPayload>;
        };
        createMany: {
          args: Prisma.SchoolCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.SchoolCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SchoolPayload>[];
        };
        delete: {
          args: Prisma.SchoolDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SchoolPayload>;
        };
        update: {
          args: Prisma.SchoolUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SchoolPayload>;
        };
        deleteMany: {
          args: Prisma.SchoolDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.SchoolUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.SchoolUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SchoolPayload>[];
        };
        upsert: {
          args: Prisma.SchoolUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SchoolPayload>;
        };
        aggregate: {
          args: Prisma.SchoolAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateSchool>;
        };
        groupBy: {
          args: Prisma.SchoolGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.SchoolGroupByOutputType>[];
        };
        count: {
          args: Prisma.SchoolCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.SchoolCountAggregateOutputType>
            | number;
        };
      };
    };
    RequiredAccountingJournal: {
      payload: Prisma.$RequiredAccountingJournalPayload<ExtArgs>;
      fields: Prisma.RequiredAccountingJournalFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.RequiredAccountingJournalFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequiredAccountingJournalPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.RequiredAccountingJournalFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequiredAccountingJournalPayload>;
        };
        findFirst: {
          args: Prisma.RequiredAccountingJournalFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequiredAccountingJournalPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.RequiredAccountingJournalFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequiredAccountingJournalPayload>;
        };
        findMany: {
          args: Prisma.RequiredAccountingJournalFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequiredAccountingJournalPayload>[];
        };
        create: {
          args: Prisma.RequiredAccountingJournalCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequiredAccountingJournalPayload>;
        };
        createMany: {
          args: Prisma.RequiredAccountingJournalCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.RequiredAccountingJournalCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequiredAccountingJournalPayload>[];
        };
        delete: {
          args: Prisma.RequiredAccountingJournalDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequiredAccountingJournalPayload>;
        };
        update: {
          args: Prisma.RequiredAccountingJournalUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequiredAccountingJournalPayload>;
        };
        deleteMany: {
          args: Prisma.RequiredAccountingJournalDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.RequiredAccountingJournalUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.RequiredAccountingJournalUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequiredAccountingJournalPayload>[];
        };
        upsert: {
          args: Prisma.RequiredAccountingJournalUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RequiredAccountingJournalPayload>;
        };
        aggregate: {
          args: Prisma.RequiredAccountingJournalAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateRequiredAccountingJournal>;
        };
        groupBy: {
          args: Prisma.RequiredAccountingJournalGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.RequiredAccountingJournalGroupByOutputType>[];
        };
        count: {
          args: Prisma.RequiredAccountingJournalCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.RequiredAccountingJournalCountAggregateOutputType>
            | number;
        };
      };
    };
    FormerSchool: {
      payload: Prisma.$FormerSchoolPayload<ExtArgs>;
      fields: Prisma.FormerSchoolFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.FormerSchoolFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormerSchoolPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.FormerSchoolFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormerSchoolPayload>;
        };
        findFirst: {
          args: Prisma.FormerSchoolFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormerSchoolPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.FormerSchoolFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormerSchoolPayload>;
        };
        findMany: {
          args: Prisma.FormerSchoolFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormerSchoolPayload>[];
        };
        create: {
          args: Prisma.FormerSchoolCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormerSchoolPayload>;
        };
        createMany: {
          args: Prisma.FormerSchoolCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.FormerSchoolCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormerSchoolPayload>[];
        };
        delete: {
          args: Prisma.FormerSchoolDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormerSchoolPayload>;
        };
        update: {
          args: Prisma.FormerSchoolUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormerSchoolPayload>;
        };
        deleteMany: {
          args: Prisma.FormerSchoolDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.FormerSchoolUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.FormerSchoolUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormerSchoolPayload>[];
        };
        upsert: {
          args: Prisma.FormerSchoolUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormerSchoolPayload>;
        };
        aggregate: {
          args: Prisma.FormerSchoolAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateFormerSchool>;
        };
        groupBy: {
          args: Prisma.FormerSchoolGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.FormerSchoolGroupByOutputType>[];
        };
        count: {
          args: Prisma.FormerSchoolCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.FormerSchoolCountAggregateOutputType>
            | number;
        };
      };
    };
    Subject: {
      payload: Prisma.$SubjectPayload<ExtArgs>;
      fields: Prisma.SubjectFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.SubjectFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubjectPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.SubjectFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubjectPayload>;
        };
        findFirst: {
          args: Prisma.SubjectFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubjectPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.SubjectFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubjectPayload>;
        };
        findMany: {
          args: Prisma.SubjectFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubjectPayload>[];
        };
        create: {
          args: Prisma.SubjectCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubjectPayload>;
        };
        createMany: {
          args: Prisma.SubjectCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.SubjectCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubjectPayload>[];
        };
        delete: {
          args: Prisma.SubjectDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubjectPayload>;
        };
        update: {
          args: Prisma.SubjectUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubjectPayload>;
        };
        deleteMany: {
          args: Prisma.SubjectDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.SubjectUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.SubjectUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubjectPayload>[];
        };
        upsert: {
          args: Prisma.SubjectUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubjectPayload>;
        };
        aggregate: {
          args: Prisma.SubjectAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateSubject>;
        };
        groupBy: {
          args: Prisma.SubjectGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.SubjectGroupByOutputType>[];
        };
        count: {
          args: Prisma.SubjectCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.SubjectCountAggregateOutputType>
            | number;
        };
      };
    };
    SubjectGroup: {
      payload: Prisma.$SubjectGroupPayload<ExtArgs>;
      fields: Prisma.SubjectGroupFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.SubjectGroupFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubjectGroupPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.SubjectGroupFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubjectGroupPayload>;
        };
        findFirst: {
          args: Prisma.SubjectGroupFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubjectGroupPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.SubjectGroupFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubjectGroupPayload>;
        };
        findMany: {
          args: Prisma.SubjectGroupFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubjectGroupPayload>[];
        };
        create: {
          args: Prisma.SubjectGroupCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubjectGroupPayload>;
        };
        createMany: {
          args: Prisma.SubjectGroupCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.SubjectGroupCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubjectGroupPayload>[];
        };
        delete: {
          args: Prisma.SubjectGroupDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubjectGroupPayload>;
        };
        update: {
          args: Prisma.SubjectGroupUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubjectGroupPayload>;
        };
        deleteMany: {
          args: Prisma.SubjectGroupDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.SubjectGroupUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.SubjectGroupUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubjectGroupPayload>[];
        };
        upsert: {
          args: Prisma.SubjectGroupUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubjectGroupPayload>;
        };
        aggregate: {
          args: Prisma.SubjectGroupAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateSubjectGroup>;
        };
        groupBy: {
          args: Prisma.SubjectGroupGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.SubjectGroupGroupByOutputType>[];
        };
        count: {
          args: Prisma.SubjectGroupCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.SubjectGroupCountAggregateOutputType>
            | number;
        };
      };
    };
    Course: {
      payload: Prisma.$CoursePayload<ExtArgs>;
      fields: Prisma.CourseFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.CourseFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CoursePayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.CourseFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CoursePayload>;
        };
        findFirst: {
          args: Prisma.CourseFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CoursePayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.CourseFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CoursePayload>;
        };
        findMany: {
          args: Prisma.CourseFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CoursePayload>[];
        };
        create: {
          args: Prisma.CourseCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CoursePayload>;
        };
        createMany: {
          args: Prisma.CourseCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.CourseCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CoursePayload>[];
        };
        delete: {
          args: Prisma.CourseDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CoursePayload>;
        };
        update: {
          args: Prisma.CourseUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CoursePayload>;
        };
        deleteMany: {
          args: Prisma.CourseDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.CourseUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.CourseUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CoursePayload>[];
        };
        upsert: {
          args: Prisma.CourseUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CoursePayload>;
        };
        aggregate: {
          args: Prisma.CourseAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateCourse>;
        };
        groupBy: {
          args: Prisma.CourseGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.CourseGroupByOutputType>[];
        };
        count: {
          args: Prisma.CourseCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.CourseCountAggregateOutputType>
            | number;
        };
      };
    };
    SchoolYear: {
      payload: Prisma.$SchoolYearPayload<ExtArgs>;
      fields: Prisma.SchoolYearFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.SchoolYearFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SchoolYearPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.SchoolYearFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SchoolYearPayload>;
        };
        findFirst: {
          args: Prisma.SchoolYearFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SchoolYearPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.SchoolYearFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SchoolYearPayload>;
        };
        findMany: {
          args: Prisma.SchoolYearFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SchoolYearPayload>[];
        };
        create: {
          args: Prisma.SchoolYearCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SchoolYearPayload>;
        };
        createMany: {
          args: Prisma.SchoolYearCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.SchoolYearCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SchoolYearPayload>[];
        };
        delete: {
          args: Prisma.SchoolYearDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SchoolYearPayload>;
        };
        update: {
          args: Prisma.SchoolYearUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SchoolYearPayload>;
        };
        deleteMany: {
          args: Prisma.SchoolYearDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.SchoolYearUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.SchoolYearUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SchoolYearPayload>[];
        };
        upsert: {
          args: Prisma.SchoolYearUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SchoolYearPayload>;
        };
        aggregate: {
          args: Prisma.SchoolYearAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateSchoolYear>;
        };
        groupBy: {
          args: Prisma.SchoolYearGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.SchoolYearGroupByOutputType>[];
        };
        count: {
          args: Prisma.SchoolYearCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.SchoolYearCountAggregateOutputType>
            | number;
        };
      };
    };
    ClassroomCycle: {
      payload: Prisma.$ClassroomCyclePayload<ExtArgs>;
      fields: Prisma.ClassroomCycleFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.ClassroomCycleFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomCyclePayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.ClassroomCycleFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomCyclePayload>;
        };
        findFirst: {
          args: Prisma.ClassroomCycleFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomCyclePayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.ClassroomCycleFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomCyclePayload>;
        };
        findMany: {
          args: Prisma.ClassroomCycleFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomCyclePayload>[];
        };
        create: {
          args: Prisma.ClassroomCycleCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomCyclePayload>;
        };
        createMany: {
          args: Prisma.ClassroomCycleCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.ClassroomCycleCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomCyclePayload>[];
        };
        delete: {
          args: Prisma.ClassroomCycleDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomCyclePayload>;
        };
        update: {
          args: Prisma.ClassroomCycleUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomCyclePayload>;
        };
        deleteMany: {
          args: Prisma.ClassroomCycleDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.ClassroomCycleUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.ClassroomCycleUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomCyclePayload>[];
        };
        upsert: {
          args: Prisma.ClassroomCycleUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomCyclePayload>;
        };
        aggregate: {
          args: Prisma.ClassroomCycleAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateClassroomCycle>;
        };
        groupBy: {
          args: Prisma.ClassroomCycleGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.ClassroomCycleGroupByOutputType>[];
        };
        count: {
          args: Prisma.ClassroomCycleCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.ClassroomCycleCountAggregateOutputType>
            | number;
        };
      };
    };
    ClassroomSection: {
      payload: Prisma.$ClassroomSectionPayload<ExtArgs>;
      fields: Prisma.ClassroomSectionFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.ClassroomSectionFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomSectionPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.ClassroomSectionFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomSectionPayload>;
        };
        findFirst: {
          args: Prisma.ClassroomSectionFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomSectionPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.ClassroomSectionFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomSectionPayload>;
        };
        findMany: {
          args: Prisma.ClassroomSectionFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomSectionPayload>[];
        };
        create: {
          args: Prisma.ClassroomSectionCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomSectionPayload>;
        };
        createMany: {
          args: Prisma.ClassroomSectionCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.ClassroomSectionCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomSectionPayload>[];
        };
        delete: {
          args: Prisma.ClassroomSectionDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomSectionPayload>;
        };
        update: {
          args: Prisma.ClassroomSectionUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomSectionPayload>;
        };
        deleteMany: {
          args: Prisma.ClassroomSectionDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.ClassroomSectionUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.ClassroomSectionUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomSectionPayload>[];
        };
        upsert: {
          args: Prisma.ClassroomSectionUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomSectionPayload>;
        };
        aggregate: {
          args: Prisma.ClassroomSectionAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateClassroomSection>;
        };
        groupBy: {
          args: Prisma.ClassroomSectionGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.ClassroomSectionGroupByOutputType>[];
        };
        count: {
          args: Prisma.ClassroomSectionCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.ClassroomSectionCountAggregateOutputType>
            | number;
        };
      };
    };
    UserRole: {
      payload: Prisma.$UserRolePayload<ExtArgs>;
      fields: Prisma.UserRoleFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.UserRoleFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.UserRoleFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload>;
        };
        findFirst: {
          args: Prisma.UserRoleFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.UserRoleFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload>;
        };
        findMany: {
          args: Prisma.UserRoleFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload>[];
        };
        create: {
          args: Prisma.UserRoleCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload>;
        };
        createMany: {
          args: Prisma.UserRoleCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.UserRoleCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload>[];
        };
        delete: {
          args: Prisma.UserRoleDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload>;
        };
        update: {
          args: Prisma.UserRoleUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload>;
        };
        deleteMany: {
          args: Prisma.UserRoleDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.UserRoleUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.UserRoleUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload>[];
        };
        upsert: {
          args: Prisma.UserRoleUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload>;
        };
        aggregate: {
          args: Prisma.UserRoleAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateUserRole>;
        };
        groupBy: {
          args: Prisma.UserRoleGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.UserRoleGroupByOutputType>[];
        };
        count: {
          args: Prisma.UserRoleCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.UserRoleCountAggregateOutputType>
            | number;
        };
      };
    };
    Token: {
      payload: Prisma.$TokenPayload<ExtArgs>;
      fields: Prisma.TokenFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.TokenFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TokenPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.TokenFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TokenPayload>;
        };
        findFirst: {
          args: Prisma.TokenFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TokenPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.TokenFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TokenPayload>;
        };
        findMany: {
          args: Prisma.TokenFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TokenPayload>[];
        };
        create: {
          args: Prisma.TokenCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TokenPayload>;
        };
        createMany: {
          args: Prisma.TokenCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.TokenCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TokenPayload>[];
        };
        delete: {
          args: Prisma.TokenDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TokenPayload>;
        };
        update: {
          args: Prisma.TokenUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TokenPayload>;
        };
        deleteMany: {
          args: Prisma.TokenDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.TokenUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.TokenUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TokenPayload>[];
        };
        upsert: {
          args: Prisma.TokenUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TokenPayload>;
        };
        aggregate: {
          args: Prisma.TokenAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateToken>;
        };
        groupBy: {
          args: Prisma.TokenGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.TokenGroupByOutputType>[];
        };
        count: {
          args: Prisma.TokenCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.TokenCountAggregateOutputType>
            | number;
        };
      };
    };
    MenuItem: {
      payload: Prisma.$MenuItemPayload<ExtArgs>;
      fields: Prisma.MenuItemFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.MenuItemFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MenuItemPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.MenuItemFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MenuItemPayload>;
        };
        findFirst: {
          args: Prisma.MenuItemFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MenuItemPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.MenuItemFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MenuItemPayload>;
        };
        findMany: {
          args: Prisma.MenuItemFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MenuItemPayload>[];
        };
        create: {
          args: Prisma.MenuItemCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MenuItemPayload>;
        };
        createMany: {
          args: Prisma.MenuItemCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.MenuItemCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MenuItemPayload>[];
        };
        delete: {
          args: Prisma.MenuItemDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MenuItemPayload>;
        };
        update: {
          args: Prisma.MenuItemUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MenuItemPayload>;
        };
        deleteMany: {
          args: Prisma.MenuItemDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.MenuItemUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.MenuItemUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MenuItemPayload>[];
        };
        upsert: {
          args: Prisma.MenuItemUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MenuItemPayload>;
        };
        aggregate: {
          args: Prisma.MenuItemAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateMenuItem>;
        };
        groupBy: {
          args: Prisma.MenuItemGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.MenuItemGroupByOutputType>[];
        };
        count: {
          args: Prisma.MenuItemCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.MenuItemCountAggregateOutputType>
            | number;
        };
      };
    };
    ProgramCategory: {
      payload: Prisma.$ProgramCategoryPayload<ExtArgs>;
      fields: Prisma.ProgramCategoryFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.ProgramCategoryFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramCategoryPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.ProgramCategoryFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramCategoryPayload>;
        };
        findFirst: {
          args: Prisma.ProgramCategoryFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramCategoryPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.ProgramCategoryFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramCategoryPayload>;
        };
        findMany: {
          args: Prisma.ProgramCategoryFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramCategoryPayload>[];
        };
        create: {
          args: Prisma.ProgramCategoryCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramCategoryPayload>;
        };
        createMany: {
          args: Prisma.ProgramCategoryCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.ProgramCategoryCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramCategoryPayload>[];
        };
        delete: {
          args: Prisma.ProgramCategoryDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramCategoryPayload>;
        };
        update: {
          args: Prisma.ProgramCategoryUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramCategoryPayload>;
        };
        deleteMany: {
          args: Prisma.ProgramCategoryDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.ProgramCategoryUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.ProgramCategoryUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramCategoryPayload>[];
        };
        upsert: {
          args: Prisma.ProgramCategoryUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramCategoryPayload>;
        };
        aggregate: {
          args: Prisma.ProgramCategoryAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateProgramCategory>;
        };
        groupBy: {
          args: Prisma.ProgramCategoryGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.ProgramCategoryGroupByOutputType>[];
        };
        count: {
          args: Prisma.ProgramCategoryCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.ProgramCategoryCountAggregateOutputType>
            | number;
        };
      };
    };
    Program: {
      payload: Prisma.$ProgramPayload<ExtArgs>;
      fields: Prisma.ProgramFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.ProgramFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.ProgramFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramPayload>;
        };
        findFirst: {
          args: Prisma.ProgramFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.ProgramFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramPayload>;
        };
        findMany: {
          args: Prisma.ProgramFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramPayload>[];
        };
        create: {
          args: Prisma.ProgramCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramPayload>;
        };
        createMany: {
          args: Prisma.ProgramCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.ProgramCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramPayload>[];
        };
        delete: {
          args: Prisma.ProgramDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramPayload>;
        };
        update: {
          args: Prisma.ProgramUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramPayload>;
        };
        deleteMany: {
          args: Prisma.ProgramDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.ProgramUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.ProgramUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramPayload>[];
        };
        upsert: {
          args: Prisma.ProgramUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramPayload>;
        };
        aggregate: {
          args: Prisma.ProgramAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateProgram>;
        };
        groupBy: {
          args: Prisma.ProgramGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.ProgramGroupByOutputType>[];
        };
        count: {
          args: Prisma.ProgramCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.ProgramCountAggregateOutputType>
            | number;
        };
      };
    };
    TeachingSessionProgram: {
      payload: Prisma.$TeachingSessionProgramPayload<ExtArgs>;
      fields: Prisma.TeachingSessionProgramFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.TeachingSessionProgramFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeachingSessionProgramPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.TeachingSessionProgramFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeachingSessionProgramPayload>;
        };
        findFirst: {
          args: Prisma.TeachingSessionProgramFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeachingSessionProgramPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.TeachingSessionProgramFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeachingSessionProgramPayload>;
        };
        findMany: {
          args: Prisma.TeachingSessionProgramFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeachingSessionProgramPayload>[];
        };
        create: {
          args: Prisma.TeachingSessionProgramCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeachingSessionProgramPayload>;
        };
        createMany: {
          args: Prisma.TeachingSessionProgramCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.TeachingSessionProgramCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeachingSessionProgramPayload>[];
        };
        delete: {
          args: Prisma.TeachingSessionProgramDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeachingSessionProgramPayload>;
        };
        update: {
          args: Prisma.TeachingSessionProgramUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeachingSessionProgramPayload>;
        };
        deleteMany: {
          args: Prisma.TeachingSessionProgramDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.TeachingSessionProgramUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.TeachingSessionProgramUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeachingSessionProgramPayload>[];
        };
        upsert: {
          args: Prisma.TeachingSessionProgramUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeachingSessionProgramPayload>;
        };
        aggregate: {
          args: Prisma.TeachingSessionProgramAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateTeachingSessionProgram>;
        };
        groupBy: {
          args: Prisma.TeachingSessionProgramGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.TeachingSessionProgramGroupByOutputType>[];
        };
        count: {
          args: Prisma.TeachingSessionProgramCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.TeachingSessionProgramCountAggregateOutputType>
            | number;
        };
      };
    };
    TeachingSession: {
      payload: Prisma.$TeachingSessionPayload<ExtArgs>;
      fields: Prisma.TeachingSessionFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.TeachingSessionFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeachingSessionPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.TeachingSessionFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeachingSessionPayload>;
        };
        findFirst: {
          args: Prisma.TeachingSessionFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeachingSessionPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.TeachingSessionFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeachingSessionPayload>;
        };
        findMany: {
          args: Prisma.TeachingSessionFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeachingSessionPayload>[];
        };
        create: {
          args: Prisma.TeachingSessionCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeachingSessionPayload>;
        };
        createMany: {
          args: Prisma.TeachingSessionCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.TeachingSessionCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeachingSessionPayload>[];
        };
        delete: {
          args: Prisma.TeachingSessionDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeachingSessionPayload>;
        };
        update: {
          args: Prisma.TeachingSessionUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeachingSessionPayload>;
        };
        deleteMany: {
          args: Prisma.TeachingSessionDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.TeachingSessionUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.TeachingSessionUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeachingSessionPayload>[];
        };
        upsert: {
          args: Prisma.TeachingSessionUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeachingSessionPayload>;
        };
        aggregate: {
          args: Prisma.TeachingSessionAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateTeachingSession>;
        };
        groupBy: {
          args: Prisma.TeachingSessionGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.TeachingSessionGroupByOutputType>[];
        };
        count: {
          args: Prisma.TeachingSessionCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.TeachingSessionCountAggregateOutputType>
            | number;
        };
      };
    };
    SMSTemplate: {
      payload: Prisma.$SMSTemplatePayload<ExtArgs>;
      fields: Prisma.SMSTemplateFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.SMSTemplateFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SMSTemplatePayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.SMSTemplateFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SMSTemplatePayload>;
        };
        findFirst: {
          args: Prisma.SMSTemplateFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SMSTemplatePayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.SMSTemplateFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SMSTemplatePayload>;
        };
        findMany: {
          args: Prisma.SMSTemplateFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SMSTemplatePayload>[];
        };
        create: {
          args: Prisma.SMSTemplateCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SMSTemplatePayload>;
        };
        createMany: {
          args: Prisma.SMSTemplateCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.SMSTemplateCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SMSTemplatePayload>[];
        };
        delete: {
          args: Prisma.SMSTemplateDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SMSTemplatePayload>;
        };
        update: {
          args: Prisma.SMSTemplateUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SMSTemplatePayload>;
        };
        deleteMany: {
          args: Prisma.SMSTemplateDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.SMSTemplateUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.SMSTemplateUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SMSTemplatePayload>[];
        };
        upsert: {
          args: Prisma.SMSTemplateUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SMSTemplatePayload>;
        };
        aggregate: {
          args: Prisma.SMSTemplateAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateSMSTemplate>;
        };
        groupBy: {
          args: Prisma.SMSTemplateGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.SMSTemplateGroupByOutputType>[];
        };
        count: {
          args: Prisma.SMSTemplateCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.SMSTemplateCountAggregateOutputType>
            | number;
        };
      };
    };
    SMSHistory: {
      payload: Prisma.$SMSHistoryPayload<ExtArgs>;
      fields: Prisma.SMSHistoryFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.SMSHistoryFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SMSHistoryPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.SMSHistoryFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SMSHistoryPayload>;
        };
        findFirst: {
          args: Prisma.SMSHistoryFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SMSHistoryPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.SMSHistoryFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SMSHistoryPayload>;
        };
        findMany: {
          args: Prisma.SMSHistoryFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SMSHistoryPayload>[];
        };
        create: {
          args: Prisma.SMSHistoryCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SMSHistoryPayload>;
        };
        createMany: {
          args: Prisma.SMSHistoryCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.SMSHistoryCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SMSHistoryPayload>[];
        };
        delete: {
          args: Prisma.SMSHistoryDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SMSHistoryPayload>;
        };
        update: {
          args: Prisma.SMSHistoryUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SMSHistoryPayload>;
        };
        deleteMany: {
          args: Prisma.SMSHistoryDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.SMSHistoryUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.SMSHistoryUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SMSHistoryPayload>[];
        };
        upsert: {
          args: Prisma.SMSHistoryUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SMSHistoryPayload>;
        };
        aggregate: {
          args: Prisma.SMSHistoryAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateSMSHistory>;
        };
        groupBy: {
          args: Prisma.SMSHistoryGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.SMSHistoryGroupByOutputType>[];
        };
        count: {
          args: Prisma.SMSHistoryCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.SMSHistoryCountAggregateOutputType>
            | number;
        };
      };
    };
    SMSHistoryDetail: {
      payload: Prisma.$SMSHistoryDetailPayload<ExtArgs>;
      fields: Prisma.SMSHistoryDetailFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.SMSHistoryDetailFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SMSHistoryDetailPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.SMSHistoryDetailFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SMSHistoryDetailPayload>;
        };
        findFirst: {
          args: Prisma.SMSHistoryDetailFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SMSHistoryDetailPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.SMSHistoryDetailFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SMSHistoryDetailPayload>;
        };
        findMany: {
          args: Prisma.SMSHistoryDetailFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SMSHistoryDetailPayload>[];
        };
        create: {
          args: Prisma.SMSHistoryDetailCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SMSHistoryDetailPayload>;
        };
        createMany: {
          args: Prisma.SMSHistoryDetailCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.SMSHistoryDetailCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SMSHistoryDetailPayload>[];
        };
        delete: {
          args: Prisma.SMSHistoryDetailDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SMSHistoryDetailPayload>;
        };
        update: {
          args: Prisma.SMSHistoryDetailUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SMSHistoryDetailPayload>;
        };
        deleteMany: {
          args: Prisma.SMSHistoryDetailDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.SMSHistoryDetailUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.SMSHistoryDetailUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SMSHistoryDetailPayload>[];
        };
        upsert: {
          args: Prisma.SMSHistoryDetailUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SMSHistoryDetailPayload>;
        };
        aggregate: {
          args: Prisma.SMSHistoryDetailAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateSMSHistoryDetail>;
        };
        groupBy: {
          args: Prisma.SMSHistoryDetailGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.SMSHistoryDetailGroupByOutputType>[];
        };
        count: {
          args: Prisma.SMSHistoryDetailCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.SMSHistoryDetailCountAggregateOutputType>
            | number;
        };
      };
    };
    Photo: {
      payload: Prisma.$PhotoPayload<ExtArgs>;
      fields: Prisma.PhotoFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.PhotoFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotoPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.PhotoFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotoPayload>;
        };
        findFirst: {
          args: Prisma.PhotoFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotoPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.PhotoFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotoPayload>;
        };
        findMany: {
          args: Prisma.PhotoFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotoPayload>[];
        };
        create: {
          args: Prisma.PhotoCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotoPayload>;
        };
        createMany: {
          args: Prisma.PhotoCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.PhotoCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotoPayload>[];
        };
        delete: {
          args: Prisma.PhotoDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotoPayload>;
        };
        update: {
          args: Prisma.PhotoUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotoPayload>;
        };
        deleteMany: {
          args: Prisma.PhotoDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.PhotoUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.PhotoUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotoPayload>[];
        };
        upsert: {
          args: Prisma.PhotoUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotoPayload>;
        };
        aggregate: {
          args: Prisma.PhotoAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregatePhoto>;
        };
        groupBy: {
          args: Prisma.PhotoGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.PhotoGroupByOutputType>[];
        };
        count: {
          args: Prisma.PhotoCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.PhotoCountAggregateOutputType>
            | number;
        };
      };
    };
    ReportQueue: {
      payload: Prisma.$ReportQueuePayload<ExtArgs>;
      fields: Prisma.ReportQueueFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.ReportQueueFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportQueuePayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.ReportQueueFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportQueuePayload>;
        };
        findFirst: {
          args: Prisma.ReportQueueFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportQueuePayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.ReportQueueFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportQueuePayload>;
        };
        findMany: {
          args: Prisma.ReportQueueFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportQueuePayload>[];
        };
        create: {
          args: Prisma.ReportQueueCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportQueuePayload>;
        };
        createMany: {
          args: Prisma.ReportQueueCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.ReportQueueCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportQueuePayload>[];
        };
        delete: {
          args: Prisma.ReportQueueDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportQueuePayload>;
        };
        update: {
          args: Prisma.ReportQueueUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportQueuePayload>;
        };
        deleteMany: {
          args: Prisma.ReportQueueDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.ReportQueueUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.ReportQueueUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportQueuePayload>[];
        };
        upsert: {
          args: Prisma.ReportQueueUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportQueuePayload>;
        };
        aggregate: {
          args: Prisma.ReportQueueAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateReportQueue>;
        };
        groupBy: {
          args: Prisma.ReportQueueGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.ReportQueueGroupByOutputType>[];
        };
        count: {
          args: Prisma.ReportQueueCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.ReportQueueCountAggregateOutputType>
            | number;
        };
      };
    };
    Religion: {
      payload: Prisma.$ReligionPayload<ExtArgs>;
      fields: Prisma.ReligionFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.ReligionFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReligionPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.ReligionFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReligionPayload>;
        };
        findFirst: {
          args: Prisma.ReligionFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReligionPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.ReligionFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReligionPayload>;
        };
        findMany: {
          args: Prisma.ReligionFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReligionPayload>[];
        };
        create: {
          args: Prisma.ReligionCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReligionPayload>;
        };
        createMany: {
          args: Prisma.ReligionCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.ReligionCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReligionPayload>[];
        };
        delete: {
          args: Prisma.ReligionDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReligionPayload>;
        };
        update: {
          args: Prisma.ReligionUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReligionPayload>;
        };
        deleteMany: {
          args: Prisma.ReligionDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.ReligionUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.ReligionUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReligionPayload>[];
        };
        upsert: {
          args: Prisma.ReligionUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReligionPayload>;
        };
        aggregate: {
          args: Prisma.ReligionAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateReligion>;
        };
        groupBy: {
          args: Prisma.ReligionGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.ReligionGroupByOutputType>[];
        };
        count: {
          args: Prisma.ReligionCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.ReligionCountAggregateOutputType>
            | number;
        };
      };
    };
    Club: {
      payload: Prisma.$ClubPayload<ExtArgs>;
      fields: Prisma.ClubFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.ClubFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClubPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.ClubFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClubPayload>;
        };
        findFirst: {
          args: Prisma.ClubFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClubPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.ClubFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClubPayload>;
        };
        findMany: {
          args: Prisma.ClubFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClubPayload>[];
        };
        create: {
          args: Prisma.ClubCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClubPayload>;
        };
        createMany: {
          args: Prisma.ClubCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.ClubCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClubPayload>[];
        };
        delete: {
          args: Prisma.ClubDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClubPayload>;
        };
        update: {
          args: Prisma.ClubUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClubPayload>;
        };
        deleteMany: {
          args: Prisma.ClubDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.ClubUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.ClubUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClubPayload>[];
        };
        upsert: {
          args: Prisma.ClubUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClubPayload>;
        };
        aggregate: {
          args: Prisma.ClubAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateClub>;
        };
        groupBy: {
          args: Prisma.ClubGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.ClubGroupByOutputType>[];
        };
        count: {
          args: Prisma.ClubCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.ClubCountAggregateOutputType>
            | number;
        };
      };
    };
    StudentClub: {
      payload: Prisma.$StudentClubPayload<ExtArgs>;
      fields: Prisma.StudentClubFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.StudentClubFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentClubPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.StudentClubFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentClubPayload>;
        };
        findFirst: {
          args: Prisma.StudentClubFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentClubPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.StudentClubFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentClubPayload>;
        };
        findMany: {
          args: Prisma.StudentClubFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentClubPayload>[];
        };
        create: {
          args: Prisma.StudentClubCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentClubPayload>;
        };
        createMany: {
          args: Prisma.StudentClubCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.StudentClubCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentClubPayload>[];
        };
        delete: {
          args: Prisma.StudentClubDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentClubPayload>;
        };
        update: {
          args: Prisma.StudentClubUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentClubPayload>;
        };
        deleteMany: {
          args: Prisma.StudentClubDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.StudentClubUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.StudentClubUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentClubPayload>[];
        };
        upsert: {
          args: Prisma.StudentClubUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentClubPayload>;
        };
        aggregate: {
          args: Prisma.StudentClubAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateStudentClub>;
        };
        groupBy: {
          args: Prisma.StudentClubGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.StudentClubGroupByOutputType>[];
        };
        count: {
          args: Prisma.StudentClubCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.StudentClubCountAggregateOutputType>
            | number;
        };
      };
    };
    StudentSport: {
      payload: Prisma.$StudentSportPayload<ExtArgs>;
      fields: Prisma.StudentSportFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.StudentSportFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentSportPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.StudentSportFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentSportPayload>;
        };
        findFirst: {
          args: Prisma.StudentSportFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentSportPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.StudentSportFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentSportPayload>;
        };
        findMany: {
          args: Prisma.StudentSportFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentSportPayload>[];
        };
        create: {
          args: Prisma.StudentSportCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentSportPayload>;
        };
        createMany: {
          args: Prisma.StudentSportCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.StudentSportCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentSportPayload>[];
        };
        delete: {
          args: Prisma.StudentSportDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentSportPayload>;
        };
        update: {
          args: Prisma.StudentSportUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentSportPayload>;
        };
        deleteMany: {
          args: Prisma.StudentSportDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.StudentSportUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.StudentSportUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentSportPayload>[];
        };
        upsert: {
          args: Prisma.StudentSportUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StudentSportPayload>;
        };
        aggregate: {
          args: Prisma.StudentSportAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateStudentSport>;
        };
        groupBy: {
          args: Prisma.StudentSportGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.StudentSportGroupByOutputType>[];
        };
        count: {
          args: Prisma.StudentSportCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.StudentSportCountAggregateOutputType>
            | number;
        };
      };
    };
    Invite: {
      payload: Prisma.$InvitePayload<ExtArgs>;
      fields: Prisma.InviteFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.InviteFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvitePayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.InviteFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvitePayload>;
        };
        findFirst: {
          args: Prisma.InviteFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvitePayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.InviteFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvitePayload>;
        };
        findMany: {
          args: Prisma.InviteFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvitePayload>[];
        };
        create: {
          args: Prisma.InviteCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvitePayload>;
        };
        createMany: {
          args: Prisma.InviteCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.InviteCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvitePayload>[];
        };
        delete: {
          args: Prisma.InviteDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvitePayload>;
        };
        update: {
          args: Prisma.InviteUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvitePayload>;
        };
        deleteMany: {
          args: Prisma.InviteDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.InviteUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.InviteUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvitePayload>[];
        };
        upsert: {
          args: Prisma.InviteUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvitePayload>;
        };
        aggregate: {
          args: Prisma.InviteAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateInvite>;
        };
        groupBy: {
          args: Prisma.InviteGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.InviteGroupByOutputType>[];
        };
        count: {
          args: Prisma.InviteCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.InviteCountAggregateOutputType>
            | number;
        };
      };
    };
    Sport: {
      payload: Prisma.$SportPayload<ExtArgs>;
      fields: Prisma.SportFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.SportFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SportPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.SportFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SportPayload>;
        };
        findFirst: {
          args: Prisma.SportFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SportPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.SportFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SportPayload>;
        };
        findMany: {
          args: Prisma.SportFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SportPayload>[];
        };
        create: {
          args: Prisma.SportCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SportPayload>;
        };
        createMany: {
          args: Prisma.SportCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.SportCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SportPayload>[];
        };
        delete: {
          args: Prisma.SportDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SportPayload>;
        };
        update: {
          args: Prisma.SportUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SportPayload>;
        };
        deleteMany: {
          args: Prisma.SportDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.SportUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.SportUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SportPayload>[];
        };
        upsert: {
          args: Prisma.SportUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SportPayload>;
        };
        aggregate: {
          args: Prisma.SportAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateSport>;
        };
        groupBy: {
          args: Prisma.SportGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.SportGroupByOutputType>[];
        };
        count: {
          args: Prisma.SportCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.SportCountAggregateOutputType>
            | number;
        };
      };
    };
    Transaction: {
      payload: Prisma.$TransactionPayload<ExtArgs>;
      fields: Prisma.TransactionFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.TransactionFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>;
        };
        findFirst: {
          args: Prisma.TransactionFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>;
        };
        findMany: {
          args: Prisma.TransactionFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>[];
        };
        create: {
          args: Prisma.TransactionCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>;
        };
        createMany: {
          args: Prisma.TransactionCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>[];
        };
        delete: {
          args: Prisma.TransactionDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>;
        };
        update: {
          args: Prisma.TransactionUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>;
        };
        deleteMany: {
          args: Prisma.TransactionDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.TransactionUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.TransactionUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>[];
        };
        upsert: {
          args: Prisma.TransactionUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>;
        };
        aggregate: {
          args: Prisma.TransactionAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateTransaction>;
        };
        groupBy: {
          args: Prisma.TransactionGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.TransactionGroupByOutputType>[];
        };
        count: {
          args: Prisma.TransactionCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.TransactionCountAggregateOutputType>
            | number;
        };
      };
    };
    AccountingJournal: {
      payload: Prisma.$AccountingJournalPayload<ExtArgs>;
      fields: Prisma.AccountingJournalFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.AccountingJournalFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountingJournalPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.AccountingJournalFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountingJournalPayload>;
        };
        findFirst: {
          args: Prisma.AccountingJournalFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountingJournalPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.AccountingJournalFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountingJournalPayload>;
        };
        findMany: {
          args: Prisma.AccountingJournalFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountingJournalPayload>[];
        };
        create: {
          args: Prisma.AccountingJournalCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountingJournalPayload>;
        };
        createMany: {
          args: Prisma.AccountingJournalCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.AccountingJournalCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountingJournalPayload>[];
        };
        delete: {
          args: Prisma.AccountingJournalDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountingJournalPayload>;
        };
        update: {
          args: Prisma.AccountingJournalUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountingJournalPayload>;
        };
        deleteMany: {
          args: Prisma.AccountingJournalDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.AccountingJournalUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.AccountingJournalUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountingJournalPayload>[];
        };
        upsert: {
          args: Prisma.AccountingJournalUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountingJournalPayload>;
        };
        aggregate: {
          args: Prisma.AccountingJournalAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateAccountingJournal>;
        };
        groupBy: {
          args: Prisma.AccountingJournalGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AccountingJournalGroupByOutputType>[];
        };
        count: {
          args: Prisma.AccountingJournalCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.AccountingJournalCountAggregateOutputType>
            | number;
        };
      };
    };
    ScheduleTask: {
      payload: Prisma.$ScheduleTaskPayload<ExtArgs>;
      fields: Prisma.ScheduleTaskFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.ScheduleTaskFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduleTaskPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.ScheduleTaskFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduleTaskPayload>;
        };
        findFirst: {
          args: Prisma.ScheduleTaskFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduleTaskPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.ScheduleTaskFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduleTaskPayload>;
        };
        findMany: {
          args: Prisma.ScheduleTaskFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduleTaskPayload>[];
        };
        create: {
          args: Prisma.ScheduleTaskCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduleTaskPayload>;
        };
        createMany: {
          args: Prisma.ScheduleTaskCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.ScheduleTaskCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduleTaskPayload>[];
        };
        delete: {
          args: Prisma.ScheduleTaskDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduleTaskPayload>;
        };
        update: {
          args: Prisma.ScheduleTaskUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduleTaskPayload>;
        };
        deleteMany: {
          args: Prisma.ScheduleTaskDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.ScheduleTaskUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.ScheduleTaskUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduleTaskPayload>[];
        };
        upsert: {
          args: Prisma.ScheduleTaskUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduleTaskPayload>;
        };
        aggregate: {
          args: Prisma.ScheduleTaskAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateScheduleTask>;
        };
        groupBy: {
          args: Prisma.ScheduleTaskGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.ScheduleTaskGroupByOutputType>[];
        };
        count: {
          args: Prisma.ScheduleTaskCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.ScheduleTaskCountAggregateOutputType>
            | number;
        };
      };
    };
    GradeAppreciation: {
      payload: Prisma.$GradeAppreciationPayload<ExtArgs>;
      fields: Prisma.GradeAppreciationFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.GradeAppreciationFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GradeAppreciationPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.GradeAppreciationFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GradeAppreciationPayload>;
        };
        findFirst: {
          args: Prisma.GradeAppreciationFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GradeAppreciationPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.GradeAppreciationFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GradeAppreciationPayload>;
        };
        findMany: {
          args: Prisma.GradeAppreciationFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GradeAppreciationPayload>[];
        };
        create: {
          args: Prisma.GradeAppreciationCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GradeAppreciationPayload>;
        };
        createMany: {
          args: Prisma.GradeAppreciationCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.GradeAppreciationCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GradeAppreciationPayload>[];
        };
        delete: {
          args: Prisma.GradeAppreciationDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GradeAppreciationPayload>;
        };
        update: {
          args: Prisma.GradeAppreciationUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GradeAppreciationPayload>;
        };
        deleteMany: {
          args: Prisma.GradeAppreciationDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.GradeAppreciationUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.GradeAppreciationUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GradeAppreciationPayload>[];
        };
        upsert: {
          args: Prisma.GradeAppreciationUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GradeAppreciationPayload>;
        };
        aggregate: {
          args: Prisma.GradeAppreciationAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateGradeAppreciation>;
        };
        groupBy: {
          args: Prisma.GradeAppreciationGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.GradeAppreciationGroupByOutputType>[];
        };
        count: {
          args: Prisma.GradeAppreciationCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.GradeAppreciationCountAggregateOutputType>
            | number;
        };
      };
    };
    ClassroomGradeAppreciation: {
      payload: Prisma.$ClassroomGradeAppreciationPayload<ExtArgs>;
      fields: Prisma.ClassroomGradeAppreciationFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.ClassroomGradeAppreciationFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomGradeAppreciationPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.ClassroomGradeAppreciationFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomGradeAppreciationPayload>;
        };
        findFirst: {
          args: Prisma.ClassroomGradeAppreciationFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomGradeAppreciationPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.ClassroomGradeAppreciationFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomGradeAppreciationPayload>;
        };
        findMany: {
          args: Prisma.ClassroomGradeAppreciationFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomGradeAppreciationPayload>[];
        };
        create: {
          args: Prisma.ClassroomGradeAppreciationCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomGradeAppreciationPayload>;
        };
        createMany: {
          args: Prisma.ClassroomGradeAppreciationCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.ClassroomGradeAppreciationCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomGradeAppreciationPayload>[];
        };
        delete: {
          args: Prisma.ClassroomGradeAppreciationDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomGradeAppreciationPayload>;
        };
        update: {
          args: Prisma.ClassroomGradeAppreciationUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomGradeAppreciationPayload>;
        };
        deleteMany: {
          args: Prisma.ClassroomGradeAppreciationDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.ClassroomGradeAppreciationUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.ClassroomGradeAppreciationUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomGradeAppreciationPayload>[];
        };
        upsert: {
          args: Prisma.ClassroomGradeAppreciationUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClassroomGradeAppreciationPayload>;
        };
        aggregate: {
          args: Prisma.ClassroomGradeAppreciationAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateClassroomGradeAppreciation>;
        };
        groupBy: {
          args: Prisma.ClassroomGradeAppreciationGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.ClassroomGradeAppreciationGroupByOutputType>[];
        };
        count: {
          args: Prisma.ClassroomGradeAppreciationCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.ClassroomGradeAppreciationCountAggregateOutputType>
            | number;
        };
      };
    };
    HealthRecord: {
      payload: Prisma.$HealthRecordPayload<ExtArgs>;
      fields: Prisma.HealthRecordFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.HealthRecordFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HealthRecordPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.HealthRecordFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HealthRecordPayload>;
        };
        findFirst: {
          args: Prisma.HealthRecordFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HealthRecordPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.HealthRecordFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HealthRecordPayload>;
        };
        findMany: {
          args: Prisma.HealthRecordFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HealthRecordPayload>[];
        };
        create: {
          args: Prisma.HealthRecordCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HealthRecordPayload>;
        };
        createMany: {
          args: Prisma.HealthRecordCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.HealthRecordCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HealthRecordPayload>[];
        };
        delete: {
          args: Prisma.HealthRecordDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HealthRecordPayload>;
        };
        update: {
          args: Prisma.HealthRecordUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HealthRecordPayload>;
        };
        deleteMany: {
          args: Prisma.HealthRecordDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.HealthRecordUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.HealthRecordUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HealthRecordPayload>[];
        };
        upsert: {
          args: Prisma.HealthRecordUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HealthRecordPayload>;
        };
        aggregate: {
          args: Prisma.HealthRecordAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateHealthRecord>;
        };
        groupBy: {
          args: Prisma.HealthRecordGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.HealthRecordGroupByOutputType>[];
        };
        count: {
          args: Prisma.HealthRecordCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.HealthRecordCountAggregateOutputType>
            | number;
        };
      };
    };
    HealthDrug: {
      payload: Prisma.$HealthDrugPayload<ExtArgs>;
      fields: Prisma.HealthDrugFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.HealthDrugFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HealthDrugPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.HealthDrugFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HealthDrugPayload>;
        };
        findFirst: {
          args: Prisma.HealthDrugFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HealthDrugPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.HealthDrugFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HealthDrugPayload>;
        };
        findMany: {
          args: Prisma.HealthDrugFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HealthDrugPayload>[];
        };
        create: {
          args: Prisma.HealthDrugCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HealthDrugPayload>;
        };
        createMany: {
          args: Prisma.HealthDrugCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.HealthDrugCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HealthDrugPayload>[];
        };
        delete: {
          args: Prisma.HealthDrugDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HealthDrugPayload>;
        };
        update: {
          args: Prisma.HealthDrugUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HealthDrugPayload>;
        };
        deleteMany: {
          args: Prisma.HealthDrugDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.HealthDrugUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.HealthDrugUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HealthDrugPayload>[];
        };
        upsert: {
          args: Prisma.HealthDrugUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HealthDrugPayload>;
        };
        aggregate: {
          args: Prisma.HealthDrugAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateHealthDrug>;
        };
        groupBy: {
          args: Prisma.HealthDrugGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.HealthDrugGroupByOutputType>[];
        };
        count: {
          args: Prisma.HealthDrugCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.HealthDrugCountAggregateOutputType>
            | number;
        };
      };
    };
    User: {
      payload: Prisma.$UserPayload<ExtArgs>;
      fields: Prisma.UserFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.UserFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>;
        };
        findFirst: {
          args: Prisma.UserFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>;
        };
        findMany: {
          args: Prisma.UserFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[];
        };
        create: {
          args: Prisma.UserCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>;
        };
        createMany: {
          args: Prisma.UserCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[];
        };
        delete: {
          args: Prisma.UserDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>;
        };
        update: {
          args: Prisma.UserUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>;
        };
        deleteMany: {
          args: Prisma.UserDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.UserUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[];
        };
        upsert: {
          args: Prisma.UserUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>;
        };
        aggregate: {
          args: Prisma.UserAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateUser>;
        };
        groupBy: {
          args: Prisma.UserGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.UserGroupByOutputType>[];
        };
        count: {
          args: Prisma.UserCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.UserCountAggregateOutputType>
            | number;
        };
      };
    };
    Role: {
      payload: Prisma.$RolePayload<ExtArgs>;
      fields: Prisma.RoleFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.RoleFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>;
        };
        findFirst: {
          args: Prisma.RoleFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>;
        };
        findMany: {
          args: Prisma.RoleFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>[];
        };
        create: {
          args: Prisma.RoleCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>;
        };
        createMany: {
          args: Prisma.RoleCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>[];
        };
        delete: {
          args: Prisma.RoleDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>;
        };
        update: {
          args: Prisma.RoleUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>;
        };
        deleteMany: {
          args: Prisma.RoleDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.RoleUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>[];
        };
        upsert: {
          args: Prisma.RoleUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>;
        };
        aggregate: {
          args: Prisma.RoleAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateRole>;
        };
        groupBy: {
          args: Prisma.RoleGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.RoleGroupByOutputType>[];
        };
        count: {
          args: Prisma.RoleCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.RoleCountAggregateOutputType>
            | number;
        };
      };
    };
    RolePolicy: {
      payload: Prisma.$RolePolicyPayload<ExtArgs>;
      fields: Prisma.RolePolicyFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.RolePolicyFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePolicyPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.RolePolicyFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePolicyPayload>;
        };
        findFirst: {
          args: Prisma.RolePolicyFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePolicyPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.RolePolicyFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePolicyPayload>;
        };
        findMany: {
          args: Prisma.RolePolicyFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePolicyPayload>[];
        };
        create: {
          args: Prisma.RolePolicyCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePolicyPayload>;
        };
        createMany: {
          args: Prisma.RolePolicyCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.RolePolicyCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePolicyPayload>[];
        };
        delete: {
          args: Prisma.RolePolicyDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePolicyPayload>;
        };
        update: {
          args: Prisma.RolePolicyUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePolicyPayload>;
        };
        deleteMany: {
          args: Prisma.RolePolicyDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.RolePolicyUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.RolePolicyUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePolicyPayload>[];
        };
        upsert: {
          args: Prisma.RolePolicyUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePolicyPayload>;
        };
        aggregate: {
          args: Prisma.RolePolicyAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateRolePolicy>;
        };
        groupBy: {
          args: Prisma.RolePolicyGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.RolePolicyGroupByOutputType>[];
        };
        count: {
          args: Prisma.RolePolicyCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.RolePolicyCountAggregateOutputType>
            | number;
        };
      };
    };
    UserPolicy: {
      payload: Prisma.$UserPolicyPayload<ExtArgs>;
      fields: Prisma.UserPolicyFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.UserPolicyFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPolicyPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.UserPolicyFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPolicyPayload>;
        };
        findFirst: {
          args: Prisma.UserPolicyFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPolicyPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.UserPolicyFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPolicyPayload>;
        };
        findMany: {
          args: Prisma.UserPolicyFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPolicyPayload>[];
        };
        create: {
          args: Prisma.UserPolicyCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPolicyPayload>;
        };
        createMany: {
          args: Prisma.UserPolicyCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.UserPolicyCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPolicyPayload>[];
        };
        delete: {
          args: Prisma.UserPolicyDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPolicyPayload>;
        };
        update: {
          args: Prisma.UserPolicyUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPolicyPayload>;
        };
        deleteMany: {
          args: Prisma.UserPolicyDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.UserPolicyUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.UserPolicyUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPolicyPayload>[];
        };
        upsert: {
          args: Prisma.UserPolicyUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPolicyPayload>;
        };
        aggregate: {
          args: Prisma.UserPolicyAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateUserPolicy>;
        };
        groupBy: {
          args: Prisma.UserPolicyGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.UserPolicyGroupByOutputType>[];
        };
        count: {
          args: Prisma.UserPolicyCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.UserPolicyCountAggregateOutputType>
            | number;
        };
      };
    };
    NotificationPreference: {
      payload: Prisma.$NotificationPreferencePayload<ExtArgs>;
      fields: Prisma.NotificationPreferenceFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.NotificationPreferenceFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>;
        };
        findFirst: {
          args: Prisma.NotificationPreferenceFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.NotificationPreferenceFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>;
        };
        findMany: {
          args: Prisma.NotificationPreferenceFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[];
        };
        create: {
          args: Prisma.NotificationPreferenceCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>;
        };
        createMany: {
          args: Prisma.NotificationPreferenceCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.NotificationPreferenceCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[];
        };
        delete: {
          args: Prisma.NotificationPreferenceDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>;
        };
        update: {
          args: Prisma.NotificationPreferenceUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>;
        };
        deleteMany: {
          args: Prisma.NotificationPreferenceDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.NotificationPreferenceUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.NotificationPreferenceUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[];
        };
        upsert: {
          args: Prisma.NotificationPreferenceUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>;
        };
        aggregate: {
          args: Prisma.NotificationPreferenceAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateNotificationPreference>;
        };
        groupBy: {
          args: Prisma.NotificationPreferenceGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.NotificationPreferenceGroupByOutputType>[];
        };
        count: {
          args: Prisma.NotificationPreferenceCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.NotificationPreferenceCountAggregateOutputType>
            | number;
        };
      };
    };
    Subscription: {
      payload: Prisma.$SubscriptionPayload<ExtArgs>;
      fields: Prisma.SubscriptionFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPayload>;
        };
        findFirst: {
          args: Prisma.SubscriptionFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPayload>;
        };
        findMany: {
          args: Prisma.SubscriptionFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPayload>[];
        };
        create: {
          args: Prisma.SubscriptionCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPayload>;
        };
        createMany: {
          args: Prisma.SubscriptionCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.SubscriptionCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPayload>[];
        };
        delete: {
          args: Prisma.SubscriptionDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPayload>;
        };
        update: {
          args: Prisma.SubscriptionUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPayload>;
        };
        deleteMany: {
          args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.SubscriptionUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPayload>[];
        };
        upsert: {
          args: Prisma.SubscriptionUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPayload>;
        };
        aggregate: {
          args: Prisma.SubscriptionAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateSubscription>;
        };
        groupBy: {
          args: Prisma.SubscriptionGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.SubscriptionGroupByOutputType>[];
        };
        count: {
          args: Prisma.SubscriptionCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.SubscriptionCountAggregateOutputType>
            | number;
        };
      };
    };
    LogActivity: {
      payload: Prisma.$LogActivityPayload<ExtArgs>;
      fields: Prisma.LogActivityFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.LogActivityFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LogActivityPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.LogActivityFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LogActivityPayload>;
        };
        findFirst: {
          args: Prisma.LogActivityFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LogActivityPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.LogActivityFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LogActivityPayload>;
        };
        findMany: {
          args: Prisma.LogActivityFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LogActivityPayload>[];
        };
        create: {
          args: Prisma.LogActivityCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LogActivityPayload>;
        };
        createMany: {
          args: Prisma.LogActivityCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.LogActivityCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LogActivityPayload>[];
        };
        delete: {
          args: Prisma.LogActivityDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LogActivityPayload>;
        };
        update: {
          args: Prisma.LogActivityUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LogActivityPayload>;
        };
        deleteMany: {
          args: Prisma.LogActivityDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.LogActivityUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.LogActivityUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LogActivityPayload>[];
        };
        upsert: {
          args: Prisma.LogActivityUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LogActivityPayload>;
        };
        aggregate: {
          args: Prisma.LogActivityAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateLogActivity>;
        };
        groupBy: {
          args: Prisma.LogActivityGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.LogActivityGroupByOutputType>[];
        };
        count: {
          args: Prisma.LogActivityCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.LogActivityCountAggregateOutputType>
            | number;
        };
      };
    };
    SchoolYearEvent: {
      payload: Prisma.$SchoolYearEventPayload<ExtArgs>;
      fields: Prisma.SchoolYearEventFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.SchoolYearEventFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SchoolYearEventPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.SchoolYearEventFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SchoolYearEventPayload>;
        };
        findFirst: {
          args: Prisma.SchoolYearEventFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SchoolYearEventPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.SchoolYearEventFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SchoolYearEventPayload>;
        };
        findMany: {
          args: Prisma.SchoolYearEventFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SchoolYearEventPayload>[];
        };
        create: {
          args: Prisma.SchoolYearEventCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SchoolYearEventPayload>;
        };
        createMany: {
          args: Prisma.SchoolYearEventCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.SchoolYearEventCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SchoolYearEventPayload>[];
        };
        delete: {
          args: Prisma.SchoolYearEventDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SchoolYearEventPayload>;
        };
        update: {
          args: Prisma.SchoolYearEventUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SchoolYearEventPayload>;
        };
        deleteMany: {
          args: Prisma.SchoolYearEventDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.SchoolYearEventUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.SchoolYearEventUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SchoolYearEventPayload>[];
        };
        upsert: {
          args: Prisma.SchoolYearEventUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SchoolYearEventPayload>;
        };
        aggregate: {
          args: Prisma.SchoolYearEventAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateSchoolYearEvent>;
        };
        groupBy: {
          args: Prisma.SchoolYearEventGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.SchoolYearEventGroupByOutputType>[];
        };
        count: {
          args: Prisma.SchoolYearEventCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.SchoolYearEventCountAggregateOutputType>
            | number;
        };
      };
    };
    SchoolYearEventType: {
      payload: Prisma.$SchoolYearEventTypePayload<ExtArgs>;
      fields: Prisma.SchoolYearEventTypeFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.SchoolYearEventTypeFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SchoolYearEventTypePayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.SchoolYearEventTypeFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SchoolYearEventTypePayload>;
        };
        findFirst: {
          args: Prisma.SchoolYearEventTypeFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SchoolYearEventTypePayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.SchoolYearEventTypeFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SchoolYearEventTypePayload>;
        };
        findMany: {
          args: Prisma.SchoolYearEventTypeFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SchoolYearEventTypePayload>[];
        };
        create: {
          args: Prisma.SchoolYearEventTypeCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SchoolYearEventTypePayload>;
        };
        createMany: {
          args: Prisma.SchoolYearEventTypeCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.SchoolYearEventTypeCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SchoolYearEventTypePayload>[];
        };
        delete: {
          args: Prisma.SchoolYearEventTypeDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SchoolYearEventTypePayload>;
        };
        update: {
          args: Prisma.SchoolYearEventTypeUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SchoolYearEventTypePayload>;
        };
        deleteMany: {
          args: Prisma.SchoolYearEventTypeDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.SchoolYearEventTypeUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.SchoolYearEventTypeUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SchoolYearEventTypePayload>[];
        };
        upsert: {
          args: Prisma.SchoolYearEventTypeUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SchoolYearEventTypePayload>;
        };
        aggregate: {
          args: Prisma.SchoolYearEventTypeAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateSchoolYearEventType>;
        };
        groupBy: {
          args: Prisma.SchoolYearEventTypeGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.SchoolYearEventTypeGroupByOutputType>[];
        };
        count: {
          args: Prisma.SchoolYearEventTypeCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.SchoolYearEventTypeCountAggregateOutputType>
            | number;
        };
      };
    };
    Session: {
      payload: Prisma.$SessionPayload<ExtArgs>;
      fields: Prisma.SessionFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.SessionFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>;
        };
        findFirst: {
          args: Prisma.SessionFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>;
        };
        findMany: {
          args: Prisma.SessionFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>[];
        };
        create: {
          args: Prisma.SessionCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>;
        };
        createMany: {
          args: Prisma.SessionCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>[];
        };
        delete: {
          args: Prisma.SessionDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>;
        };
        update: {
          args: Prisma.SessionUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>;
        };
        deleteMany: {
          args: Prisma.SessionDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.SessionUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>[];
        };
        upsert: {
          args: Prisma.SessionUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>;
        };
        aggregate: {
          args: Prisma.SessionAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateSession>;
        };
        groupBy: {
          args: Prisma.SessionGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.SessionGroupByOutputType>[];
        };
        count: {
          args: Prisma.SessionCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.SessionCountAggregateOutputType>
            | number;
        };
      };
    };
    Account: {
      payload: Prisma.$AccountPayload<ExtArgs>;
      fields: Prisma.AccountFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.AccountFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>;
        };
        findFirst: {
          args: Prisma.AccountFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>;
        };
        findMany: {
          args: Prisma.AccountFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>[];
        };
        create: {
          args: Prisma.AccountCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>;
        };
        createMany: {
          args: Prisma.AccountCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>[];
        };
        delete: {
          args: Prisma.AccountDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>;
        };
        update: {
          args: Prisma.AccountUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>;
        };
        deleteMany: {
          args: Prisma.AccountDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.AccountUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>[];
        };
        upsert: {
          args: Prisma.AccountUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>;
        };
        aggregate: {
          args: Prisma.AccountAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateAccount>;
        };
        groupBy: {
          args: Prisma.AccountGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AccountGroupByOutputType>[];
        };
        count: {
          args: Prisma.AccountCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.AccountCountAggregateOutputType>
            | number;
        };
      };
    };
    Verification: {
      payload: Prisma.$VerificationPayload<ExtArgs>;
      fields: Prisma.VerificationFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.VerificationFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.VerificationFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationPayload>;
        };
        findFirst: {
          args: Prisma.VerificationFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.VerificationFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationPayload>;
        };
        findMany: {
          args: Prisma.VerificationFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationPayload>[];
        };
        create: {
          args: Prisma.VerificationCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationPayload>;
        };
        createMany: {
          args: Prisma.VerificationCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.VerificationCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationPayload>[];
        };
        delete: {
          args: Prisma.VerificationDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationPayload>;
        };
        update: {
          args: Prisma.VerificationUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationPayload>;
        };
        deleteMany: {
          args: Prisma.VerificationDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.VerificationUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.VerificationUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationPayload>[];
        };
        upsert: {
          args: Prisma.VerificationUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationPayload>;
        };
        aggregate: {
          args: Prisma.VerificationAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateVerification>;
        };
        groupBy: {
          args: Prisma.VerificationGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.VerificationGroupByOutputType>[];
        };
        count: {
          args: Prisma.VerificationCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.VerificationCountAggregateOutputType>
            | number;
        };
      };
    };
    Apikey: {
      payload: Prisma.$ApikeyPayload<ExtArgs>;
      fields: Prisma.ApikeyFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.ApikeyFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApikeyPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.ApikeyFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApikeyPayload>;
        };
        findFirst: {
          args: Prisma.ApikeyFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApikeyPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.ApikeyFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApikeyPayload>;
        };
        findMany: {
          args: Prisma.ApikeyFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApikeyPayload>[];
        };
        create: {
          args: Prisma.ApikeyCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApikeyPayload>;
        };
        createMany: {
          args: Prisma.ApikeyCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.ApikeyCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApikeyPayload>[];
        };
        delete: {
          args: Prisma.ApikeyDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApikeyPayload>;
        };
        update: {
          args: Prisma.ApikeyUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApikeyPayload>;
        };
        deleteMany: {
          args: Prisma.ApikeyDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.ApikeyUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.ApikeyUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApikeyPayload>[];
        };
        upsert: {
          args: Prisma.ApikeyUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApikeyPayload>;
        };
        aggregate: {
          args: Prisma.ApikeyAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateApikey>;
        };
        groupBy: {
          args: Prisma.ApikeyGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.ApikeyGroupByOutputType>[];
        };
        count: {
          args: Prisma.ApikeyCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.ApikeyCountAggregateOutputType>
            | number;
        };
      };
    };
    UserNotification: {
      payload: Prisma.$UserNotificationPayload<ExtArgs>;
      fields: Prisma.UserNotificationFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.UserNotificationFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserNotificationPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.UserNotificationFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserNotificationPayload>;
        };
        findFirst: {
          args: Prisma.UserNotificationFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserNotificationPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.UserNotificationFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserNotificationPayload>;
        };
        findMany: {
          args: Prisma.UserNotificationFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserNotificationPayload>[];
        };
        create: {
          args: Prisma.UserNotificationCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserNotificationPayload>;
        };
        createMany: {
          args: Prisma.UserNotificationCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.UserNotificationCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserNotificationPayload>[];
        };
        delete: {
          args: Prisma.UserNotificationDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserNotificationPayload>;
        };
        update: {
          args: Prisma.UserNotificationUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserNotificationPayload>;
        };
        deleteMany: {
          args: Prisma.UserNotificationDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.UserNotificationUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.UserNotificationUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserNotificationPayload>[];
        };
        upsert: {
          args: Prisma.UserNotificationUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserNotificationPayload>;
        };
        aggregate: {
          args: Prisma.UserNotificationAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateUserNotification>;
        };
        groupBy: {
          args: Prisma.UserNotificationGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.UserNotificationGroupByOutputType>[];
        };
        count: {
          args: Prisma.UserNotificationCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.UserNotificationCountAggregateOutputType>
            | number;
        };
      };
    };
    AppreciationRuleSet: {
      payload: Prisma.$AppreciationRuleSetPayload<ExtArgs>;
      fields: Prisma.AppreciationRuleSetFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.AppreciationRuleSetFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationRuleSetPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.AppreciationRuleSetFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationRuleSetPayload>;
        };
        findFirst: {
          args: Prisma.AppreciationRuleSetFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationRuleSetPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.AppreciationRuleSetFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationRuleSetPayload>;
        };
        findMany: {
          args: Prisma.AppreciationRuleSetFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationRuleSetPayload>[];
        };
        create: {
          args: Prisma.AppreciationRuleSetCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationRuleSetPayload>;
        };
        createMany: {
          args: Prisma.AppreciationRuleSetCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.AppreciationRuleSetCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationRuleSetPayload>[];
        };
        delete: {
          args: Prisma.AppreciationRuleSetDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationRuleSetPayload>;
        };
        update: {
          args: Prisma.AppreciationRuleSetUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationRuleSetPayload>;
        };
        deleteMany: {
          args: Prisma.AppreciationRuleSetDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.AppreciationRuleSetUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.AppreciationRuleSetUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationRuleSetPayload>[];
        };
        upsert: {
          args: Prisma.AppreciationRuleSetUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationRuleSetPayload>;
        };
        aggregate: {
          args: Prisma.AppreciationRuleSetAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateAppreciationRuleSet>;
        };
        groupBy: {
          args: Prisma.AppreciationRuleSetGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AppreciationRuleSetGroupByOutputType>[];
        };
        count: {
          args: Prisma.AppreciationRuleSetCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.AppreciationRuleSetCountAggregateOutputType>
            | number;
        };
      };
    };
    AppreciationRule: {
      payload: Prisma.$AppreciationRulePayload<ExtArgs>;
      fields: Prisma.AppreciationRuleFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.AppreciationRuleFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationRulePayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.AppreciationRuleFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationRulePayload>;
        };
        findFirst: {
          args: Prisma.AppreciationRuleFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationRulePayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.AppreciationRuleFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationRulePayload>;
        };
        findMany: {
          args: Prisma.AppreciationRuleFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationRulePayload>[];
        };
        create: {
          args: Prisma.AppreciationRuleCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationRulePayload>;
        };
        createMany: {
          args: Prisma.AppreciationRuleCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.AppreciationRuleCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationRulePayload>[];
        };
        delete: {
          args: Prisma.AppreciationRuleDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationRulePayload>;
        };
        update: {
          args: Prisma.AppreciationRuleUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationRulePayload>;
        };
        deleteMany: {
          args: Prisma.AppreciationRuleDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.AppreciationRuleUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.AppreciationRuleUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationRulePayload>[];
        };
        upsert: {
          args: Prisma.AppreciationRuleUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppreciationRulePayload>;
        };
        aggregate: {
          args: Prisma.AppreciationRuleAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateAppreciationRule>;
        };
        groupBy: {
          args: Prisma.AppreciationRuleGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AppreciationRuleGroupByOutputType>[];
        };
        count: {
          args: Prisma.AppreciationRuleCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.AppreciationRuleCountAggregateOutputType>
            | number;
        };
      };
    };
    ScheduleDivision: {
      payload: Prisma.$ScheduleDivisionPayload<ExtArgs>;
      fields: Prisma.ScheduleDivisionFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.ScheduleDivisionFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduleDivisionPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.ScheduleDivisionFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduleDivisionPayload>;
        };
        findFirst: {
          args: Prisma.ScheduleDivisionFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduleDivisionPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.ScheduleDivisionFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduleDivisionPayload>;
        };
        findMany: {
          args: Prisma.ScheduleDivisionFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduleDivisionPayload>[];
        };
        create: {
          args: Prisma.ScheduleDivisionCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduleDivisionPayload>;
        };
        createMany: {
          args: Prisma.ScheduleDivisionCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.ScheduleDivisionCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduleDivisionPayload>[];
        };
        delete: {
          args: Prisma.ScheduleDivisionDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduleDivisionPayload>;
        };
        update: {
          args: Prisma.ScheduleDivisionUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduleDivisionPayload>;
        };
        deleteMany: {
          args: Prisma.ScheduleDivisionDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.ScheduleDivisionUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.ScheduleDivisionUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduleDivisionPayload>[];
        };
        upsert: {
          args: Prisma.ScheduleDivisionUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduleDivisionPayload>;
        };
        aggregate: {
          args: Prisma.ScheduleDivisionAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateScheduleDivision>;
        };
        groupBy: {
          args: Prisma.ScheduleDivisionGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.ScheduleDivisionGroupByOutputType>[];
        };
        count: {
          args: Prisma.ScheduleDivisionCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.ScheduleDivisionCountAggregateOutputType>
            | number;
        };
      };
    };
  };
} & {
  other: {
    payload: any;
    operations: {
      $executeRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]];
        result: any;
      };
      $executeRawUnsafe: {
        args: [query: string, ...values: any[]];
        result: any;
      };
      $queryRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]];
        result: any;
      };
      $queryRawUnsafe: {
        args: [query: string, ...values: any[]];
        result: any;
      };
    };
  };
};

/**
 * Enums
 */

export const TransactionIsolationLevel = runtime.makeStrictEnum({
  ReadUncommitted: "ReadUncommitted",
  ReadCommitted: "ReadCommitted",
  RepeatableRead: "RepeatableRead",
  Serializable: "Serializable",
} as const);

export type TransactionIsolationLevel =
  (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel];

export const AiChatScalarFieldEnum = {
  id: "id",
  createdAt: "createdAt",
  title: "title",
  userId: "userId",
  visibility: "visibility",
} as const;

export type AiChatScalarFieldEnum =
  (typeof AiChatScalarFieldEnum)[keyof typeof AiChatScalarFieldEnum];

export const AiMessageScalarFieldEnum = {
  id: "id",
  chatId: "chatId",
  role: "role",
  parts: "parts",
  attachments: "attachments",
  createdAt: "createdAt",
} as const;

export type AiMessageScalarFieldEnum =
  (typeof AiMessageScalarFieldEnum)[keyof typeof AiMessageScalarFieldEnum];

export const VoteScalarFieldEnum = {
  chatId: "chatId",
  messageId: "messageId",
  isUpvoted: "isUpvoted",
} as const;

export type VoteScalarFieldEnum =
  (typeof VoteScalarFieldEnum)[keyof typeof VoteScalarFieldEnum];

export const AiDocumentScalarFieldEnum = {
  id: "id",
  createdAt: "createdAt",
  title: "title",
  content: "content",
  kind: "kind",
  userId: "userId",
} as const;

export type AiDocumentScalarFieldEnum =
  (typeof AiDocumentScalarFieldEnum)[keyof typeof AiDocumentScalarFieldEnum];

export const AiSuggestionScalarFieldEnum = {
  id: "id",
  documentId: "documentId",
  documentCreatedAt: "documentCreatedAt",
  originalText: "originalText",
  suggestedText: "suggestedText",
  description: "description",
  isResolved: "isResolved",
  userId: "userId",
  createdAt: "createdAt",
} as const;

export type AiSuggestionScalarFieldEnum =
  (typeof AiSuggestionScalarFieldEnum)[keyof typeof AiSuggestionScalarFieldEnum];

export const StreamScalarFieldEnum = {
  id: "id",
  chatId: "chatId",
  createdAt: "createdAt",
} as const;

export type StreamScalarFieldEnum =
  (typeof StreamScalarFieldEnum)[keyof typeof StreamScalarFieldEnum];

export const AbsenceScalarFieldEnum = {
  id: "id",
  date: "date",
  value: "value",
  termId: "termId",
  studentId: "studentId",
  type: "type",
  createdAt: "createdAt",
  createdById: "createdById",
  attachments: "attachments",
  reason: "reason",
} as const;

export type AbsenceScalarFieldEnum =
  (typeof AbsenceScalarFieldEnum)[keyof typeof AbsenceScalarFieldEnum];

export const AbsenceJustificationScalarFieldEnum = {
  id: "id",
  absenceId: "absenceId",
  value: "value",
  createdAt: "createdAt",
  createdById: "createdById",
  reason: "reason",
} as const;

export type AbsenceJustificationScalarFieldEnum =
  (typeof AbsenceJustificationScalarFieldEnum)[keyof typeof AbsenceJustificationScalarFieldEnum];

export const LatenessScalarFieldEnum = {
  id: "id",
  studentId: "studentId",
  date: "date",
  termId: "termId",
  duration: "duration",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  createdById: "createdById",
  updatedById: "updatedById",
  attachments: "attachments",
  reason: "reason",
} as const;

export type LatenessScalarFieldEnum =
  (typeof LatenessScalarFieldEnum)[keyof typeof LatenessScalarFieldEnum];

export const LatenessJustificationScalarFieldEnum = {
  id: "id",
  latenessId: "latenessId",
  value: "value",
  createdAt: "createdAt",
  createdById: "createdById",
  reason: "reason",
} as const;

export type LatenessJustificationScalarFieldEnum =
  (typeof LatenessJustificationScalarFieldEnum)[keyof typeof LatenessJustificationScalarFieldEnum];

export const ChatterScalarFieldEnum = {
  id: "id",
  date: "date",
  value: "value",
  termId: "termId",
  studentId: "studentId",
  type: "type",
  createdAt: "createdAt",
  createdById: "createdById",
} as const;

export type ChatterScalarFieldEnum =
  (typeof ChatterScalarFieldEnum)[keyof typeof ChatterScalarFieldEnum];

export const ConsigneScalarFieldEnum = {
  id: "id",
  studentId: "studentId",
  termId: "termId",
  date: "date",
  task: "task",
  duration: "duration",
  createdById: "createdById",
  createdAt: "createdAt",
} as const;

export type ConsigneScalarFieldEnum =
  (typeof ConsigneScalarFieldEnum)[keyof typeof ConsigneScalarFieldEnum];

export const ExclusionScalarFieldEnum = {
  id: "id",
  studentId: "studentId",
  termId: "termId",
  startDate: "startDate",
  endDate: "endDate",
  reason: "reason",
  createdAt: "createdAt",
  createdById: "createdById",
} as const;

export type ExclusionScalarFieldEnum =
  (typeof ExclusionScalarFieldEnum)[keyof typeof ExclusionScalarFieldEnum];

export const PreventedAbsenceScalarFieldEnum = {
  id: "id",
  studentId: "studentId",
  from: "from",
  to: "to",
  attachments: "attachments",
  reason: "reason",
  comment: "comment",
  createdAt: "createdAt",
  createdById: "createdById",
  status: "status",
  approvedById: "approvedById",
  approvedAt: "approvedAt",
} as const;

export type PreventedAbsenceScalarFieldEnum =
  (typeof PreventedAbsenceScalarFieldEnum)[keyof typeof PreventedAbsenceScalarFieldEnum];

export const ConvocationScalarFieldEnum = {
  id: "id",
  studentId: "studentId",
  termId: "termId",
  date: "date",
  reason: "reason",
  createdAt: "createdAt",
  createdById: "createdById",
  comment: "comment",
} as const;

export type ConvocationScalarFieldEnum =
  (typeof ConvocationScalarFieldEnum)[keyof typeof ConvocationScalarFieldEnum];

export const TimetableCategoryScalarFieldEnum = {
  id: "id",
  name: "name",
  schoolId: "schoolId",
  schoolYearId: "schoolYearId",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type TimetableCategoryScalarFieldEnum =
  (typeof TimetableCategoryScalarFieldEnum)[keyof typeof TimetableCategoryScalarFieldEnum];

export const SubjectTimetableScalarFieldEnum = {
  id: "id",
  start: "start",
  end: "end",
  subjectId: "subjectId",
  schoolId: "schoolId",
  groupKey: "groupKey",
  categoryId: "categoryId",
} as const;

export type SubjectTimetableScalarFieldEnum =
  (typeof SubjectTimetableScalarFieldEnum)[keyof typeof SubjectTimetableScalarFieldEnum];

export const PeriodicAttendanceScalarFieldEnum = {
  id: "id",
  absence: "absence",
  justifiedAbsence: "justifiedAbsence",
  lateness: "lateness",
  justifiedLateness: "justifiedLateness",
  chatter: "chatter",
  consigne: "consigne",
  studentId: "studentId",
  termId: "termId",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  createdById: "createdById",
} as const;

export type PeriodicAttendanceScalarFieldEnum =
  (typeof PeriodicAttendanceScalarFieldEnum)[keyof typeof PeriodicAttendanceScalarFieldEnum];

export const BibleTextScalarFieldEnum = {
  id: "id",
  book: "book",
  chapter: "chapter",
  verse: "verse",
  text: "text",
  language: "language",
  version: "version",
} as const;

export type BibleTextScalarFieldEnum =
  (typeof BibleTextScalarFieldEnum)[keyof typeof BibleTextScalarFieldEnum];

export const InventoryAssetScalarFieldEnum = {
  id: "id",
  name: "name",
  sku: "sku",
  serial: "serial",
  note: "note",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  schoolId: "schoolId",
} as const;

export type InventoryAssetScalarFieldEnum =
  (typeof InventoryAssetScalarFieldEnum)[keyof typeof InventoryAssetScalarFieldEnum];

export const InventoryConsumableScalarFieldEnum = {
  id: "id",
  name: "name",
  note: "note",
  unitId: "unitId",
  currentStock: "currentStock",
  minStockLevel: "minStockLevel",
  schoolId: "schoolId",
  schoolYearId: "schoolYearId",
} as const;

export type InventoryConsumableScalarFieldEnum =
  (typeof InventoryConsumableScalarFieldEnum)[keyof typeof InventoryConsumableScalarFieldEnum];

export const InventoryAssetUsageScalarFieldEnum = {
  id: "id",
  assetId: "assetId",
  userId: "userId",
  location: "location",
  status: "status",
  note: "note",
  createdAt: "createdAt",
  createdById: "createdById",
  approvedAt: "approvedAt",
  approvedBy: "approvedBy",
  returnedAt: "returnedAt",
  schoolYearId: "schoolYearId",
} as const;

export type InventoryAssetUsageScalarFieldEnum =
  (typeof InventoryAssetUsageScalarFieldEnum)[keyof typeof InventoryAssetUsageScalarFieldEnum];

export const InventoryConsumableUsageScalarFieldEnum = {
  id: "id",
  userId: "userId",
  quantity: "quantity",
  note: "note",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  schoolYearId: "schoolYearId",
  schoolId: "schoolId",
  consumableId: "consumableId",
  createdById: "createdById",
} as const;

export type InventoryConsumableUsageScalarFieldEnum =
  (typeof InventoryConsumableUsageScalarFieldEnum)[keyof typeof InventoryConsumableUsageScalarFieldEnum];

export const InventoryUnitScalarFieldEnum = {
  id: "id",
  name: "name",
  schoolId: "schoolId",
} as const;

export type InventoryUnitScalarFieldEnum =
  (typeof InventoryUnitScalarFieldEnum)[keyof typeof InventoryUnitScalarFieldEnum];

export const InventoryStockMovementScalarFieldEnum = {
  id: "id",
  quantity: "quantity",
  type: "type",
  note: "note",
  createdAt: "createdAt",
  createdById: "createdById",
  consumableId: "consumableId",
  schoolYearId: "schoolYearId",
  schoolId: "schoolId",
} as const;

export type InventoryStockMovementScalarFieldEnum =
  (typeof InventoryStockMovementScalarFieldEnum)[keyof typeof InventoryStockMovementScalarFieldEnum];

export const BookScalarFieldEnum = {
  id: "id",
  title: "title",
  description: "description",
  year: "year",
  author: "author",
  isbn: "isbn",
  publishedAt: "publishedAt",
  lastBorrowed: "lastBorrowed",
  tags: "tags",
  schoolId: "schoolId",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  categoryId: "categoryId",
  available: "available",
} as const;

export type BookScalarFieldEnum =
  (typeof BookScalarFieldEnum)[keyof typeof BookScalarFieldEnum];

export const BookCategoryScalarFieldEnum = {
  id: "id",
  name: "name",
  schoolId: "schoolId",
} as const;

export type BookCategoryScalarFieldEnum =
  (typeof BookCategoryScalarFieldEnum)[keyof typeof BookCategoryScalarFieldEnum];

export const BorrowedBookScalarFieldEnum = {
  id: "id",
  bookId: "bookId",
  userId: "userId",
  borrowed: "borrowed",
  returned: "returned",
  expected: "expected",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type BorrowedBookScalarFieldEnum =
  (typeof BorrowedBookScalarFieldEnum)[keyof typeof BorrowedBookScalarFieldEnum];

export const ShortcutScalarFieldEnum = {
  id: "id",
  title: "title",
  url: "url",
  userId: "userId",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  schoolId: "schoolId",
} as const;

export type ShortcutScalarFieldEnum =
  (typeof ShortcutScalarFieldEnum)[keyof typeof ShortcutScalarFieldEnum];

export const EmailScalarFieldEnum = {
  id: "id",
  subject: "subject",
  body: "body",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  senderId: "senderId",
  parentEmailId: "parentEmailId",
  deletedBySenderAt: "deletedBySenderAt",
} as const;

export type EmailScalarFieldEnum =
  (typeof EmailScalarFieldEnum)[keyof typeof EmailScalarFieldEnum];

export const EmailRecipientScalarFieldEnum = {
  id: "id",
  emailId: "emailId",
  userId: "userId",
  readAt: "readAt",
  deletedAt: "deletedAt",
} as const;

export type EmailRecipientScalarFieldEnum =
  (typeof EmailRecipientScalarFieldEnum)[keyof typeof EmailRecipientScalarFieldEnum];

export const AttachmentScalarFieldEnum = {
  id: "id",
  emailId: "emailId",
  filename: "filename",
  url: "url",
} as const;

export type AttachmentScalarFieldEnum =
  (typeof AttachmentScalarFieldEnum)[keyof typeof AttachmentScalarFieldEnum];

export const CommunicationChannelScalarFieldEnum = {
  id: "id",
  name: "name",
  type: "type",
  url: "url",
  schoolId: "schoolId",
  schoolYearId: "schoolYearId",
  classroomId: "classroomId",
  description: "description",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  lastAccessedAt: "lastAccessedAt",
  lastAccessedById: "lastAccessedById",
} as const;

export type CommunicationChannelScalarFieldEnum =
  (typeof CommunicationChannelScalarFieldEnum)[keyof typeof CommunicationChannelScalarFieldEnum];

export const RecipientGroupScalarFieldEnum = {
  id: "id",
  name: "name",
} as const;

export type RecipientGroupScalarFieldEnum =
  (typeof RecipientGroupScalarFieldEnum)[keyof typeof RecipientGroupScalarFieldEnum];

export const FeedbackScalarFieldEnum = {
  id: "id",
  content: "content",
  createdAt: "createdAt",
  createdById: "createdById",
} as const;

export type FeedbackScalarFieldEnum =
  (typeof FeedbackScalarFieldEnum)[keyof typeof FeedbackScalarFieldEnum];

export const RecipientScalarFieldEnum = {
  groupId: "groupId",
  userId: "userId",
} as const;

export type RecipientScalarFieldEnum =
  (typeof RecipientScalarFieldEnum)[keyof typeof RecipientScalarFieldEnum];

export const AnnouncementScalarFieldEnum = {
  id: "id",
  title: "title",
  description: "description",
  link: "link",
  from: "from",
  to: "to",
  level: "level",
  recipients: "recipients",
  createdAt: "createdAt",
  createdById: "createdById",
  updatedAt: "updatedAt",
  updatedBy: "updatedBy",
} as const;

export type AnnouncementScalarFieldEnum =
  (typeof AnnouncementScalarFieldEnum)[keyof typeof AnnouncementScalarFieldEnum];

export const PolicyScalarFieldEnum = {
  id: "id",
  name: "name",
  effect: "effect",
  actions: "actions",
  resources: "resources",
  description: "description",
  category: "category",
  isActive: "isActive",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  createdById: "createdById",
  updatedBy: "updatedBy",
  condition: "condition",
  schoolId: "schoolId",
} as const;

export type PolicyScalarFieldEnum =
  (typeof PolicyScalarFieldEnum)[keyof typeof PolicyScalarFieldEnum];

export const AppreciationScalarFieldEnum = {
  id: "id",
  content: "content",
  isActive: "isActive",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  categoryId: "categoryId",
} as const;

export type AppreciationScalarFieldEnum =
  (typeof AppreciationScalarFieldEnum)[keyof typeof AppreciationScalarFieldEnum];

export const ReportCardScalarFieldEnum = {
  studentId: "studentId",
  classroomId: "classroomId",
  termId: "termId",
  remark: "remark",
  createdById: "createdById",
  remarkAt: "remarkAt",
} as const;

export type ReportCardScalarFieldEnum =
  (typeof ReportCardScalarFieldEnum)[keyof typeof ReportCardScalarFieldEnum];

export const ReportScalarFieldEnum = {
  id: "id",
  code: "code",
  category: "category",
  name: "name",
  isActive: "isActive",
  type: "type",
  link: "link",
  createdAt: "createdAt",
} as const;

export type ReportScalarFieldEnum =
  (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum];

export const HealthVisitScalarFieldEnum = {
  id: "id",
  createdAt: "createdAt",
  complaint: "complaint",
  date: "date",
  signs: "signs",
  examination: "examination",
  assessment: "assessment",
  plan: "plan",
  notify: "notify",
  attachments: "attachments",
  userId: "userId",
  createdById: "createdById",
} as const;

export type HealthVisitScalarFieldEnum =
  (typeof HealthVisitScalarFieldEnum)[keyof typeof HealthVisitScalarFieldEnum];

export const ClassroomScalarFieldEnum = {
  id: "id",
  name: "name",
  reportName: "reportName",
  maxSize: "maxSize",
  levelId: "levelId",
  sectionId: "sectionId",
  cycleId: "cycleId",
  schoolYearId: "schoolYearId",
  seniorAdvisorId: "seniorAdvisorId",
  headTeacherId: "headTeacherId",
  classroomLeaderId: "classroomLeaderId",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  updatedBy: "updatedBy",
  deletedAt: "deletedAt",
  deletedBy: "deletedBy",
  schoolId: "schoolId",
  createdById: "createdById",
  appreciationRuleSetId: "appreciationRuleSetId",
} as const;

export type ClassroomScalarFieldEnum =
  (typeof ClassroomScalarFieldEnum)[keyof typeof ClassroomScalarFieldEnum];

export const EnrollmentScalarFieldEnum = {
  id: "id",
  schoolYearId: "schoolYearId",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  createdById: "createdById",
  classroomId: "classroomId",
  observation: "observation",
  studentId: "studentId",
} as const;

export type EnrollmentScalarFieldEnum =
  (typeof EnrollmentScalarFieldEnum)[keyof typeof EnrollmentScalarFieldEnum];

export const ReportingScalarFieldEnum = {
  id: "id",
  url: "url",
  title: "title",
  type: "type",
  size: "size",
  createdAt: "createdAt",
  status: "status",
  userId: "userId",
  schoolId: "schoolId",
} as const;

export type ReportingScalarFieldEnum =
  (typeof ReportingScalarFieldEnum)[keyof typeof ReportingScalarFieldEnum];

export const ClassroomLevelScalarFieldEnum = {
  id: "id",
  name: "name",
  order: "order",
  schoolId: "schoolId",
} as const;

export type ClassroomLevelScalarFieldEnum =
  (typeof ClassroomLevelScalarFieldEnum)[keyof typeof ClassroomLevelScalarFieldEnum];

export const CalendarTypeScalarFieldEnum = {
  id: "id",
  name: "name",
  backgroundColor: "backgroundColor",
} as const;

export type CalendarTypeScalarFieldEnum =
  (typeof CalendarTypeScalarFieldEnum)[keyof typeof CalendarTypeScalarFieldEnum];

export const CalendarEventScalarFieldEnum = {
  id: "id",
  calendarTypeId: "calendarTypeId",
  title: "title",
  description: "description",
  start: "start",
  end: "end",
  repeat: "repeat",
  alert: "alert",
  data: "data",
} as const;

export type CalendarEventScalarFieldEnum =
  (typeof CalendarEventScalarFieldEnum)[keyof typeof CalendarEventScalarFieldEnum];

export const GradeSheetScalarFieldEnum = {
  id: "id",
  name: "name",
  isActive: "isActive",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  status: "status",
  createdById: "createdById",
  observation: "observation",
  weight: "weight",
  scale: "scale",
  subjectId: "subjectId",
  termId: "termId",
  appreciationRuleSetId: "appreciationRuleSetId",
} as const;

export type GradeSheetScalarFieldEnum =
  (typeof GradeSheetScalarFieldEnum)[keyof typeof GradeSheetScalarFieldEnum];

export const GradeScalarFieldEnum = {
  id: "id",
  grade: "grade",
  observation: "observation",
  updatedAt: "updatedAt",
  updatedBy: "updatedBy",
  isAbsent: "isAbsent",
  gradeSheetId: "gradeSheetId",
  studentId: "studentId",
} as const;

export type GradeScalarFieldEnum =
  (typeof GradeScalarFieldEnum)[keyof typeof GradeScalarFieldEnum];

export const AssignmentCategoryScalarFieldEnum = {
  id: "id",
  name: "name",
  isActive: "isActive",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  createdBy: "createdBy",
  updatedBy: "updatedBy",
} as const;

export type AssignmentCategoryScalarFieldEnum =
  (typeof AssignmentCategoryScalarFieldEnum)[keyof typeof AssignmentCategoryScalarFieldEnum];

export const AppreciationCategoryScalarFieldEnum = {
  id: "id",
  name: "name",
  isActive: "isActive",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  createdBy: "createdBy",
} as const;

export type AppreciationCategoryScalarFieldEnum =
  (typeof AppreciationCategoryScalarFieldEnum)[keyof typeof AppreciationCategoryScalarFieldEnum];

export const AssignmentScalarFieldEnum = {
  id: "id",
  title: "title",
  description: "description",
  isActive: "isActive",
  categoryId: "categoryId",
  subjectId: "subjectId",
  termId: "termId",
  post: "post",
  dueDate: "dueDate",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  createdById: "createdById",
  classroomId: "classroomId",
  from: "from",
  to: "to",
  visibles: "visibles",
  attachments: "attachments",
  sections: "sections",
  notify: "notify",
} as const;

export type AssignmentScalarFieldEnum =
  (typeof AssignmentScalarFieldEnum)[keyof typeof AssignmentScalarFieldEnum];

export const EventScalarFieldEnum = {
  id: "id",
  start: "start",
  end: "end",
  allDay: "allDay",
  title: "title",
  description: "description",
  location: "location",
} as const;

export type EventScalarFieldEnum =
  (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum];

export const TermScalarFieldEnum = {
  id: "id",
  name: "name",
  schoolYearId: "schoolYearId",
  order: "order",
  startDate: "startDate",
  endDate: "endDate",
  isActive: "isActive",
  observation: "observation",
  schoolId: "schoolId",
} as const;

export type TermScalarFieldEnum =
  (typeof TermScalarFieldEnum)[keyof typeof TermScalarFieldEnum];

export const ContactRelationshipScalarFieldEnum = {
  id: "id",
  name: "name",
  schoolId: "schoolId",
} as const;

export type ContactRelationshipScalarFieldEnum =
  (typeof ContactRelationshipScalarFieldEnum)[keyof typeof ContactRelationshipScalarFieldEnum];

export const StaffDegreeScalarFieldEnum = {
  id: "id",
  name: "name",
  schoolId: "schoolId",
} as const;

export type StaffDegreeScalarFieldEnum =
  (typeof StaffDegreeScalarFieldEnum)[keyof typeof StaffDegreeScalarFieldEnum];

export const StaffScalarFieldEnum = {
  id: "id",
  prefix: "prefix",
  firstName: "firstName",
  lastName: "lastName",
  isActive: "isActive",
  jobTitle: "jobTitle",
  employmentType: "employmentType",
  degreeId: "degreeId",
  dateOfHire: "dateOfHire",
  bloodType: "bloodType",
  dateOfBirth: "dateOfBirth",
  sendAgendaFrequency: "sendAgendaFrequency",
  dateOfRelease: "dateOfRelease",
  isTeacher: "isTeacher",
  gender: "gender",
  phoneNumber1: "phoneNumber1",
  phoneNumber2: "phoneNumber2",
  address: "address",
  observation: "observation",
  dateOfCriminalRecordCheck: "dateOfCriminalRecordCheck",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  userId: "userId",
  countryId: "countryId",
  dateOfLastAdvancement: "dateOfLastAdvancement",
  schoolId: "schoolId",
} as const;

export type StaffScalarFieldEnum =
  (typeof StaffScalarFieldEnum)[keyof typeof StaffScalarFieldEnum];

export const DocumentScalarFieldEnum = {
  id: "id",
  title: "title",
  description: "description",
  userId: "userId",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  createdById: "createdById",
  attachments: "attachments",
  schoolId: "schoolId",
} as const;

export type DocumentScalarFieldEnum =
  (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum];

export const StudentScalarFieldEnum = {
  id: "id",
  registrationNumber: "registrationNumber",
  isActive: "isActive",
  firstName: "firstName",
  lastName: "lastName",
  dateOfBirth: "dateOfBirth",
  bloodType: "bloodType",
  placeOfBirth: "placeOfBirth",
  photos: "photos",
  residence: "residence",
  status: "status",
  gender: "gender",
  religionId: "religionId",
  isBaptized: "isBaptized",
  isRepeating: "isRepeating",
  isNew: "isNew",
  phoneNumber: "phoneNumber",
  parentDivorced: "parentDivorced",
  dateOfEntry: "dateOfEntry",
  dateOfExit: "dateOfExit",
  dateOfWithdraw: "dateOfWithdraw",
  lastAccessed: "lastAccessed",
  observation: "observation",
  externalAccountingNo: "externalAccountingNo",
  allergies: "allergies",
  countryId: "countryId",
  userId: "userId",
  tags: "tags",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  createdById: "createdById",
  formerSchoolId: "formerSchoolId",
  achievements: "achievements",
  hobbies: "hobbies",
  socialMedias: "socialMedias",
  schoolId: "schoolId",
} as const;

export type StudentScalarFieldEnum =
  (typeof StudentScalarFieldEnum)[keyof typeof StudentScalarFieldEnum];

export const StudentSiblingScalarFieldEnum = {
  studentId: "studentId",
  siblingId: "siblingId",
} as const;

export type StudentSiblingScalarFieldEnum =
  (typeof StudentSiblingScalarFieldEnum)[keyof typeof StudentSiblingScalarFieldEnum];

export const RequiredFeeTransactionScalarFieldEnum = {
  id: "id",
  studentId: "studentId",
  feeId: "feeId",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  createdById: "createdById",
  status: "status",
  updatedById: "updatedById",
} as const;

export type RequiredFeeTransactionScalarFieldEnum =
  (typeof RequiredFeeTransactionScalarFieldEnum)[keyof typeof RequiredFeeTransactionScalarFieldEnum];

export const FeeScalarFieldEnum = {
  id: "id",
  description: "description",
  code: "code",
  amount: "amount",
  dueDate: "dueDate",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  createdBy: "createdBy",
  updatedBy: "updatedBy",
  classroomId: "classroomId",
  journalId: "journalId",
} as const;

export type FeeScalarFieldEnum =
  (typeof FeeScalarFieldEnum)[keyof typeof FeeScalarFieldEnum];

export const StudentContactScalarFieldEnum = {
  studentId: "studentId",
  contactId: "contactId",
  relationshipId: "relationshipId",
  livesWith: "livesWith",
  schoolPickup: "schoolPickup",
  emergencyContact: "emergencyContact",
  observation: "observation",
  accessAttendance: "accessAttendance",
  accessBilling: "accessBilling",
  accessDiscipline: "accessDiscipline",
  accessReportCard: "accessReportCard",
  accessScheduling: "accessScheduling",
  canAccessData: "canAccessData",
  enablePortalAccess: "enablePortalAccess",
  primaryContact: "primaryContact",
  paysFee: "paysFee",
} as const;

export type StudentContactScalarFieldEnum =
  (typeof StudentContactScalarFieldEnum)[keyof typeof StudentContactScalarFieldEnum];

export const ContactScalarFieldEnum = {
  id: "id",
  prefix: "prefix",
  firstName: "firstName",
  lastName: "lastName",
  occupation: "occupation",
  employer: "employer",
  phoneNumber1: "phoneNumber1",
  phoneNumber2: "phoneNumber2",
  isActive: "isActive",
  address: "address",
  gender: "gender",
  observation: "observation",
  createdAt: "createdAt",
  lastAccessed: "lastAccessed",
  updatedAt: "updatedAt",
  userId: "userId",
  countryId: "countryId",
  schoolId: "schoolId",
} as const;

export type ContactScalarFieldEnum =
  (typeof ContactScalarFieldEnum)[keyof typeof ContactScalarFieldEnum];

export const CountryScalarFieldEnum = {
  id: "id",
  name: "name",
  codeIso3: "codeIso3",
} as const;

export type CountryScalarFieldEnum =
  (typeof CountryScalarFieldEnum)[keyof typeof CountryScalarFieldEnum];

export const SchoolScalarFieldEnum = {
  id: "id",
  code: "code",
  name: "name",
  authorization: "authorization",
  ministry: "ministry",
  department: "department",
  region: "region",
  defaultLocale: "defaultLocale",
  city: "city",
  headmaster: "headmaster",
  phoneNumber1: "phoneNumber1",
  phoneNumber2: "phoneNumber2",
  email: "email",
  website: "website",
  numberOfReceipts: "numberOfReceipts",
  logo: "logo",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  isActive: "isActive",
  address: "address",
  timezone: "timezone",
  defaultCountryId: "defaultCountryId",
  registrationPrefix: "registrationPrefix",
  requestSunPlusNo: "requestSunPlusNo",
  allowOverEnrollment: "allowOverEnrollment",
  applyRequiredFee: "applyRequiredFee",
  includeRequiredFee: "includeRequiredFee",
  hasQuarterlyReports: "hasQuarterlyReports",
  currency: "currency",
  appreciationRuleSetId: "appreciationRuleSetId",
} as const;

export type SchoolScalarFieldEnum =
  (typeof SchoolScalarFieldEnum)[keyof typeof SchoolScalarFieldEnum];

export const RequiredAccountingJournalScalarFieldEnum = {
  id: "id",
  journalId: "journalId",
  schoolId: "schoolId",
} as const;

export type RequiredAccountingJournalScalarFieldEnum =
  (typeof RequiredAccountingJournalScalarFieldEnum)[keyof typeof RequiredAccountingJournalScalarFieldEnum];

export const FormerSchoolScalarFieldEnum = {
  id: "id",
  name: "name",
  phoneNumber1: "phoneNumber1",
  phoneNumber2: "phoneNumber2",
  headOfSchool: "headOfSchool",
  address: "address",
  type: "type",
  createdAt: "createdAt",
  createdById: "createdById",
  schoolId: "schoolId",
} as const;

export type FormerSchoolScalarFieldEnum =
  (typeof FormerSchoolScalarFieldEnum)[keyof typeof FormerSchoolScalarFieldEnum];

export const SubjectScalarFieldEnum = {
  id: "id",
  courseId: "courseId",
  teacherId: "teacherId",
  classroomId: "classroomId",
  subjectGroupId: "subjectGroupId",
  program: "program",
  order: "order",
  coefficient: "coefficient",
} as const;

export type SubjectScalarFieldEnum =
  (typeof SubjectScalarFieldEnum)[keyof typeof SubjectScalarFieldEnum];

export const SubjectGroupScalarFieldEnum = {
  id: "id",
  name: "name",
  schoolId: "schoolId",
} as const;

export type SubjectGroupScalarFieldEnum =
  (typeof SubjectGroupScalarFieldEnum)[keyof typeof SubjectGroupScalarFieldEnum];

export const CourseScalarFieldEnum = {
  id: "id",
  name: "name",
  color: "color",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  shortName: "shortName",
  reportName: "reportName",
  isActive: "isActive",
  schoolId: "schoolId",
} as const;

export type CourseScalarFieldEnum =
  (typeof CourseScalarFieldEnum)[keyof typeof CourseScalarFieldEnum];

export const SchoolYearScalarFieldEnum = {
  id: "id",
  observation: "observation",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  abbreviation: "abbreviation",
  createdBy: "createdBy",
  updatedBy: "updatedBy",
  isDefault: "isDefault",
  deletedAt: "deletedAt",
  deletedBy: "deletedBy",
  isActive: "isActive",
  isDeleted: "isDeleted",
  name: "name",
  startDate: "startDate",
  endDate: "endDate",
  enrollmentStartDate: "enrollmentStartDate",
  enrollmentEndDate: "enrollmentEndDate",
  schoolId: "schoolId",
} as const;

export type SchoolYearScalarFieldEnum =
  (typeof SchoolYearScalarFieldEnum)[keyof typeof SchoolYearScalarFieldEnum];

export const ClassroomCycleScalarFieldEnum = {
  id: "id",
  name: "name",
  schoolId: "schoolId",
} as const;

export type ClassroomCycleScalarFieldEnum =
  (typeof ClassroomCycleScalarFieldEnum)[keyof typeof ClassroomCycleScalarFieldEnum];

export const ClassroomSectionScalarFieldEnum = {
  id: "id",
  name: "name",
  schoolId: "schoolId",
} as const;

export type ClassroomSectionScalarFieldEnum =
  (typeof ClassroomSectionScalarFieldEnum)[keyof typeof ClassroomSectionScalarFieldEnum];

export const UserRoleScalarFieldEnum = {
  userId: "userId",
  roleId: "roleId",
  createdById: "createdById",
} as const;

export type UserRoleScalarFieldEnum =
  (typeof UserRoleScalarFieldEnum)[keyof typeof UserRoleScalarFieldEnum];

export const TokenScalarFieldEnum = {
  id: "id",
  token: "token",
  type: "type",
  expires: "expires",
  blacklisted: "blacklisted",
  createdAt: "createdAt",
  userId: "userId",
} as const;

export type TokenScalarFieldEnum =
  (typeof TokenScalarFieldEnum)[keyof typeof TokenScalarFieldEnum];

export const MenuItemScalarFieldEnum = {
  id: "id",
  name: "name",
  title: "title",
  href: "href",
  order: "order",
  category: "category",
  isActive: "isActive",
} as const;

export type MenuItemScalarFieldEnum =
  (typeof MenuItemScalarFieldEnum)[keyof typeof MenuItemScalarFieldEnum];

export const ProgramCategoryScalarFieldEnum = {
  id: "id",
  title: "title",
  color: "color",
  isActive: "isActive",
  schoolYearId: "schoolYearId",
} as const;

export type ProgramCategoryScalarFieldEnum =
  (typeof ProgramCategoryScalarFieldEnum)[keyof typeof ProgramCategoryScalarFieldEnum];

export const ProgramScalarFieldEnum = {
  id: "id",
  title: "title",
  description: "description",
  subjectId: "subjectId",
  requiredSessionCount: "requiredSessionCount",
  categoryId: "categoryId",
} as const;

export type ProgramScalarFieldEnum =
  (typeof ProgramScalarFieldEnum)[keyof typeof ProgramScalarFieldEnum];

export const TeachingSessionProgramScalarFieldEnum = {
  sessionId: "sessionId",
  programId: "programId",
} as const;

export type TeachingSessionProgramScalarFieldEnum =
  (typeof TeachingSessionProgramScalarFieldEnum)[keyof typeof TeachingSessionProgramScalarFieldEnum];

export const TeachingSessionScalarFieldEnum = {
  id: "id",
  subjectId: "subjectId",
  title: "title",
  content: "content",
  createdById: "createdById",
  attachment: "attachment",
  createdAt: "createdAt",
  publishDate: "publishDate",
} as const;

export type TeachingSessionScalarFieldEnum =
  (typeof TeachingSessionScalarFieldEnum)[keyof typeof TeachingSessionScalarFieldEnum];

export const SMSTemplateScalarFieldEnum = {
  id: "id",
  name: "name",
  description: "description",
  content: "content",
  isActive: "isActive",
  createdAt: "createdAt",
  createdBy: "createdBy",
} as const;

export type SMSTemplateScalarFieldEnum =
  (typeof SMSTemplateScalarFieldEnum)[keyof typeof SMSTemplateScalarFieldEnum];

export const SMSHistoryScalarFieldEnum = {
  id: "id",
  message: "message",
  status: "status",
  createdAt: "createdAt",
  createdBy: "createdBy",
  sentAt: "sentAt",
} as const;

export type SMSHistoryScalarFieldEnum =
  (typeof SMSHistoryScalarFieldEnum)[keyof typeof SMSHistoryScalarFieldEnum];

export const SMSHistoryDetailScalarFieldEnum = {
  id: "id",
  smsHistoryId: "smsHistoryId",
  to: "to",
  status: "status",
  deliveredAt: "deliveredAt",
} as const;

export type SMSHistoryDetailScalarFieldEnum =
  (typeof SMSHistoryDetailScalarFieldEnum)[keyof typeof SMSHistoryDetailScalarFieldEnum];

export const PhotoScalarFieldEnum = {
  id: "id",
  photoUrl: "photoUrl",
  name: "name",
  createdAt: "createdAt",
  createdBy: "createdBy",
  userId: "userId",
} as const;

export type PhotoScalarFieldEnum =
  (typeof PhotoScalarFieldEnum)[keyof typeof PhotoScalarFieldEnum];

export const ReportQueueScalarFieldEnum = {
  id: "id",
  name: "name",
  code: "code",
  fromUrl: "fromUrl",
  filePath: "filePath",
  content: "content",
  status: "status",
  expectedDate: "expectedDate",
  createdAt: "createdAt",
  startedAt: "startedAt",
  completedAt: "completedAt",
  userId: "userId",
} as const;

export type ReportQueueScalarFieldEnum =
  (typeof ReportQueueScalarFieldEnum)[keyof typeof ReportQueueScalarFieldEnum];

export const ReligionScalarFieldEnum = {
  id: "id",
  name: "name",
  createdById: "createdById",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  schoolId: "schoolId",
} as const;

export type ReligionScalarFieldEnum =
  (typeof ReligionScalarFieldEnum)[keyof typeof ReligionScalarFieldEnum];

export const ClubScalarFieldEnum = {
  id: "id",
  name: "name",
  description: "description",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  presidentId: "presidentId",
  deputyId: "deputyId",
  schoolId: "schoolId",
} as const;

export type ClubScalarFieldEnum =
  (typeof ClubScalarFieldEnum)[keyof typeof ClubScalarFieldEnum];

export const StudentClubScalarFieldEnum = {
  studentId: "studentId",
  clubId: "clubId",
} as const;

export type StudentClubScalarFieldEnum =
  (typeof StudentClubScalarFieldEnum)[keyof typeof StudentClubScalarFieldEnum];

export const StudentSportScalarFieldEnum = {
  studentId: "studentId",
  sportId: "sportId",
} as const;

export type StudentSportScalarFieldEnum =
  (typeof StudentSportScalarFieldEnum)[keyof typeof StudentSportScalarFieldEnum];

export const InviteScalarFieldEnum = {
  id: "id",
  schoolId: "schoolId",
  entityId: "entityId",
  entityType: "entityType",
  token: "token",
  expiresAt: "expiresAt",
  used: "used",
  attempts: "attempts",
  lastAttempt: "lastAttempt",
} as const;

export type InviteScalarFieldEnum =
  (typeof InviteScalarFieldEnum)[keyof typeof InviteScalarFieldEnum];

export const SportScalarFieldEnum = {
  id: "id",
  name: "name",
  schoolId: "schoolId",
} as const;

export type SportScalarFieldEnum =
  (typeof SportScalarFieldEnum)[keyof typeof SportScalarFieldEnum];

export const TransactionScalarFieldEnum = {
  id: "id",
  transactionRef: "transactionRef",
  method: "method",
  amount: "amount",
  description: "description",
  transactionType: "transactionType",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  createdById: "createdById",
  receivedById: "receivedById",
  receivedAt: "receivedAt",
  isPrinted: "isPrinted",
  printedAt: "printedAt",
  printedById: "printedById",
  updatedById: "updatedById",
  updatedBy: "updatedBy",
  observation: "observation",
  deletedAt: "deletedAt",
  deletedById: "deletedById",
  status: "status",
  schoolYearId: "schoolYearId",
  studentId: "studentId",
  journalId: "journalId",
} as const;

export type TransactionScalarFieldEnum =
  (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum];

export const AccountingJournalScalarFieldEnum = {
  id: "id",
  name: "name",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  schoolYearId: "schoolYearId",
  schoolId: "schoolId",
  description: "description",
} as const;

export type AccountingJournalScalarFieldEnum =
  (typeof AccountingJournalScalarFieldEnum)[keyof typeof AccountingJournalScalarFieldEnum];

export const ScheduleTaskScalarFieldEnum = {
  id: "id",
  name: "name",
  cron: "cron",
  schoolYearId: "schoolYearId",
  schoolId: "schoolId",
  lastRun: "lastRun",
  status: "status",
  data: "data",
} as const;

export type ScheduleTaskScalarFieldEnum =
  (typeof ScheduleTaskScalarFieldEnum)[keyof typeof ScheduleTaskScalarFieldEnum];

export const GradeAppreciationScalarFieldEnum = {
  id: "id",
  minGrade: "minGrade",
  maxGrade: "maxGrade",
  appreciation: "appreciation",
  schoolId: "schoolId",
  schoolYearId: "schoolYearId",
} as const;

export type GradeAppreciationScalarFieldEnum =
  (typeof GradeAppreciationScalarFieldEnum)[keyof typeof GradeAppreciationScalarFieldEnum];

export const ClassroomGradeAppreciationScalarFieldEnum = {
  classroomId: "classroomId",
  gradeAppreciationId: "gradeAppreciationId",
} as const;

export type ClassroomGradeAppreciationScalarFieldEnum =
  (typeof ClassroomGradeAppreciationScalarFieldEnum)[keyof typeof ClassroomGradeAppreciationScalarFieldEnum];

export const HealthRecordScalarFieldEnum = {
  id: "id",
  studentId: "studentId",
  hasAdd: "hasAdd",
  addNotes: "addNotes",
  hasAllergies: "hasAllergies",
  allergyFood: "allergyFood",
  allergyInsectStings: "allergyInsectStings",
  allergyPollen: "allergyPollen",
  allergyAnimals: "allergyAnimals",
  allergyMedications: "allergyMedications",
  allergyNotes: "allergyNotes",
  usesEpiPenAtSchool: "usesEpiPenAtSchool",
  hasAsthma: "hasAsthma",
  asthmaNotes: "asthmaNotes",
  inhalerAtSchool: "inhalerAtSchool",
  hasMobilityIssues: "hasMobilityIssues",
  mobilityNotes: "mobilityNotes",
  hasDiabetes: "hasDiabetes",
  diabetesNotes: "diabetesNotes",
  needsInsulinOrGlucometer: "needsInsulinOrGlucometer",
  hasEarThroatInfections: "hasEarThroatInfections",
  earThroatNotes: "earThroatNotes",
  hasEmotionalIssues: "hasEmotionalIssues",
  emotionalNotes: "emotionalNotes",
  hasEpilepsy: "hasEpilepsy",
  epilepsyNotes: "epilepsyNotes",
  frequentHeadaches: "frequentHeadaches",
  frequentHeadachesNotes: "frequentHeadachesNotes",
  hasHeadInjuries: "hasHeadInjuries",
  headInjuriesNotes: "headInjuriesNotes",
  hasHeartIssues: "hasHeartIssues",
  heartIssuesNotes: "heartIssuesNotes",
  hasHearingLoss: "hasHearingLoss",
  hearingLossNotes: "hearingLossNotes",
  hasSeizures: "hasSeizures",
  seizuresNotes: "seizuresNotes",
  hasHandicap: "hasHandicap",
  handicapNotes: "handicapNotes",
  hasSkinProblems: "hasSkinProblems",
  skinProblemsNotes: "skinProblemsNotes",
  hasVisionProblems: "hasVisionProblems",
  visionProblemsNotes: "visionProblemsNotes",
  hasUrinaryProblems: "hasUrinaryProblems",
  urinaryProblemsNotes: "urinaryProblemsNotes",
  hospitalizationIssues: "hospitalizationIssues",
  hospitalizationNotes: "hospitalizationNotes",
  internalObservations: "internalObservations",
  observations: "observations",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type HealthRecordScalarFieldEnum =
  (typeof HealthRecordScalarFieldEnum)[keyof typeof HealthRecordScalarFieldEnum];

export const HealthDrugScalarFieldEnum = {
  id: "id",
  studentId: "studentId",
  name: "name",
  description: "description",
  dosage: "dosage",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type HealthDrugScalarFieldEnum =
  (typeof HealthDrugScalarFieldEnum)[keyof typeof HealthDrugScalarFieldEnum];

export const UserScalarFieldEnum = {
  id: "id",
  name: "name",
  email: "email",
  emailVerified: "emailVerified",
  image: "image",
  username: "username",
  displayUsername: "displayUsername",
  role: "role",
  banned: "banned",
  banReason: "banReason",
  banExpires: "banExpires",
  avatar: "avatar",
  isActive: "isActive",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  profile: "profile",
  permissions: "permissions",
  schoolId: "schoolId",
} as const;

export type UserScalarFieldEnum =
  (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum];

export const RoleScalarFieldEnum = {
  id: "id",
  name: "name",
  description: "description",
  isActive: "isActive",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  createdBy: "createdBy",
  updatedBy: "updatedBy",
  schoolId: "schoolId",
} as const;

export type RoleScalarFieldEnum =
  (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum];

export const RolePolicyScalarFieldEnum = {
  roleId: "roleId",
  policyId: "policyId",
  createdById: "createdById",
} as const;

export type RolePolicyScalarFieldEnum =
  (typeof RolePolicyScalarFieldEnum)[keyof typeof RolePolicyScalarFieldEnum];

export const UserPolicyScalarFieldEnum = {
  userId: "userId",
  policyId: "policyId",
  createdById: "createdById",
} as const;

export type UserPolicyScalarFieldEnum =
  (typeof UserPolicyScalarFieldEnum)[keyof typeof UserPolicyScalarFieldEnum];

export const NotificationPreferenceScalarFieldEnum = {
  id: "id",
  userId: "userId",
  event: "event",
  channels: "channels",
} as const;

export type NotificationPreferenceScalarFieldEnum =
  (typeof NotificationPreferenceScalarFieldEnum)[keyof typeof NotificationPreferenceScalarFieldEnum];

export const SubscriptionScalarFieldEnum = {
  id: "id",
  userId: "userId",
  sms: "sms",
  whatsapp: "whatsapp",
  email: "email",
  plan: "plan",
  createdAt: "createdAt",
  createdById: "createdById",
  updatedAt: "updatedAt",
  comment: "comment",
} as const;

export type SubscriptionScalarFieldEnum =
  (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum];

export const LogActivityScalarFieldEnum = {
  id: "id",
  userId: "userId",
  action: "action",
  entity: "entity",
  entityId: "entityId",
  metadata: "metadata",
  createdAt: "createdAt",
  schoolId: "schoolId",
} as const;

export type LogActivityScalarFieldEnum =
  (typeof LogActivityScalarFieldEnum)[keyof typeof LogActivityScalarFieldEnum];

export const SchoolYearEventScalarFieldEnum = {
  id: "id",
  name: "name",
  date: "date",
  createdAt: "createdAt",
  schoolId: "schoolId",
  schoolYearId: "schoolYearId",
  typeId: "typeId",
} as const;

export type SchoolYearEventScalarFieldEnum =
  (typeof SchoolYearEventScalarFieldEnum)[keyof typeof SchoolYearEventScalarFieldEnum];

export const SchoolYearEventTypeScalarFieldEnum = {
  id: "id",
  name: "name",
  color: "color",
  createdAt: "createdAt",
  schoolId: "schoolId",
} as const;

export type SchoolYearEventTypeScalarFieldEnum =
  (typeof SchoolYearEventTypeScalarFieldEnum)[keyof typeof SchoolYearEventTypeScalarFieldEnum];

export const SessionScalarFieldEnum = {
  id: "id",
  expiresAt: "expiresAt",
  token: "token",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  ipAddress: "ipAddress",
  userAgent: "userAgent",
  userId: "userId",
  impersonatedBy: "impersonatedBy",
} as const;

export type SessionScalarFieldEnum =
  (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum];

export const AccountScalarFieldEnum = {
  id: "id",
  accountId: "accountId",
  providerId: "providerId",
  userId: "userId",
  accessToken: "accessToken",
  refreshToken: "refreshToken",
  idToken: "idToken",
  accessTokenExpiresAt: "accessTokenExpiresAt",
  refreshTokenExpiresAt: "refreshTokenExpiresAt",
  scope: "scope",
  password: "password",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type AccountScalarFieldEnum =
  (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum];

export const VerificationScalarFieldEnum = {
  id: "id",
  identifier: "identifier",
  value: "value",
  expiresAt: "expiresAt",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type VerificationScalarFieldEnum =
  (typeof VerificationScalarFieldEnum)[keyof typeof VerificationScalarFieldEnum];

export const ApikeyScalarFieldEnum = {
  id: "id",
  name: "name",
  start: "start",
  prefix: "prefix",
  key: "key",
  userId: "userId",
  refillInterval: "refillInterval",
  refillAmount: "refillAmount",
  lastRefillAt: "lastRefillAt",
  enabled: "enabled",
  rateLimitEnabled: "rateLimitEnabled",
  rateLimitTimeWindow: "rateLimitTimeWindow",
  rateLimitMax: "rateLimitMax",
  requestCount: "requestCount",
  remaining: "remaining",
  lastRequest: "lastRequest",
  expiresAt: "expiresAt",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  permissions: "permissions",
  metadata: "metadata",
} as const;

export type ApikeyScalarFieldEnum =
  (typeof ApikeyScalarFieldEnum)[keyof typeof ApikeyScalarFieldEnum];

export const UserNotificationScalarFieldEnum = {
  id: "id",
  userId: "userId",
  title: "title",
  message: "message",
  schoolYearId: "schoolYearId",
  read: "read",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type UserNotificationScalarFieldEnum =
  (typeof UserNotificationScalarFieldEnum)[keyof typeof UserNotificationScalarFieldEnum];

export const AppreciationRuleSetScalarFieldEnum = {
  id: "id",
  name: "name",
  scale: "scale",
} as const;

export type AppreciationRuleSetScalarFieldEnum =
  (typeof AppreciationRuleSetScalarFieldEnum)[keyof typeof AppreciationRuleSetScalarFieldEnum];

export const AppreciationRuleScalarFieldEnum = {
  id: "id",
  appreciationRuleSetId: "appreciationRuleSetId",
  minGrade: "minGrade",
  maxGrade: "maxGrade",
  label: "label",
  order: "order",
} as const;

export type AppreciationRuleScalarFieldEnum =
  (typeof AppreciationRuleScalarFieldEnum)[keyof typeof AppreciationRuleScalarFieldEnum];

export const ScheduleDivisionScalarFieldEnum = {
  id: "id",
  name: "name",
  startTime: "startTime",
  endTime: "endTime",
  monday: "monday",
  tuesday: "tuesday",
  wednesday: "wednesday",
  thursday: "thursday",
  friday: "friday",
  saturday: "saturday",
  sunday: "sunday",
  schoolYearId: "schoolYearId",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type ScheduleDivisionScalarFieldEnum =
  (typeof ScheduleDivisionScalarFieldEnum)[keyof typeof ScheduleDivisionScalarFieldEnum];

export const SortOrder = {
  asc: "asc",
  desc: "desc",
} as const;

export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder];

export const JsonNullValueInput = {
  JsonNull: JsonNull,
} as const;

export type JsonNullValueInput =
  (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput];

export const NullableJsonNullValueInput = {
  DbNull: DbNull,
  JsonNull: JsonNull,
} as const;

export type NullableJsonNullValueInput =
  (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput];

export const QueryMode = {
  default: "default",
  insensitive: "insensitive",
} as const;

export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode];

export const JsonNullValueFilter = {
  DbNull: DbNull,
  JsonNull: JsonNull,
  AnyNull: AnyNull,
} as const;

export type JsonNullValueFilter =
  (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter];

export const NullsOrder = {
  first: "first",
  last: "last",
} as const;

export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder];

/**
 * Field references
 */

/**
 * Reference to a field of type 'String'
 */
export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "String"
>;

/**
 * Reference to a field of type 'String[]'
 */
export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "String[]"
>;

/**
 * Reference to a field of type 'DateTime'
 */
export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "DateTime"
>;

/**
 * Reference to a field of type 'DateTime[]'
 */
export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "DateTime[]"
>;

/**
 * Reference to a field of type 'VisibilityType'
 */
export type EnumVisibilityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "VisibilityType"
>;

/**
 * Reference to a field of type 'VisibilityType[]'
 */
export type ListEnumVisibilityTypeFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "VisibilityType[]">;

/**
 * Reference to a field of type 'Json'
 */
export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "Json"
>;

/**
 * Reference to a field of type 'QueryMode'
 */
export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "QueryMode"
>;

/**
 * Reference to a field of type 'Boolean'
 */
export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "Boolean"
>;

/**
 * Reference to a field of type 'DocumentKind'
 */
export type EnumDocumentKindFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "DocumentKind"
>;

/**
 * Reference to a field of type 'DocumentKind[]'
 */
export type ListEnumDocumentKindFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "DocumentKind[]"
>;

/**
 * Reference to a field of type 'Int'
 */
export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "Int"
>;

/**
 * Reference to a field of type 'Int[]'
 */
export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "Int[]"
>;

/**
 * Reference to a field of type 'InventoryAssignmentStatus'
 */
export type EnumInventoryAssignmentStatusFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "InventoryAssignmentStatus">;

/**
 * Reference to a field of type 'InventoryAssignmentStatus[]'
 */
export type ListEnumInventoryAssignmentStatusFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "InventoryAssignmentStatus[]">;

/**
 * Reference to a field of type 'InventoryMovementType'
 */
export type EnumInventoryMovementTypeFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "InventoryMovementType">;

/**
 * Reference to a field of type 'InventoryMovementType[]'
 */
export type ListEnumInventoryMovementTypeFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "InventoryMovementType[]">;

/**
 * Reference to a field of type 'CommunicationChannelType'
 */
export type EnumCommunicationChannelTypeFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "CommunicationChannelType">;

/**
 * Reference to a field of type 'CommunicationChannelType[]'
 */
export type ListEnumCommunicationChannelTypeFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "CommunicationChannelType[]">;

/**
 * Reference to a field of type 'PolicyEffect'
 */
export type EnumPolicyEffectFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "PolicyEffect"
>;

/**
 * Reference to a field of type 'PolicyEffect[]'
 */
export type ListEnumPolicyEffectFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "PolicyEffect[]"
>;

/**
 * Reference to a field of type 'StatusEnum'
 */
export type EnumStatusEnumFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "StatusEnum"
>;

/**
 * Reference to a field of type 'StatusEnum[]'
 */
export type ListEnumStatusEnumFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "StatusEnum[]"
>;

/**
 * Reference to a field of type 'Float'
 */
export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "Float"
>;

/**
 * Reference to a field of type 'Float[]'
 */
export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "Float[]"
>;

/**
 * Reference to a field of type 'Gender'
 */
export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "Gender"
>;

/**
 * Reference to a field of type 'Gender[]'
 */
export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "Gender[]"
>;

/**
 * Reference to a field of type 'StudentStatus'
 */
export type EnumStudentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "StudentStatus"
>;

/**
 * Reference to a field of type 'StudentStatus[]'
 */
export type ListEnumStudentStatusFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "StudentStatus[]">;

/**
 * Reference to a field of type 'ApplyRequiredFee'
 */
export type EnumApplyRequiredFeeFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "ApplyRequiredFee"
>;

/**
 * Reference to a field of type 'ApplyRequiredFee[]'
 */
export type ListEnumApplyRequiredFeeFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "ApplyRequiredFee[]">;

/**
 * Reference to a field of type 'TokenType'
 */
export type EnumTokenTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "TokenType"
>;

/**
 * Reference to a field of type 'TokenType[]'
 */
export type ListEnumTokenTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "TokenType[]"
>;

/**
 * Reference to a field of type 'TransactionType'
 */
export type EnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "TransactionType"
>;

/**
 * Reference to a field of type 'TransactionType[]'
 */
export type ListEnumTransactionTypeFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "TransactionType[]">;

/**
 * Reference to a field of type 'TransactionStatus'
 */
export type EnumTransactionStatusFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "TransactionStatus">;

/**
 * Reference to a field of type 'TransactionStatus[]'
 */
export type ListEnumTransactionStatusFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "TransactionStatus[]">;

/**
 * Reference to a field of type 'NotificationChannel[]'
 */
export type ListEnumNotificationChannelFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "NotificationChannel[]">;

/**
 * Reference to a field of type 'NotificationChannel'
 */
export type EnumNotificationChannelFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "NotificationChannel">;

/**
 * Batch Payload for updateMany & deleteMany & createMany
 */
export type BatchPayload = {
  count: number;
};

export type Datasource = {
  url?: string;
};
export type Datasources = {
  db?: Datasource;
};

export const defineExtension = runtime.Extensions
  .defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<
  "define",
  TypeMapCb,
  runtime.Types.Extensions.DefaultArgs
>;
export type DefaultPrismaClient = PrismaClient;
export type ErrorFormat = "pretty" | "colorless" | "minimal";
export interface PrismaClientOptions {
  /**
   * Overwrites the datasource url from your schema.prisma file
   */
  datasources?: Datasources;
  /**
   * Overwrites the datasource url from your schema.prisma file
   */
  datasourceUrl?: string;
  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat;
  /**
   * @example
   * ```
   * // Shorthand for `emit: 'stdout'`
   * log: ['query', 'info', 'warn', 'error']
   *
   * // Emit as events only
   * log: [
   *   { emit: 'event', level: 'query' },
   *   { emit: 'event', level: 'info' },
   *   { emit: 'event', level: 'warn' }
   *   { emit: 'event', level: 'error' }
   * ]
   *
   * / Emit as events and log to stdout
   * og: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   *
   * ```
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
   */
  log?: (LogLevel | LogDefinition)[];
  /**
   * The default values for transactionOptions
   * maxWait ?= 2000
   * timeout ?= 5000
   */
  transactionOptions?: {
    maxWait?: number;
    timeout?: number;
    isolationLevel?: TransactionIsolationLevel;
  };
  /**
   * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
   */
  adapter?: runtime.SqlDriverAdapterFactory | null;
  /**
   * Global configuration for omitting model fields by default.
   *
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   omit: {
   *     user: {
   *       password: true
   *     }
   *   }
   * })
   * ```
   */
  omit?: GlobalOmitConfig;
}
export type GlobalOmitConfig = {
  aiChat?: Prisma.AiChatOmit;
  aiMessage?: Prisma.AiMessageOmit;
  vote?: Prisma.VoteOmit;
  aiDocument?: Prisma.AiDocumentOmit;
  aiSuggestion?: Prisma.AiSuggestionOmit;
  stream?: Prisma.StreamOmit;
  absence?: Prisma.AbsenceOmit;
  absenceJustification?: Prisma.AbsenceJustificationOmit;
  lateness?: Prisma.LatenessOmit;
  latenessJustification?: Prisma.LatenessJustificationOmit;
  chatter?: Prisma.ChatterOmit;
  consigne?: Prisma.ConsigneOmit;
  exclusion?: Prisma.ExclusionOmit;
  preventedAbsence?: Prisma.PreventedAbsenceOmit;
  convocation?: Prisma.ConvocationOmit;
  timetableCategory?: Prisma.TimetableCategoryOmit;
  subjectTimetable?: Prisma.SubjectTimetableOmit;
  periodicAttendance?: Prisma.PeriodicAttendanceOmit;
  bibleText?: Prisma.BibleTextOmit;
  inventoryAsset?: Prisma.InventoryAssetOmit;
  inventoryConsumable?: Prisma.InventoryConsumableOmit;
  inventoryAssetUsage?: Prisma.InventoryAssetUsageOmit;
  inventoryConsumableUsage?: Prisma.InventoryConsumableUsageOmit;
  inventoryUnit?: Prisma.InventoryUnitOmit;
  inventoryStockMovement?: Prisma.InventoryStockMovementOmit;
  book?: Prisma.BookOmit;
  bookCategory?: Prisma.BookCategoryOmit;
  borrowedBook?: Prisma.BorrowedBookOmit;
  shortcut?: Prisma.ShortcutOmit;
  email?: Prisma.EmailOmit;
  emailRecipient?: Prisma.EmailRecipientOmit;
  attachment?: Prisma.AttachmentOmit;
  communicationChannel?: Prisma.CommunicationChannelOmit;
  recipientGroup?: Prisma.RecipientGroupOmit;
  feedback?: Prisma.FeedbackOmit;
  recipient?: Prisma.RecipientOmit;
  announcement?: Prisma.AnnouncementOmit;
  policy?: Prisma.PolicyOmit;
  appreciation?: Prisma.AppreciationOmit;
  reportCard?: Prisma.ReportCardOmit;
  report?: Prisma.ReportOmit;
  healthVisit?: Prisma.HealthVisitOmit;
  classroom?: Prisma.ClassroomOmit;
  enrollment?: Prisma.EnrollmentOmit;
  reporting?: Prisma.ReportingOmit;
  classroomLevel?: Prisma.ClassroomLevelOmit;
  calendarType?: Prisma.CalendarTypeOmit;
  calendarEvent?: Prisma.CalendarEventOmit;
  gradeSheet?: Prisma.GradeSheetOmit;
  grade?: Prisma.GradeOmit;
  assignmentCategory?: Prisma.AssignmentCategoryOmit;
  appreciationCategory?: Prisma.AppreciationCategoryOmit;
  assignment?: Prisma.AssignmentOmit;
  event?: Prisma.EventOmit;
  term?: Prisma.TermOmit;
  contactRelationship?: Prisma.ContactRelationshipOmit;
  staffDegree?: Prisma.StaffDegreeOmit;
  staff?: Prisma.StaffOmit;
  document?: Prisma.DocumentOmit;
  student?: Prisma.StudentOmit;
  studentSibling?: Prisma.StudentSiblingOmit;
  requiredFeeTransaction?: Prisma.RequiredFeeTransactionOmit;
  fee?: Prisma.FeeOmit;
  studentContact?: Prisma.StudentContactOmit;
  contact?: Prisma.ContactOmit;
  country?: Prisma.CountryOmit;
  school?: Prisma.SchoolOmit;
  requiredAccountingJournal?: Prisma.RequiredAccountingJournalOmit;
  formerSchool?: Prisma.FormerSchoolOmit;
  subject?: Prisma.SubjectOmit;
  subjectGroup?: Prisma.SubjectGroupOmit;
  course?: Prisma.CourseOmit;
  schoolYear?: Prisma.SchoolYearOmit;
  classroomCycle?: Prisma.ClassroomCycleOmit;
  classroomSection?: Prisma.ClassroomSectionOmit;
  userRole?: Prisma.UserRoleOmit;
  token?: Prisma.TokenOmit;
  menuItem?: Prisma.MenuItemOmit;
  programCategory?: Prisma.ProgramCategoryOmit;
  program?: Prisma.ProgramOmit;
  teachingSessionProgram?: Prisma.TeachingSessionProgramOmit;
  teachingSession?: Prisma.TeachingSessionOmit;
  sMSTemplate?: Prisma.SMSTemplateOmit;
  sMSHistory?: Prisma.SMSHistoryOmit;
  sMSHistoryDetail?: Prisma.SMSHistoryDetailOmit;
  photo?: Prisma.PhotoOmit;
  reportQueue?: Prisma.ReportQueueOmit;
  religion?: Prisma.ReligionOmit;
  club?: Prisma.ClubOmit;
  studentClub?: Prisma.StudentClubOmit;
  studentSport?: Prisma.StudentSportOmit;
  invite?: Prisma.InviteOmit;
  sport?: Prisma.SportOmit;
  transaction?: Prisma.TransactionOmit;
  accountingJournal?: Prisma.AccountingJournalOmit;
  scheduleTask?: Prisma.ScheduleTaskOmit;
  gradeAppreciation?: Prisma.GradeAppreciationOmit;
  classroomGradeAppreciation?: Prisma.ClassroomGradeAppreciationOmit;
  healthRecord?: Prisma.HealthRecordOmit;
  healthDrug?: Prisma.HealthDrugOmit;
  user?: Prisma.UserOmit;
  role?: Prisma.RoleOmit;
  rolePolicy?: Prisma.RolePolicyOmit;
  userPolicy?: Prisma.UserPolicyOmit;
  notificationPreference?: Prisma.NotificationPreferenceOmit;
  subscription?: Prisma.SubscriptionOmit;
  logActivity?: Prisma.LogActivityOmit;
  schoolYearEvent?: Prisma.SchoolYearEventOmit;
  schoolYearEventType?: Prisma.SchoolYearEventTypeOmit;
  session?: Prisma.SessionOmit;
  account?: Prisma.AccountOmit;
  verification?: Prisma.VerificationOmit;
  apikey?: Prisma.ApikeyOmit;
  userNotification?: Prisma.UserNotificationOmit;
  appreciationRuleSet?: Prisma.AppreciationRuleSetOmit;
  appreciationRule?: Prisma.AppreciationRuleOmit;
  scheduleDivision?: Prisma.ScheduleDivisionOmit;
};

/* Types for Logging */
export type LogLevel = "info" | "query" | "warn" | "error";
export type LogDefinition = {
  level: LogLevel;
  emit: "stdout" | "event";
};

export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

export type GetLogType<T> = CheckIsLogLevel<
  T extends LogDefinition ? T["level"] : T
>;

export type GetEvents<T extends any[]> =
  T extends Array<LogLevel | LogDefinition> ? GetLogType<T[number]> : never;

export type QueryEvent = {
  timestamp: Date;
  query: string;
  params: string;
  duration: number;
  target: string;
};

export type LogEvent = {
  timestamp: Date;
  message: string;
  target: string;
};
/* End Types for Logging */

export type PrismaAction =
  | "findUnique"
  | "findUniqueOrThrow"
  | "findMany"
  | "findFirst"
  | "findFirstOrThrow"
  | "create"
  | "createMany"
  | "createManyAndReturn"
  | "update"
  | "updateMany"
  | "updateManyAndReturn"
  | "upsert"
  | "delete"
  | "deleteMany"
  | "executeRaw"
  | "queryRaw"
  | "aggregate"
  | "count"
  | "runCommandRaw"
  | "findRaw"
  | "groupBy";

/**
 * `PrismaClient` proxy available in interactive transactions.
 */
export type TransactionClient = Omit<
  DefaultPrismaClient,
  runtime.ITXClientDenyList
>;
