/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// @ts-nocheck
/*
 * This file exports the `AiChat` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client";

import type * as $Enums from "../enums";
import type * as Prisma from "../internal/prismaNamespace";

/**
 * Model AiChat
 *
 */
export type AiChatModel =
  runtime.Types.Result.DefaultSelection<Prisma.$AiChatPayload>;

export type AggregateAiChat = {
  _count: AiChatCountAggregateOutputType | null;
  _min: AiChatMinAggregateOutputType | null;
  _max: AiChatMaxAggregateOutputType | null;
};

export type AiChatMinAggregateOutputType = {
  id: string | null;
  createdAt: Date | null;
  title: string | null;
  userId: string | null;
  visibility: $Enums.VisibilityType | null;
};

export type AiChatMaxAggregateOutputType = {
  id: string | null;
  createdAt: Date | null;
  title: string | null;
  userId: string | null;
  visibility: $Enums.VisibilityType | null;
};

export type AiChatCountAggregateOutputType = {
  id: number;
  createdAt: number;
  title: number;
  userId: number;
  visibility: number;
  _all: number;
};

export type AiChatMinAggregateInputType = {
  id?: true;
  createdAt?: true;
  title?: true;
  userId?: true;
  visibility?: true;
};

export type AiChatMaxAggregateInputType = {
  id?: true;
  createdAt?: true;
  title?: true;
  userId?: true;
  visibility?: true;
};

export type AiChatCountAggregateInputType = {
  id?: true;
  createdAt?: true;
  title?: true;
  userId?: true;
  visibility?: true;
  _all?: true;
};

export type AiChatAggregateArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Filter which AiChat to aggregate.
   */
  where?: Prisma.AiChatWhereInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   *
   * Determine the order of AiChats to fetch.
   */
  orderBy?:
    | Prisma.AiChatOrderByWithRelationInput
    | Prisma.AiChatOrderByWithRelationInput[];
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   *
   * Sets the start position
   */
  cursor?: Prisma.AiChatWhereUniqueInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Take `Â±n` AiChats from the position of the cursor.
   */
  take?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Skip the first `n` AiChats.
   */
  skip?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   *
   * Count returned AiChats
   **/
  _count?: true | AiChatCountAggregateInputType;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   *
   * Select which fields to find the minimum value
   **/
  _min?: AiChatMinAggregateInputType;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   *
   * Select which fields to find the maximum value
   **/
  _max?: AiChatMaxAggregateInputType;
};

export type GetAiChatAggregateType<T extends AiChatAggregateArgs> = {
  [P in keyof T & keyof AggregateAiChat]: P extends "_count" | "count"
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateAiChat[P]>
    : Prisma.GetScalarType<T[P], AggregateAiChat[P]>;
};

export type AiChatGroupByArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  where?: Prisma.AiChatWhereInput;
  orderBy?:
    | Prisma.AiChatOrderByWithAggregationInput
    | Prisma.AiChatOrderByWithAggregationInput[];
  by: Prisma.AiChatScalarFieldEnum[] | Prisma.AiChatScalarFieldEnum;
  having?: Prisma.AiChatScalarWhereWithAggregatesInput;
  take?: number;
  skip?: number;
  _count?: AiChatCountAggregateInputType | true;
  _min?: AiChatMinAggregateInputType;
  _max?: AiChatMaxAggregateInputType;
};

export type AiChatGroupByOutputType = {
  id: string;
  createdAt: Date;
  title: string;
  userId: string;
  visibility: $Enums.VisibilityType;
  _count: AiChatCountAggregateOutputType | null;
  _min: AiChatMinAggregateOutputType | null;
  _max: AiChatMaxAggregateOutputType | null;
};

type GetAiChatGroupByPayload<T extends AiChatGroupByArgs> =
  Prisma.PrismaPromise<
    Array<
      Prisma.PickEnumerable<AiChatGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof AiChatGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], AiChatGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], AiChatGroupByOutputType[P]>;
      }
    >
  >;

export type AiChatWhereInput = {
  AND?: Prisma.AiChatWhereInput | Prisma.AiChatWhereInput[];
  OR?: Prisma.AiChatWhereInput[];
  NOT?: Prisma.AiChatWhereInput | Prisma.AiChatWhereInput[];
  id?: Prisma.StringFilter<"AiChat"> | string;
  createdAt?: Prisma.DateTimeFilter<"AiChat"> | Date | string;
  title?: Prisma.StringFilter<"AiChat"> | string;
  userId?: Prisma.StringFilter<"AiChat"> | string;
  visibility?:
    | Prisma.EnumVisibilityTypeFilter<"AiChat">
    | $Enums.VisibilityType;
  user?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>;
  messages?: Prisma.AiMessageListRelationFilter;
  votes?: Prisma.VoteListRelationFilter;
  streams?: Prisma.StreamListRelationFilter;
};

export type AiChatOrderByWithRelationInput = {
  id?: Prisma.SortOrder;
  createdAt?: Prisma.SortOrder;
  title?: Prisma.SortOrder;
  userId?: Prisma.SortOrder;
  visibility?: Prisma.SortOrder;
  user?: Prisma.UserOrderByWithRelationInput;
  messages?: Prisma.AiMessageOrderByRelationAggregateInput;
  votes?: Prisma.VoteOrderByRelationAggregateInput;
  streams?: Prisma.StreamOrderByRelationAggregateInput;
};

export type AiChatWhereUniqueInput = Prisma.AtLeast<
  {
    id?: string;
    AND?: Prisma.AiChatWhereInput | Prisma.AiChatWhereInput[];
    OR?: Prisma.AiChatWhereInput[];
    NOT?: Prisma.AiChatWhereInput | Prisma.AiChatWhereInput[];
    createdAt?: Prisma.DateTimeFilter<"AiChat"> | Date | string;
    title?: Prisma.StringFilter<"AiChat"> | string;
    userId?: Prisma.StringFilter<"AiChat"> | string;
    visibility?:
      | Prisma.EnumVisibilityTypeFilter<"AiChat">
      | $Enums.VisibilityType;
    user?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>;
    messages?: Prisma.AiMessageListRelationFilter;
    votes?: Prisma.VoteListRelationFilter;
    streams?: Prisma.StreamListRelationFilter;
  },
  "id"
>;

export type AiChatOrderByWithAggregationInput = {
  id?: Prisma.SortOrder;
  createdAt?: Prisma.SortOrder;
  title?: Prisma.SortOrder;
  userId?: Prisma.SortOrder;
  visibility?: Prisma.SortOrder;
  _count?: Prisma.AiChatCountOrderByAggregateInput;
  _max?: Prisma.AiChatMaxOrderByAggregateInput;
  _min?: Prisma.AiChatMinOrderByAggregateInput;
};

export type AiChatScalarWhereWithAggregatesInput = {
  AND?:
    | Prisma.AiChatScalarWhereWithAggregatesInput
    | Prisma.AiChatScalarWhereWithAggregatesInput[];
  OR?: Prisma.AiChatScalarWhereWithAggregatesInput[];
  NOT?:
    | Prisma.AiChatScalarWhereWithAggregatesInput
    | Prisma.AiChatScalarWhereWithAggregatesInput[];
  id?: Prisma.StringWithAggregatesFilter<"AiChat"> | string;
  createdAt?: Prisma.DateTimeWithAggregatesFilter<"AiChat"> | Date | string;
  title?: Prisma.StringWithAggregatesFilter<"AiChat"> | string;
  userId?: Prisma.StringWithAggregatesFilter<"AiChat"> | string;
  visibility?:
    | Prisma.EnumVisibilityTypeWithAggregatesFilter<"AiChat">
    | $Enums.VisibilityType;
};

export type AiChatCreateInput = {
  id?: string;
  createdAt?: Date | string;
  title: string;
  visibility?: $Enums.VisibilityType;
  user: Prisma.UserCreateNestedOneWithoutChatsInput;
  messages?: Prisma.AiMessageCreateNestedManyWithoutChatInput;
  votes?: Prisma.VoteCreateNestedManyWithoutChatInput;
  streams?: Prisma.StreamCreateNestedManyWithoutChatInput;
};

export type AiChatUncheckedCreateInput = {
  id?: string;
  createdAt?: Date | string;
  title: string;
  userId: string;
  visibility?: $Enums.VisibilityType;
  messages?: Prisma.AiMessageUncheckedCreateNestedManyWithoutChatInput;
  votes?: Prisma.VoteUncheckedCreateNestedManyWithoutChatInput;
  streams?: Prisma.StreamUncheckedCreateNestedManyWithoutChatInput;
};

export type AiChatUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  title?: Prisma.StringFieldUpdateOperationsInput | string;
  visibility?:
    | Prisma.EnumVisibilityTypeFieldUpdateOperationsInput
    | $Enums.VisibilityType;
  user?: Prisma.UserUpdateOneRequiredWithoutChatsNestedInput;
  messages?: Prisma.AiMessageUpdateManyWithoutChatNestedInput;
  votes?: Prisma.VoteUpdateManyWithoutChatNestedInput;
  streams?: Prisma.StreamUpdateManyWithoutChatNestedInput;
};

export type AiChatUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  title?: Prisma.StringFieldUpdateOperationsInput | string;
  userId?: Prisma.StringFieldUpdateOperationsInput | string;
  visibility?:
    | Prisma.EnumVisibilityTypeFieldUpdateOperationsInput
    | $Enums.VisibilityType;
  messages?: Prisma.AiMessageUncheckedUpdateManyWithoutChatNestedInput;
  votes?: Prisma.VoteUncheckedUpdateManyWithoutChatNestedInput;
  streams?: Prisma.StreamUncheckedUpdateManyWithoutChatNestedInput;
};

export type AiChatCreateManyInput = {
  id?: string;
  createdAt?: Date | string;
  title: string;
  userId: string;
  visibility?: $Enums.VisibilityType;
};

export type AiChatUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  title?: Prisma.StringFieldUpdateOperationsInput | string;
  visibility?:
    | Prisma.EnumVisibilityTypeFieldUpdateOperationsInput
    | $Enums.VisibilityType;
};

export type AiChatUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  title?: Prisma.StringFieldUpdateOperationsInput | string;
  userId?: Prisma.StringFieldUpdateOperationsInput | string;
  visibility?:
    | Prisma.EnumVisibilityTypeFieldUpdateOperationsInput
    | $Enums.VisibilityType;
};

export type AiChatCountOrderByAggregateInput = {
  id?: Prisma.SortOrder;
  createdAt?: Prisma.SortOrder;
  title?: Prisma.SortOrder;
  userId?: Prisma.SortOrder;
  visibility?: Prisma.SortOrder;
};

export type AiChatMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder;
  createdAt?: Prisma.SortOrder;
  title?: Prisma.SortOrder;
  userId?: Prisma.SortOrder;
  visibility?: Prisma.SortOrder;
};

export type AiChatMinOrderByAggregateInput = {
  id?: Prisma.SortOrder;
  createdAt?: Prisma.SortOrder;
  title?: Prisma.SortOrder;
  userId?: Prisma.SortOrder;
  visibility?: Prisma.SortOrder;
};

export type AiChatScalarRelationFilter = {
  is?: Prisma.AiChatWhereInput;
  isNot?: Prisma.AiChatWhereInput;
};

export type AiChatListRelationFilter = {
  every?: Prisma.AiChatWhereInput;
  some?: Prisma.AiChatWhereInput;
  none?: Prisma.AiChatWhereInput;
};

export type AiChatOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder;
};

export type StringFieldUpdateOperationsInput = {
  set?: string;
};

export type DateTimeFieldUpdateOperationsInput = {
  set?: Date | string;
};

export type EnumVisibilityTypeFieldUpdateOperationsInput = {
  set?: $Enums.VisibilityType;
};

export type AiChatCreateNestedOneWithoutMessagesInput = {
  create?: Prisma.XOR<
    Prisma.AiChatCreateWithoutMessagesInput,
    Prisma.AiChatUncheckedCreateWithoutMessagesInput
  >;
  connectOrCreate?: Prisma.AiChatCreateOrConnectWithoutMessagesInput;
  connect?: Prisma.AiChatWhereUniqueInput;
};

export type AiChatUpdateOneRequiredWithoutMessagesNestedInput = {
  create?: Prisma.XOR<
    Prisma.AiChatCreateWithoutMessagesInput,
    Prisma.AiChatUncheckedCreateWithoutMessagesInput
  >;
  connectOrCreate?: Prisma.AiChatCreateOrConnectWithoutMessagesInput;
  upsert?: Prisma.AiChatUpsertWithoutMessagesInput;
  connect?: Prisma.AiChatWhereUniqueInput;
  update?: Prisma.XOR<
    Prisma.XOR<
      Prisma.AiChatUpdateToOneWithWhereWithoutMessagesInput,
      Prisma.AiChatUpdateWithoutMessagesInput
    >,
    Prisma.AiChatUncheckedUpdateWithoutMessagesInput
  >;
};

export type AiChatCreateNestedOneWithoutVotesInput = {
  create?: Prisma.XOR<
    Prisma.AiChatCreateWithoutVotesInput,
    Prisma.AiChatUncheckedCreateWithoutVotesInput
  >;
  connectOrCreate?: Prisma.AiChatCreateOrConnectWithoutVotesInput;
  connect?: Prisma.AiChatWhereUniqueInput;
};

export type AiChatUpdateOneRequiredWithoutVotesNestedInput = {
  create?: Prisma.XOR<
    Prisma.AiChatCreateWithoutVotesInput,
    Prisma.AiChatUncheckedCreateWithoutVotesInput
  >;
  connectOrCreate?: Prisma.AiChatCreateOrConnectWithoutVotesInput;
  upsert?: Prisma.AiChatUpsertWithoutVotesInput;
  connect?: Prisma.AiChatWhereUniqueInput;
  update?: Prisma.XOR<
    Prisma.XOR<
      Prisma.AiChatUpdateToOneWithWhereWithoutVotesInput,
      Prisma.AiChatUpdateWithoutVotesInput
    >,
    Prisma.AiChatUncheckedUpdateWithoutVotesInput
  >;
};

export type AiChatCreateNestedOneWithoutStreamsInput = {
  create?: Prisma.XOR<
    Prisma.AiChatCreateWithoutStreamsInput,
    Prisma.AiChatUncheckedCreateWithoutStreamsInput
  >;
  connectOrCreate?: Prisma.AiChatCreateOrConnectWithoutStreamsInput;
  connect?: Prisma.AiChatWhereUniqueInput;
};

export type AiChatUpdateOneRequiredWithoutStreamsNestedInput = {
  create?: Prisma.XOR<
    Prisma.AiChatCreateWithoutStreamsInput,
    Prisma.AiChatUncheckedCreateWithoutStreamsInput
  >;
  connectOrCreate?: Prisma.AiChatCreateOrConnectWithoutStreamsInput;
  upsert?: Prisma.AiChatUpsertWithoutStreamsInput;
  connect?: Prisma.AiChatWhereUniqueInput;
  update?: Prisma.XOR<
    Prisma.XOR<
      Prisma.AiChatUpdateToOneWithWhereWithoutStreamsInput,
      Prisma.AiChatUpdateWithoutStreamsInput
    >,
    Prisma.AiChatUncheckedUpdateWithoutStreamsInput
  >;
};

export type AiChatCreateNestedManyWithoutUserInput = {
  create?:
    | Prisma.XOR<
        Prisma.AiChatCreateWithoutUserInput,
        Prisma.AiChatUncheckedCreateWithoutUserInput
      >
    | Prisma.AiChatCreateWithoutUserInput[]
    | Prisma.AiChatUncheckedCreateWithoutUserInput[];
  connectOrCreate?:
    | Prisma.AiChatCreateOrConnectWithoutUserInput
    | Prisma.AiChatCreateOrConnectWithoutUserInput[];
  createMany?: Prisma.AiChatCreateManyUserInputEnvelope;
  connect?: Prisma.AiChatWhereUniqueInput | Prisma.AiChatWhereUniqueInput[];
};

export type AiChatUncheckedCreateNestedManyWithoutUserInput = {
  create?:
    | Prisma.XOR<
        Prisma.AiChatCreateWithoutUserInput,
        Prisma.AiChatUncheckedCreateWithoutUserInput
      >
    | Prisma.AiChatCreateWithoutUserInput[]
    | Prisma.AiChatUncheckedCreateWithoutUserInput[];
  connectOrCreate?:
    | Prisma.AiChatCreateOrConnectWithoutUserInput
    | Prisma.AiChatCreateOrConnectWithoutUserInput[];
  createMany?: Prisma.AiChatCreateManyUserInputEnvelope;
  connect?: Prisma.AiChatWhereUniqueInput | Prisma.AiChatWhereUniqueInput[];
};

export type AiChatUpdateManyWithoutUserNestedInput = {
  create?:
    | Prisma.XOR<
        Prisma.AiChatCreateWithoutUserInput,
        Prisma.AiChatUncheckedCreateWithoutUserInput
      >
    | Prisma.AiChatCreateWithoutUserInput[]
    | Prisma.AiChatUncheckedCreateWithoutUserInput[];
  connectOrCreate?:
    | Prisma.AiChatCreateOrConnectWithoutUserInput
    | Prisma.AiChatCreateOrConnectWithoutUserInput[];
  upsert?:
    | Prisma.AiChatUpsertWithWhereUniqueWithoutUserInput
    | Prisma.AiChatUpsertWithWhereUniqueWithoutUserInput[];
  createMany?: Prisma.AiChatCreateManyUserInputEnvelope;
  set?: Prisma.AiChatWhereUniqueInput | Prisma.AiChatWhereUniqueInput[];
  disconnect?: Prisma.AiChatWhereUniqueInput | Prisma.AiChatWhereUniqueInput[];
  delete?: Prisma.AiChatWhereUniqueInput | Prisma.AiChatWhereUniqueInput[];
  connect?: Prisma.AiChatWhereUniqueInput | Prisma.AiChatWhereUniqueInput[];
  update?:
    | Prisma.AiChatUpdateWithWhereUniqueWithoutUserInput
    | Prisma.AiChatUpdateWithWhereUniqueWithoutUserInput[];
  updateMany?:
    | Prisma.AiChatUpdateManyWithWhereWithoutUserInput
    | Prisma.AiChatUpdateManyWithWhereWithoutUserInput[];
  deleteMany?: Prisma.AiChatScalarWhereInput | Prisma.AiChatScalarWhereInput[];
};

export type AiChatUncheckedUpdateManyWithoutUserNestedInput = {
  create?:
    | Prisma.XOR<
        Prisma.AiChatCreateWithoutUserInput,
        Prisma.AiChatUncheckedCreateWithoutUserInput
      >
    | Prisma.AiChatCreateWithoutUserInput[]
    | Prisma.AiChatUncheckedCreateWithoutUserInput[];
  connectOrCreate?:
    | Prisma.AiChatCreateOrConnectWithoutUserInput
    | Prisma.AiChatCreateOrConnectWithoutUserInput[];
  upsert?:
    | Prisma.AiChatUpsertWithWhereUniqueWithoutUserInput
    | Prisma.AiChatUpsertWithWhereUniqueWithoutUserInput[];
  createMany?: Prisma.AiChatCreateManyUserInputEnvelope;
  set?: Prisma.AiChatWhereUniqueInput | Prisma.AiChatWhereUniqueInput[];
  disconnect?: Prisma.AiChatWhereUniqueInput | Prisma.AiChatWhereUniqueInput[];
  delete?: Prisma.AiChatWhereUniqueInput | Prisma.AiChatWhereUniqueInput[];
  connect?: Prisma.AiChatWhereUniqueInput | Prisma.AiChatWhereUniqueInput[];
  update?:
    | Prisma.AiChatUpdateWithWhereUniqueWithoutUserInput
    | Prisma.AiChatUpdateWithWhereUniqueWithoutUserInput[];
  updateMany?:
    | Prisma.AiChatUpdateManyWithWhereWithoutUserInput
    | Prisma.AiChatUpdateManyWithWhereWithoutUserInput[];
  deleteMany?: Prisma.AiChatScalarWhereInput | Prisma.AiChatScalarWhereInput[];
};

export type AiChatCreateWithoutMessagesInput = {
  id?: string;
  createdAt?: Date | string;
  title: string;
  visibility?: $Enums.VisibilityType;
  user: Prisma.UserCreateNestedOneWithoutChatsInput;
  votes?: Prisma.VoteCreateNestedManyWithoutChatInput;
  streams?: Prisma.StreamCreateNestedManyWithoutChatInput;
};

export type AiChatUncheckedCreateWithoutMessagesInput = {
  id?: string;
  createdAt?: Date | string;
  title: string;
  userId: string;
  visibility?: $Enums.VisibilityType;
  votes?: Prisma.VoteUncheckedCreateNestedManyWithoutChatInput;
  streams?: Prisma.StreamUncheckedCreateNestedManyWithoutChatInput;
};

export type AiChatCreateOrConnectWithoutMessagesInput = {
  where: Prisma.AiChatWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.AiChatCreateWithoutMessagesInput,
    Prisma.AiChatUncheckedCreateWithoutMessagesInput
  >;
};

export type AiChatUpsertWithoutMessagesInput = {
  update: Prisma.XOR<
    Prisma.AiChatUpdateWithoutMessagesInput,
    Prisma.AiChatUncheckedUpdateWithoutMessagesInput
  >;
  create: Prisma.XOR<
    Prisma.AiChatCreateWithoutMessagesInput,
    Prisma.AiChatUncheckedCreateWithoutMessagesInput
  >;
  where?: Prisma.AiChatWhereInput;
};

export type AiChatUpdateToOneWithWhereWithoutMessagesInput = {
  where?: Prisma.AiChatWhereInput;
  data: Prisma.XOR<
    Prisma.AiChatUpdateWithoutMessagesInput,
    Prisma.AiChatUncheckedUpdateWithoutMessagesInput
  >;
};

export type AiChatUpdateWithoutMessagesInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  title?: Prisma.StringFieldUpdateOperationsInput | string;
  visibility?:
    | Prisma.EnumVisibilityTypeFieldUpdateOperationsInput
    | $Enums.VisibilityType;
  user?: Prisma.UserUpdateOneRequiredWithoutChatsNestedInput;
  votes?: Prisma.VoteUpdateManyWithoutChatNestedInput;
  streams?: Prisma.StreamUpdateManyWithoutChatNestedInput;
};

export type AiChatUncheckedUpdateWithoutMessagesInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  title?: Prisma.StringFieldUpdateOperationsInput | string;
  userId?: Prisma.StringFieldUpdateOperationsInput | string;
  visibility?:
    | Prisma.EnumVisibilityTypeFieldUpdateOperationsInput
    | $Enums.VisibilityType;
  votes?: Prisma.VoteUncheckedUpdateManyWithoutChatNestedInput;
  streams?: Prisma.StreamUncheckedUpdateManyWithoutChatNestedInput;
};

export type AiChatCreateWithoutVotesInput = {
  id?: string;
  createdAt?: Date | string;
  title: string;
  visibility?: $Enums.VisibilityType;
  user: Prisma.UserCreateNestedOneWithoutChatsInput;
  messages?: Prisma.AiMessageCreateNestedManyWithoutChatInput;
  streams?: Prisma.StreamCreateNestedManyWithoutChatInput;
};

export type AiChatUncheckedCreateWithoutVotesInput = {
  id?: string;
  createdAt?: Date | string;
  title: string;
  userId: string;
  visibility?: $Enums.VisibilityType;
  messages?: Prisma.AiMessageUncheckedCreateNestedManyWithoutChatInput;
  streams?: Prisma.StreamUncheckedCreateNestedManyWithoutChatInput;
};

export type AiChatCreateOrConnectWithoutVotesInput = {
  where: Prisma.AiChatWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.AiChatCreateWithoutVotesInput,
    Prisma.AiChatUncheckedCreateWithoutVotesInput
  >;
};

export type AiChatUpsertWithoutVotesInput = {
  update: Prisma.XOR<
    Prisma.AiChatUpdateWithoutVotesInput,
    Prisma.AiChatUncheckedUpdateWithoutVotesInput
  >;
  create: Prisma.XOR<
    Prisma.AiChatCreateWithoutVotesInput,
    Prisma.AiChatUncheckedCreateWithoutVotesInput
  >;
  where?: Prisma.AiChatWhereInput;
};

export type AiChatUpdateToOneWithWhereWithoutVotesInput = {
  where?: Prisma.AiChatWhereInput;
  data: Prisma.XOR<
    Prisma.AiChatUpdateWithoutVotesInput,
    Prisma.AiChatUncheckedUpdateWithoutVotesInput
  >;
};

export type AiChatUpdateWithoutVotesInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  title?: Prisma.StringFieldUpdateOperationsInput | string;
  visibility?:
    | Prisma.EnumVisibilityTypeFieldUpdateOperationsInput
    | $Enums.VisibilityType;
  user?: Prisma.UserUpdateOneRequiredWithoutChatsNestedInput;
  messages?: Prisma.AiMessageUpdateManyWithoutChatNestedInput;
  streams?: Prisma.StreamUpdateManyWithoutChatNestedInput;
};

export type AiChatUncheckedUpdateWithoutVotesInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  title?: Prisma.StringFieldUpdateOperationsInput | string;
  userId?: Prisma.StringFieldUpdateOperationsInput | string;
  visibility?:
    | Prisma.EnumVisibilityTypeFieldUpdateOperationsInput
    | $Enums.VisibilityType;
  messages?: Prisma.AiMessageUncheckedUpdateManyWithoutChatNestedInput;
  streams?: Prisma.StreamUncheckedUpdateManyWithoutChatNestedInput;
};

export type AiChatCreateWithoutStreamsInput = {
  id?: string;
  createdAt?: Date | string;
  title: string;
  visibility?: $Enums.VisibilityType;
  user: Prisma.UserCreateNestedOneWithoutChatsInput;
  messages?: Prisma.AiMessageCreateNestedManyWithoutChatInput;
  votes?: Prisma.VoteCreateNestedManyWithoutChatInput;
};

export type AiChatUncheckedCreateWithoutStreamsInput = {
  id?: string;
  createdAt?: Date | string;
  title: string;
  userId: string;
  visibility?: $Enums.VisibilityType;
  messages?: Prisma.AiMessageUncheckedCreateNestedManyWithoutChatInput;
  votes?: Prisma.VoteUncheckedCreateNestedManyWithoutChatInput;
};

export type AiChatCreateOrConnectWithoutStreamsInput = {
  where: Prisma.AiChatWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.AiChatCreateWithoutStreamsInput,
    Prisma.AiChatUncheckedCreateWithoutStreamsInput
  >;
};

export type AiChatUpsertWithoutStreamsInput = {
  update: Prisma.XOR<
    Prisma.AiChatUpdateWithoutStreamsInput,
    Prisma.AiChatUncheckedUpdateWithoutStreamsInput
  >;
  create: Prisma.XOR<
    Prisma.AiChatCreateWithoutStreamsInput,
    Prisma.AiChatUncheckedCreateWithoutStreamsInput
  >;
  where?: Prisma.AiChatWhereInput;
};

export type AiChatUpdateToOneWithWhereWithoutStreamsInput = {
  where?: Prisma.AiChatWhereInput;
  data: Prisma.XOR<
    Prisma.AiChatUpdateWithoutStreamsInput,
    Prisma.AiChatUncheckedUpdateWithoutStreamsInput
  >;
};

export type AiChatUpdateWithoutStreamsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  title?: Prisma.StringFieldUpdateOperationsInput | string;
  visibility?:
    | Prisma.EnumVisibilityTypeFieldUpdateOperationsInput
    | $Enums.VisibilityType;
  user?: Prisma.UserUpdateOneRequiredWithoutChatsNestedInput;
  messages?: Prisma.AiMessageUpdateManyWithoutChatNestedInput;
  votes?: Prisma.VoteUpdateManyWithoutChatNestedInput;
};

export type AiChatUncheckedUpdateWithoutStreamsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  title?: Prisma.StringFieldUpdateOperationsInput | string;
  userId?: Prisma.StringFieldUpdateOperationsInput | string;
  visibility?:
    | Prisma.EnumVisibilityTypeFieldUpdateOperationsInput
    | $Enums.VisibilityType;
  messages?: Prisma.AiMessageUncheckedUpdateManyWithoutChatNestedInput;
  votes?: Prisma.VoteUncheckedUpdateManyWithoutChatNestedInput;
};

export type AiChatCreateWithoutUserInput = {
  id?: string;
  createdAt?: Date | string;
  title: string;
  visibility?: $Enums.VisibilityType;
  messages?: Prisma.AiMessageCreateNestedManyWithoutChatInput;
  votes?: Prisma.VoteCreateNestedManyWithoutChatInput;
  streams?: Prisma.StreamCreateNestedManyWithoutChatInput;
};

export type AiChatUncheckedCreateWithoutUserInput = {
  id?: string;
  createdAt?: Date | string;
  title: string;
  visibility?: $Enums.VisibilityType;
  messages?: Prisma.AiMessageUncheckedCreateNestedManyWithoutChatInput;
  votes?: Prisma.VoteUncheckedCreateNestedManyWithoutChatInput;
  streams?: Prisma.StreamUncheckedCreateNestedManyWithoutChatInput;
};

export type AiChatCreateOrConnectWithoutUserInput = {
  where: Prisma.AiChatWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.AiChatCreateWithoutUserInput,
    Prisma.AiChatUncheckedCreateWithoutUserInput
  >;
};

export type AiChatCreateManyUserInputEnvelope = {
  data: Prisma.AiChatCreateManyUserInput | Prisma.AiChatCreateManyUserInput[];
  skipDuplicates?: boolean;
};

export type AiChatUpsertWithWhereUniqueWithoutUserInput = {
  where: Prisma.AiChatWhereUniqueInput;
  update: Prisma.XOR<
    Prisma.AiChatUpdateWithoutUserInput,
    Prisma.AiChatUncheckedUpdateWithoutUserInput
  >;
  create: Prisma.XOR<
    Prisma.AiChatCreateWithoutUserInput,
    Prisma.AiChatUncheckedCreateWithoutUserInput
  >;
};

export type AiChatUpdateWithWhereUniqueWithoutUserInput = {
  where: Prisma.AiChatWhereUniqueInput;
  data: Prisma.XOR<
    Prisma.AiChatUpdateWithoutUserInput,
    Prisma.AiChatUncheckedUpdateWithoutUserInput
  >;
};

export type AiChatUpdateManyWithWhereWithoutUserInput = {
  where: Prisma.AiChatScalarWhereInput;
  data: Prisma.XOR<
    Prisma.AiChatUpdateManyMutationInput,
    Prisma.AiChatUncheckedUpdateManyWithoutUserInput
  >;
};

export type AiChatScalarWhereInput = {
  AND?: Prisma.AiChatScalarWhereInput | Prisma.AiChatScalarWhereInput[];
  OR?: Prisma.AiChatScalarWhereInput[];
  NOT?: Prisma.AiChatScalarWhereInput | Prisma.AiChatScalarWhereInput[];
  id?: Prisma.StringFilter<"AiChat"> | string;
  createdAt?: Prisma.DateTimeFilter<"AiChat"> | Date | string;
  title?: Prisma.StringFilter<"AiChat"> | string;
  userId?: Prisma.StringFilter<"AiChat"> | string;
  visibility?:
    | Prisma.EnumVisibilityTypeFilter<"AiChat">
    | $Enums.VisibilityType;
};

export type AiChatCreateManyUserInput = {
  id?: string;
  createdAt?: Date | string;
  title: string;
  visibility?: $Enums.VisibilityType;
};

export type AiChatUpdateWithoutUserInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  title?: Prisma.StringFieldUpdateOperationsInput | string;
  visibility?:
    | Prisma.EnumVisibilityTypeFieldUpdateOperationsInput
    | $Enums.VisibilityType;
  messages?: Prisma.AiMessageUpdateManyWithoutChatNestedInput;
  votes?: Prisma.VoteUpdateManyWithoutChatNestedInput;
  streams?: Prisma.StreamUpdateManyWithoutChatNestedInput;
};

export type AiChatUncheckedUpdateWithoutUserInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  title?: Prisma.StringFieldUpdateOperationsInput | string;
  visibility?:
    | Prisma.EnumVisibilityTypeFieldUpdateOperationsInput
    | $Enums.VisibilityType;
  messages?: Prisma.AiMessageUncheckedUpdateManyWithoutChatNestedInput;
  votes?: Prisma.VoteUncheckedUpdateManyWithoutChatNestedInput;
  streams?: Prisma.StreamUncheckedUpdateManyWithoutChatNestedInput;
};

export type AiChatUncheckedUpdateManyWithoutUserInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  title?: Prisma.StringFieldUpdateOperationsInput | string;
  visibility?:
    | Prisma.EnumVisibilityTypeFieldUpdateOperationsInput
    | $Enums.VisibilityType;
};

/**
 * Count Type AiChatCountOutputType
 */

export type AiChatCountOutputType = {
  messages: number;
  votes: number;
  streams: number;
};

export type AiChatCountOutputTypeSelect<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  messages?: boolean | AiChatCountOutputTypeCountMessagesArgs;
  votes?: boolean | AiChatCountOutputTypeCountVotesArgs;
  streams?: boolean | AiChatCountOutputTypeCountStreamsArgs;
};

/**
 * AiChatCountOutputType without action
 */
export type AiChatCountOutputTypeDefaultArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the AiChatCountOutputType
   */
  select?: Prisma.AiChatCountOutputTypeSelect<ExtArgs> | null;
};

/**
 * AiChatCountOutputType without action
 */
export type AiChatCountOutputTypeCountMessagesArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  where?: Prisma.AiMessageWhereInput;
};

/**
 * AiChatCountOutputType without action
 */
export type AiChatCountOutputTypeCountVotesArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  where?: Prisma.VoteWhereInput;
};

/**
 * AiChatCountOutputType without action
 */
export type AiChatCountOutputTypeCountStreamsArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  where?: Prisma.StreamWhereInput;
};

export type AiChatSelect<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
  {
    id?: boolean;
    createdAt?: boolean;
    title?: boolean;
    userId?: boolean;
    visibility?: boolean;
    user?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
    messages?: boolean | Prisma.AiChat$messagesArgs<ExtArgs>;
    votes?: boolean | Prisma.AiChat$votesArgs<ExtArgs>;
    streams?: boolean | Prisma.AiChat$streamsArgs<ExtArgs>;
    _count?: boolean | Prisma.AiChatCountOutputTypeDefaultArgs<ExtArgs>;
  },
  ExtArgs["result"]["aiChat"]
>;

export type AiChatSelectCreateManyAndReturn<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
  {
    id?: boolean;
    createdAt?: boolean;
    title?: boolean;
    userId?: boolean;
    visibility?: boolean;
    user?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
  },
  ExtArgs["result"]["aiChat"]
>;

export type AiChatSelectUpdateManyAndReturn<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
  {
    id?: boolean;
    createdAt?: boolean;
    title?: boolean;
    userId?: boolean;
    visibility?: boolean;
    user?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
  },
  ExtArgs["result"]["aiChat"]
>;

export type AiChatSelectScalar = {
  id?: boolean;
  createdAt?: boolean;
  title?: boolean;
  userId?: boolean;
  visibility?: boolean;
};

export type AiChatOmit<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetOmit<
  "id" | "createdAt" | "title" | "userId" | "visibility",
  ExtArgs["result"]["aiChat"]
>;
export type AiChatInclude<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
  messages?: boolean | Prisma.AiChat$messagesArgs<ExtArgs>;
  votes?: boolean | Prisma.AiChat$votesArgs<ExtArgs>;
  streams?: boolean | Prisma.AiChat$streamsArgs<ExtArgs>;
  _count?: boolean | Prisma.AiChatCountOutputTypeDefaultArgs<ExtArgs>;
};
export type AiChatIncludeCreateManyAndReturn<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
};
export type AiChatIncludeUpdateManyAndReturn<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
};

export type $AiChatPayload<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  name: "AiChat";
  objects: {
    user: Prisma.$UserPayload<ExtArgs>;
    messages: Prisma.$AiMessagePayload<ExtArgs>[];
    votes: Prisma.$VotePayload<ExtArgs>[];
    streams: Prisma.$StreamPayload<ExtArgs>[];
  };
  scalars: runtime.Types.Extensions.GetPayloadResult<
    {
      id: string;
      createdAt: Date;
      title: string;
      userId: string;
      visibility: $Enums.VisibilityType;
    },
    ExtArgs["result"]["aiChat"]
  >;
  composites: {};
};

export type AiChatGetPayload<
  S extends boolean | null | undefined | AiChatDefaultArgs,
> = runtime.Types.Result.GetResult<Prisma.$AiChatPayload, S>;

export type AiChatCountArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = Omit<AiChatFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
  select?: AiChatCountAggregateInputType | true;
};

export interface AiChatDelegate<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
  GlobalOmitOptions = {},
> {
  [K: symbol]: {
    types: Prisma.TypeMap<ExtArgs>["model"]["AiChat"];
    meta: { name: "AiChat" };
  };
  /**
   * Find zero or one AiChat that matches the filter.
   * @param {AiChatFindUniqueArgs} args - Arguments to find a AiChat
   * @example
   * // Get one AiChat
   * const aiChat = await prisma.aiChat.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends AiChatFindUniqueArgs>(
    args: Prisma.SelectSubset<T, AiChatFindUniqueArgs<ExtArgs>>,
  ): Prisma.Prisma__AiChatClient<
    runtime.Types.Result.GetResult<
      Prisma.$AiChatPayload<ExtArgs>,
      T,
      "findUnique",
      GlobalOmitOptions
    > | null,
    null,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Find one AiChat that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {AiChatFindUniqueOrThrowArgs} args - Arguments to find a AiChat
   * @example
   * // Get one AiChat
   * const aiChat = await prisma.aiChat.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends AiChatFindUniqueOrThrowArgs>(
    args: Prisma.SelectSubset<T, AiChatFindUniqueOrThrowArgs<ExtArgs>>,
  ): Prisma.Prisma__AiChatClient<
    runtime.Types.Result.GetResult<
      Prisma.$AiChatPayload<ExtArgs>,
      T,
      "findUniqueOrThrow",
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Find the first AiChat that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {AiChatFindFirstArgs} args - Arguments to find a AiChat
   * @example
   * // Get one AiChat
   * const aiChat = await prisma.aiChat.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends AiChatFindFirstArgs>(
    args?: Prisma.SelectSubset<T, AiChatFindFirstArgs<ExtArgs>>,
  ): Prisma.Prisma__AiChatClient<
    runtime.Types.Result.GetResult<
      Prisma.$AiChatPayload<ExtArgs>,
      T,
      "findFirst",
      GlobalOmitOptions
    > | null,
    null,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Find the first AiChat that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {AiChatFindFirstOrThrowArgs} args - Arguments to find a AiChat
   * @example
   * // Get one AiChat
   * const aiChat = await prisma.aiChat.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends AiChatFindFirstOrThrowArgs>(
    args?: Prisma.SelectSubset<T, AiChatFindFirstOrThrowArgs<ExtArgs>>,
  ): Prisma.Prisma__AiChatClient<
    runtime.Types.Result.GetResult<
      Prisma.$AiChatPayload<ExtArgs>,
      T,
      "findFirstOrThrow",
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Find zero or more AiChats that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {AiChatFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all AiChats
   * const aiChats = await prisma.aiChat.findMany()
   *
   * // Get first 10 AiChats
   * const aiChats = await prisma.aiChat.findMany({ take: 10 })
   *
   * // Only select the `id`
   * const aiChatWithIdOnly = await prisma.aiChat.findMany({ select: { id: true } })
   *
   */
  findMany<T extends AiChatFindManyArgs>(
    args?: Prisma.SelectSubset<T, AiChatFindManyArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<
    runtime.Types.Result.GetResult<
      Prisma.$AiChatPayload<ExtArgs>,
      T,
      "findMany",
      GlobalOmitOptions
    >
  >;

  /**
   * Create a AiChat.
   * @param {AiChatCreateArgs} args - Arguments to create a AiChat.
   * @example
   * // Create one AiChat
   * const AiChat = await prisma.aiChat.create({
   *   data: {
   *     // ... data to create a AiChat
   *   }
   * })
   *
   */
  create<T extends AiChatCreateArgs>(
    args: Prisma.SelectSubset<T, AiChatCreateArgs<ExtArgs>>,
  ): Prisma.Prisma__AiChatClient<
    runtime.Types.Result.GetResult<
      Prisma.$AiChatPayload<ExtArgs>,
      T,
      "create",
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Create many AiChats.
   * @param {AiChatCreateManyArgs} args - Arguments to create many AiChats.
   * @example
   * // Create many AiChats
   * const aiChat = await prisma.aiChat.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *
   */
  createMany<T extends AiChatCreateManyArgs>(
    args?: Prisma.SelectSubset<T, AiChatCreateManyArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<Prisma.BatchPayload>;

  /**
   * Create many AiChats and returns the data saved in the database.
   * @param {AiChatCreateManyAndReturnArgs} args - Arguments to create many AiChats.
   * @example
   * // Create many AiChats
   * const aiChat = await prisma.aiChat.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *
   * // Create many AiChats and only return the `id`
   * const aiChatWithIdOnly = await prisma.aiChat.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   *
   */
  createManyAndReturn<T extends AiChatCreateManyAndReturnArgs>(
    args?: Prisma.SelectSubset<T, AiChatCreateManyAndReturnArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<
    runtime.Types.Result.GetResult<
      Prisma.$AiChatPayload<ExtArgs>,
      T,
      "createManyAndReturn",
      GlobalOmitOptions
    >
  >;

  /**
   * Delete a AiChat.
   * @param {AiChatDeleteArgs} args - Arguments to delete one AiChat.
   * @example
   * // Delete one AiChat
   * const AiChat = await prisma.aiChat.delete({
   *   where: {
   *     // ... filter to delete one AiChat
   *   }
   * })
   *
   */
  delete<T extends AiChatDeleteArgs>(
    args: Prisma.SelectSubset<T, AiChatDeleteArgs<ExtArgs>>,
  ): Prisma.Prisma__AiChatClient<
    runtime.Types.Result.GetResult<
      Prisma.$AiChatPayload<ExtArgs>,
      T,
      "delete",
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Update one AiChat.
   * @param {AiChatUpdateArgs} args - Arguments to update one AiChat.
   * @example
   * // Update one AiChat
   * const aiChat = await prisma.aiChat.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   *
   */
  update<T extends AiChatUpdateArgs>(
    args: Prisma.SelectSubset<T, AiChatUpdateArgs<ExtArgs>>,
  ): Prisma.Prisma__AiChatClient<
    runtime.Types.Result.GetResult<
      Prisma.$AiChatPayload<ExtArgs>,
      T,
      "update",
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Delete zero or more AiChats.
   * @param {AiChatDeleteManyArgs} args - Arguments to filter AiChats to delete.
   * @example
   * // Delete a few AiChats
   * const { count } = await prisma.aiChat.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   *
   */
  deleteMany<T extends AiChatDeleteManyArgs>(
    args?: Prisma.SelectSubset<T, AiChatDeleteManyArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<Prisma.BatchPayload>;

  /**
   * Update zero or more AiChats.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {AiChatUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many AiChats
   * const aiChat = await prisma.aiChat.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   *
   */
  updateMany<T extends AiChatUpdateManyArgs>(
    args: Prisma.SelectSubset<T, AiChatUpdateManyArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<Prisma.BatchPayload>;

  /**
   * Update zero or more AiChats and returns the data updated in the database.
   * @param {AiChatUpdateManyAndReturnArgs} args - Arguments to update many AiChats.
   * @example
   * // Update many AiChats
   * const aiChat = await prisma.aiChat.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *
   * // Update zero or more AiChats and only return the `id`
   * const aiChatWithIdOnly = await prisma.aiChat.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   *
   */
  updateManyAndReturn<T extends AiChatUpdateManyAndReturnArgs>(
    args: Prisma.SelectSubset<T, AiChatUpdateManyAndReturnArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<
    runtime.Types.Result.GetResult<
      Prisma.$AiChatPayload<ExtArgs>,
      T,
      "updateManyAndReturn",
      GlobalOmitOptions
    >
  >;

  /**
   * Create or update one AiChat.
   * @param {AiChatUpsertArgs} args - Arguments to update or create a AiChat.
   * @example
   * // Update or create a AiChat
   * const aiChat = await prisma.aiChat.upsert({
   *   create: {
   *     // ... data to create a AiChat
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the AiChat we want to update
   *   }
   * })
   */
  upsert<T extends AiChatUpsertArgs>(
    args: Prisma.SelectSubset<T, AiChatUpsertArgs<ExtArgs>>,
  ): Prisma.Prisma__AiChatClient<
    runtime.Types.Result.GetResult<
      Prisma.$AiChatPayload<ExtArgs>,
      T,
      "upsert",
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Count the number of AiChats.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {AiChatCountArgs} args - Arguments to filter AiChats to count.
   * @example
   * // Count the number of AiChats
   * const count = await prisma.aiChat.count({
   *   where: {
   *     // ... the filter for the AiChats we want to count
   *   }
   * })
   **/
  count<T extends AiChatCountArgs>(
    args?: Prisma.Subset<T, AiChatCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<"select", any>
      ? T["select"] extends true
        ? number
        : Prisma.GetScalarType<T["select"], AiChatCountAggregateOutputType>
      : number
  >;

  /**
   * Allows you to perform aggregations operations on a AiChat.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {AiChatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
   **/
  aggregate<T extends AiChatAggregateArgs>(
    args: Prisma.Subset<T, AiChatAggregateArgs>,
  ): Prisma.PrismaPromise<GetAiChatAggregateType<T>>;

  /**
   * Group by AiChat.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {AiChatGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   *
   **/
  groupBy<
    T extends AiChatGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<"skip", Prisma.Keys<T>>,
      Prisma.Extends<"take", Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: AiChatGroupByArgs["orderBy"] }
      : { orderBy?: AiChatGroupByArgs["orderBy"] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<
      Prisma.Keys<Prisma.MaybeTupleToUnion<T["orderBy"]>>
    >,
    ByFields extends Prisma.MaybeTupleToUnion<T["by"]>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T["having"]>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T["by"] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
      ? `Error: "by" must not be empty.`
      : HavingValid extends Prisma.False
        ? {
            [P in HavingFields]: P extends ByFields
              ? never
              : P extends string
                ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                : [
                    Error,
                    "Field ",
                    P,
                    ` in "having" needs to be provided in "by"`,
                  ];
          }[HavingFields]
        : "take" extends Prisma.Keys<T>
          ? "orderBy" extends Prisma.Keys<T>
            ? ByValid extends Prisma.True
              ? {}
              : {
                  [P in OrderFields]: P extends ByFields
                    ? never
                    : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                }[OrderFields]
            : 'Error: If you provide "take", you also need to provide "orderBy"'
          : "skip" extends Prisma.Keys<T>
            ? "orderBy" extends Prisma.Keys<T>
              ? ByValid extends Prisma.True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "skip", you also need to provide "orderBy"'
            : ByValid extends Prisma.True
              ? {}
              : {
                  [P in OrderFields]: P extends ByFields
                    ? never
                    : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                }[OrderFields],
  >(
    args: Prisma.SubsetIntersection<T, AiChatGroupByArgs, OrderByArg> &
      InputErrors,
  ): {} extends InputErrors
    ? GetAiChatGroupByPayload<T>
    : Prisma.PrismaPromise<InputErrors>;
  /**
   * Fields of the AiChat model
   */
  readonly fields: AiChatFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for AiChat.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__AiChatClient<
  T,
  Null = never,
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
  GlobalOmitOptions = {},
> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise";
  user<T extends Prisma.UserDefaultArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.UserDefaultArgs<ExtArgs>>,
  ): Prisma.Prisma__UserClient<
    | runtime.Types.Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >
    | Null,
    Null,
    ExtArgs,
    GlobalOmitOptions
  >;
  messages<T extends Prisma.AiChat$messagesArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.AiChat$messagesArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<
    | runtime.Types.Result.GetResult<
        Prisma.$AiMessagePayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    | Null
  >;
  votes<T extends Prisma.AiChat$votesArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.AiChat$votesArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<
    | runtime.Types.Result.GetResult<
        Prisma.$VotePayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    | Null
  >;
  streams<T extends Prisma.AiChat$streamsArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.AiChat$streamsArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<
    | runtime.Types.Result.GetResult<
        Prisma.$StreamPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    | Null
  >;
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(
    onfulfilled?:
      | ((value: T) => TResult1 | PromiseLike<TResult1>)
      | undefined
      | null,
    onrejected?:
      | ((reason: any) => TResult2 | PromiseLike<TResult2>)
      | undefined
      | null,
  ): runtime.Types.Utils.JsPromise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(
    onrejected?:
      | ((reason: any) => TResult | PromiseLike<TResult>)
      | undefined
      | null,
  ): runtime.Types.Utils.JsPromise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(
    onfinally?: (() => void) | undefined | null,
  ): runtime.Types.Utils.JsPromise<T>;
}

/**
 * Fields of the AiChat model
 */
export interface AiChatFieldRefs {
  readonly id: Prisma.FieldRef<"AiChat", "String">;
  readonly createdAt: Prisma.FieldRef<"AiChat", "DateTime">;
  readonly title: Prisma.FieldRef<"AiChat", "String">;
  readonly userId: Prisma.FieldRef<"AiChat", "String">;
  readonly visibility: Prisma.FieldRef<"AiChat", "VisibilityType">;
}

// Custom InputTypes
/**
 * AiChat findUnique
 */
export type AiChatFindUniqueArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the AiChat
   */
  select?: Prisma.AiChatSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the AiChat
   */
  omit?: Prisma.AiChatOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.AiChatInclude<ExtArgs> | null;
  /**
   * Filter, which AiChat to fetch.
   */
  where: Prisma.AiChatWhereUniqueInput;
};

/**
 * AiChat findUniqueOrThrow
 */
export type AiChatFindUniqueOrThrowArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the AiChat
   */
  select?: Prisma.AiChatSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the AiChat
   */
  omit?: Prisma.AiChatOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.AiChatInclude<ExtArgs> | null;
  /**
   * Filter, which AiChat to fetch.
   */
  where: Prisma.AiChatWhereUniqueInput;
};

/**
 * AiChat findFirst
 */
export type AiChatFindFirstArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the AiChat
   */
  select?: Prisma.AiChatSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the AiChat
   */
  omit?: Prisma.AiChatOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.AiChatInclude<ExtArgs> | null;
  /**
   * Filter, which AiChat to fetch.
   */
  where?: Prisma.AiChatWhereInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   *
   * Determine the order of AiChats to fetch.
   */
  orderBy?:
    | Prisma.AiChatOrderByWithRelationInput
    | Prisma.AiChatOrderByWithRelationInput[];
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   *
   * Sets the position for searching for AiChats.
   */
  cursor?: Prisma.AiChatWhereUniqueInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Take `Â±n` AiChats from the position of the cursor.
   */
  take?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Skip the first `n` AiChats.
   */
  skip?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   *
   * Filter by unique combinations of AiChats.
   */
  distinct?: Prisma.AiChatScalarFieldEnum | Prisma.AiChatScalarFieldEnum[];
};

/**
 * AiChat findFirstOrThrow
 */
export type AiChatFindFirstOrThrowArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the AiChat
   */
  select?: Prisma.AiChatSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the AiChat
   */
  omit?: Prisma.AiChatOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.AiChatInclude<ExtArgs> | null;
  /**
   * Filter, which AiChat to fetch.
   */
  where?: Prisma.AiChatWhereInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   *
   * Determine the order of AiChats to fetch.
   */
  orderBy?:
    | Prisma.AiChatOrderByWithRelationInput
    | Prisma.AiChatOrderByWithRelationInput[];
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   *
   * Sets the position for searching for AiChats.
   */
  cursor?: Prisma.AiChatWhereUniqueInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Take `Â±n` AiChats from the position of the cursor.
   */
  take?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Skip the first `n` AiChats.
   */
  skip?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   *
   * Filter by unique combinations of AiChats.
   */
  distinct?: Prisma.AiChatScalarFieldEnum | Prisma.AiChatScalarFieldEnum[];
};

/**
 * AiChat findMany
 */
export type AiChatFindManyArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the AiChat
   */
  select?: Prisma.AiChatSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the AiChat
   */
  omit?: Prisma.AiChatOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.AiChatInclude<ExtArgs> | null;
  /**
   * Filter, which AiChats to fetch.
   */
  where?: Prisma.AiChatWhereInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   *
   * Determine the order of AiChats to fetch.
   */
  orderBy?:
    | Prisma.AiChatOrderByWithRelationInput
    | Prisma.AiChatOrderByWithRelationInput[];
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   *
   * Sets the position for listing AiChats.
   */
  cursor?: Prisma.AiChatWhereUniqueInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Take `Â±n` AiChats from the position of the cursor.
   */
  take?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Skip the first `n` AiChats.
   */
  skip?: number;
  distinct?: Prisma.AiChatScalarFieldEnum | Prisma.AiChatScalarFieldEnum[];
};

/**
 * AiChat create
 */
export type AiChatCreateArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the AiChat
   */
  select?: Prisma.AiChatSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the AiChat
   */
  omit?: Prisma.AiChatOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.AiChatInclude<ExtArgs> | null;
  /**
   * The data needed to create a AiChat.
   */
  data: Prisma.XOR<Prisma.AiChatCreateInput, Prisma.AiChatUncheckedCreateInput>;
};

/**
 * AiChat createMany
 */
export type AiChatCreateManyArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * The data used to create many AiChats.
   */
  data: Prisma.AiChatCreateManyInput | Prisma.AiChatCreateManyInput[];
  skipDuplicates?: boolean;
};

/**
 * AiChat createManyAndReturn
 */
export type AiChatCreateManyAndReturnArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the AiChat
   */
  select?: Prisma.AiChatSelectCreateManyAndReturn<ExtArgs> | null;
  /**
   * Omit specific fields from the AiChat
   */
  omit?: Prisma.AiChatOmit<ExtArgs> | null;
  /**
   * The data used to create many AiChats.
   */
  data: Prisma.AiChatCreateManyInput | Prisma.AiChatCreateManyInput[];
  skipDuplicates?: boolean;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.AiChatIncludeCreateManyAndReturn<ExtArgs> | null;
};

/**
 * AiChat update
 */
export type AiChatUpdateArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the AiChat
   */
  select?: Prisma.AiChatSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the AiChat
   */
  omit?: Prisma.AiChatOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.AiChatInclude<ExtArgs> | null;
  /**
   * The data needed to update a AiChat.
   */
  data: Prisma.XOR<Prisma.AiChatUpdateInput, Prisma.AiChatUncheckedUpdateInput>;
  /**
   * Choose, which AiChat to update.
   */
  where: Prisma.AiChatWhereUniqueInput;
};

/**
 * AiChat updateMany
 */
export type AiChatUpdateManyArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * The data used to update AiChats.
   */
  data: Prisma.XOR<
    Prisma.AiChatUpdateManyMutationInput,
    Prisma.AiChatUncheckedUpdateManyInput
  >;
  /**
   * Filter which AiChats to update
   */
  where?: Prisma.AiChatWhereInput;
  /**
   * Limit how many AiChats to update.
   */
  limit?: number;
};

/**
 * AiChat updateManyAndReturn
 */
export type AiChatUpdateManyAndReturnArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the AiChat
   */
  select?: Prisma.AiChatSelectUpdateManyAndReturn<ExtArgs> | null;
  /**
   * Omit specific fields from the AiChat
   */
  omit?: Prisma.AiChatOmit<ExtArgs> | null;
  /**
   * The data used to update AiChats.
   */
  data: Prisma.XOR<
    Prisma.AiChatUpdateManyMutationInput,
    Prisma.AiChatUncheckedUpdateManyInput
  >;
  /**
   * Filter which AiChats to update
   */
  where?: Prisma.AiChatWhereInput;
  /**
   * Limit how many AiChats to update.
   */
  limit?: number;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.AiChatIncludeUpdateManyAndReturn<ExtArgs> | null;
};

/**
 * AiChat upsert
 */
export type AiChatUpsertArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the AiChat
   */
  select?: Prisma.AiChatSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the AiChat
   */
  omit?: Prisma.AiChatOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.AiChatInclude<ExtArgs> | null;
  /**
   * The filter to search for the AiChat to update in case it exists.
   */
  where: Prisma.AiChatWhereUniqueInput;
  /**
   * In case the AiChat found by the `where` argument doesn't exist, create a new AiChat with this data.
   */
  create: Prisma.XOR<
    Prisma.AiChatCreateInput,
    Prisma.AiChatUncheckedCreateInput
  >;
  /**
   * In case the AiChat was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<
    Prisma.AiChatUpdateInput,
    Prisma.AiChatUncheckedUpdateInput
  >;
};

/**
 * AiChat delete
 */
export type AiChatDeleteArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the AiChat
   */
  select?: Prisma.AiChatSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the AiChat
   */
  omit?: Prisma.AiChatOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.AiChatInclude<ExtArgs> | null;
  /**
   * Filter which AiChat to delete.
   */
  where: Prisma.AiChatWhereUniqueInput;
};

/**
 * AiChat deleteMany
 */
export type AiChatDeleteManyArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Filter which AiChats to delete
   */
  where?: Prisma.AiChatWhereInput;
  /**
   * Limit how many AiChats to delete.
   */
  limit?: number;
};

/**
 * AiChat.messages
 */
export type AiChat$messagesArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the AiMessage
   */
  select?: Prisma.AiMessageSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the AiMessage
   */
  omit?: Prisma.AiMessageOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.AiMessageInclude<ExtArgs> | null;
  where?: Prisma.AiMessageWhereInput;
  orderBy?:
    | Prisma.AiMessageOrderByWithRelationInput
    | Prisma.AiMessageOrderByWithRelationInput[];
  cursor?: Prisma.AiMessageWhereUniqueInput;
  take?: number;
  skip?: number;
  distinct?:
    | Prisma.AiMessageScalarFieldEnum
    | Prisma.AiMessageScalarFieldEnum[];
};

/**
 * AiChat.votes
 */
export type AiChat$votesArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Vote
   */
  select?: Prisma.VoteSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Vote
   */
  omit?: Prisma.VoteOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.VoteInclude<ExtArgs> | null;
  where?: Prisma.VoteWhereInput;
  orderBy?:
    | Prisma.VoteOrderByWithRelationInput
    | Prisma.VoteOrderByWithRelationInput[];
  cursor?: Prisma.VoteWhereUniqueInput;
  take?: number;
  skip?: number;
  distinct?: Prisma.VoteScalarFieldEnum | Prisma.VoteScalarFieldEnum[];
};

/**
 * AiChat.streams
 */
export type AiChat$streamsArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Stream
   */
  select?: Prisma.StreamSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Stream
   */
  omit?: Prisma.StreamOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.StreamInclude<ExtArgs> | null;
  where?: Prisma.StreamWhereInput;
  orderBy?:
    | Prisma.StreamOrderByWithRelationInput
    | Prisma.StreamOrderByWithRelationInput[];
  cursor?: Prisma.StreamWhereUniqueInput;
  take?: number;
  skip?: number;
  distinct?: Prisma.StreamScalarFieldEnum | Prisma.StreamScalarFieldEnum[];
};

/**
 * AiChat without action
 */
export type AiChatDefaultArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the AiChat
   */
  select?: Prisma.AiChatSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the AiChat
   */
  omit?: Prisma.AiChatOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.AiChatInclude<ExtArgs> | null;
};
