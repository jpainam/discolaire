/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// @ts-nocheck
/*
 * This file exports the `Term` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client";

import type * as $Enums from "../enums";
import type * as Prisma from "../internal/prismaNamespace";

/**
 * Model Term
 *
 */
export type TermModel =
  runtime.Types.Result.DefaultSelection<Prisma.$TermPayload>;

export type AggregateTerm = {
  _count: TermCountAggregateOutputType | null;
  _avg: TermAvgAggregateOutputType | null;
  _sum: TermSumAggregateOutputType | null;
  _min: TermMinAggregateOutputType | null;
  _max: TermMaxAggregateOutputType | null;
};

export type TermAvgAggregateOutputType = {
  order: number | null;
};

export type TermSumAggregateOutputType = {
  order: number | null;
};

export type TermMinAggregateOutputType = {
  id: string | null;
  name: string | null;
  schoolYearId: string | null;
  order: number | null;
  startDate: Date | null;
  endDate: Date | null;
  isActive: boolean | null;
  observation: string | null;
  schoolId: string | null;
};

export type TermMaxAggregateOutputType = {
  id: string | null;
  name: string | null;
  schoolYearId: string | null;
  order: number | null;
  startDate: Date | null;
  endDate: Date | null;
  isActive: boolean | null;
  observation: string | null;
  schoolId: string | null;
};

export type TermCountAggregateOutputType = {
  id: number;
  name: number;
  schoolYearId: number;
  order: number;
  startDate: number;
  endDate: number;
  isActive: number;
  observation: number;
  schoolId: number;
  _all: number;
};

export type TermAvgAggregateInputType = {
  order?: true;
};

export type TermSumAggregateInputType = {
  order?: true;
};

export type TermMinAggregateInputType = {
  id?: true;
  name?: true;
  schoolYearId?: true;
  order?: true;
  startDate?: true;
  endDate?: true;
  isActive?: true;
  observation?: true;
  schoolId?: true;
};

export type TermMaxAggregateInputType = {
  id?: true;
  name?: true;
  schoolYearId?: true;
  order?: true;
  startDate?: true;
  endDate?: true;
  isActive?: true;
  observation?: true;
  schoolId?: true;
};

export type TermCountAggregateInputType = {
  id?: true;
  name?: true;
  schoolYearId?: true;
  order?: true;
  startDate?: true;
  endDate?: true;
  isActive?: true;
  observation?: true;
  schoolId?: true;
  _all?: true;
};

export type TermAggregateArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Filter which Term to aggregate.
   */
  where?: Prisma.TermWhereInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   *
   * Determine the order of Terms to fetch.
   */
  orderBy?:
    | Prisma.TermOrderByWithRelationInput
    | Prisma.TermOrderByWithRelationInput[];
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   *
   * Sets the start position
   */
  cursor?: Prisma.TermWhereUniqueInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Take `Â±n` Terms from the position of the cursor.
   */
  take?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Skip the first `n` Terms.
   */
  skip?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   *
   * Count returned Terms
   **/
  _count?: true | TermCountAggregateInputType;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   *
   * Select which fields to average
   **/
  _avg?: TermAvgAggregateInputType;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   *
   * Select which fields to sum
   **/
  _sum?: TermSumAggregateInputType;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   *
   * Select which fields to find the minimum value
   **/
  _min?: TermMinAggregateInputType;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   *
   * Select which fields to find the maximum value
   **/
  _max?: TermMaxAggregateInputType;
};

export type GetTermAggregateType<T extends TermAggregateArgs> = {
  [P in keyof T & keyof AggregateTerm]: P extends "_count" | "count"
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateTerm[P]>
    : Prisma.GetScalarType<T[P], AggregateTerm[P]>;
};

export type TermGroupByArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  where?: Prisma.TermWhereInput;
  orderBy?:
    | Prisma.TermOrderByWithAggregationInput
    | Prisma.TermOrderByWithAggregationInput[];
  by: Prisma.TermScalarFieldEnum[] | Prisma.TermScalarFieldEnum;
  having?: Prisma.TermScalarWhereWithAggregatesInput;
  take?: number;
  skip?: number;
  _count?: TermCountAggregateInputType | true;
  _avg?: TermAvgAggregateInputType;
  _sum?: TermSumAggregateInputType;
  _min?: TermMinAggregateInputType;
  _max?: TermMaxAggregateInputType;
};

export type TermGroupByOutputType = {
  id: string;
  name: string;
  schoolYearId: string;
  order: number;
  startDate: Date;
  endDate: Date;
  isActive: boolean | null;
  observation: string | null;
  schoolId: string;
  _count: TermCountAggregateOutputType | null;
  _avg: TermAvgAggregateOutputType | null;
  _sum: TermSumAggregateOutputType | null;
  _min: TermMinAggregateOutputType | null;
  _max: TermMaxAggregateOutputType | null;
};

type GetTermGroupByPayload<T extends TermGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<TermGroupByOutputType, T["by"]> & {
      [P in keyof T & keyof TermGroupByOutputType]: P extends "_count"
        ? T[P] extends boolean
          ? number
          : Prisma.GetScalarType<T[P], TermGroupByOutputType[P]>
        : Prisma.GetScalarType<T[P], TermGroupByOutputType[P]>;
    }
  >
>;

export type TermWhereInput = {
  AND?: Prisma.TermWhereInput | Prisma.TermWhereInput[];
  OR?: Prisma.TermWhereInput[];
  NOT?: Prisma.TermWhereInput | Prisma.TermWhereInput[];
  id?: Prisma.StringFilter<"Term"> | string;
  name?: Prisma.StringFilter<"Term"> | string;
  schoolYearId?: Prisma.StringFilter<"Term"> | string;
  order?: Prisma.IntFilter<"Term"> | number;
  startDate?: Prisma.DateTimeFilter<"Term"> | Date | string;
  endDate?: Prisma.DateTimeFilter<"Term"> | Date | string;
  isActive?: Prisma.BoolNullableFilter<"Term"> | boolean | null;
  observation?: Prisma.StringNullableFilter<"Term"> | string | null;
  schoolId?: Prisma.StringFilter<"Term"> | string;
  gradeSheets?: Prisma.GradeSheetListRelationFilter;
  schoolYear?: Prisma.XOR<
    Prisma.SchoolYearScalarRelationFilter,
    Prisma.SchoolYearWhereInput
  >;
  reportCards?: Prisma.ReportCardListRelationFilter;
  assignments?: Prisma.AssignmentListRelationFilter;
  School?: Prisma.XOR<
    Prisma.SchoolScalarRelationFilter,
    Prisma.SchoolWhereInput
  >;
  absences?: Prisma.AbsenceListRelationFilter;
  latenesses?: Prisma.LatenessListRelationFilter;
  exclusions?: Prisma.ExclusionListRelationFilter;
  consignes?: Prisma.ConsigneListRelationFilter;
  chatters?: Prisma.ChatterListRelationFilter;
  convocations?: Prisma.ConvocationListRelationFilter;
  periodicAttendances?: Prisma.PeriodicAttendanceListRelationFilter;
};

export type TermOrderByWithRelationInput = {
  id?: Prisma.SortOrder;
  name?: Prisma.SortOrder;
  schoolYearId?: Prisma.SortOrder;
  order?: Prisma.SortOrder;
  startDate?: Prisma.SortOrder;
  endDate?: Prisma.SortOrder;
  isActive?: Prisma.SortOrderInput | Prisma.SortOrder;
  observation?: Prisma.SortOrderInput | Prisma.SortOrder;
  schoolId?: Prisma.SortOrder;
  gradeSheets?: Prisma.GradeSheetOrderByRelationAggregateInput;
  schoolYear?: Prisma.SchoolYearOrderByWithRelationInput;
  reportCards?: Prisma.ReportCardOrderByRelationAggregateInput;
  assignments?: Prisma.AssignmentOrderByRelationAggregateInput;
  School?: Prisma.SchoolOrderByWithRelationInput;
  absences?: Prisma.AbsenceOrderByRelationAggregateInput;
  latenesses?: Prisma.LatenessOrderByRelationAggregateInput;
  exclusions?: Prisma.ExclusionOrderByRelationAggregateInput;
  consignes?: Prisma.ConsigneOrderByRelationAggregateInput;
  chatters?: Prisma.ChatterOrderByRelationAggregateInput;
  convocations?: Prisma.ConvocationOrderByRelationAggregateInput;
  periodicAttendances?: Prisma.PeriodicAttendanceOrderByRelationAggregateInput;
};

export type TermWhereUniqueInput = Prisma.AtLeast<
  {
    id?: string;
    AND?: Prisma.TermWhereInput | Prisma.TermWhereInput[];
    OR?: Prisma.TermWhereInput[];
    NOT?: Prisma.TermWhereInput | Prisma.TermWhereInput[];
    name?: Prisma.StringFilter<"Term"> | string;
    schoolYearId?: Prisma.StringFilter<"Term"> | string;
    order?: Prisma.IntFilter<"Term"> | number;
    startDate?: Prisma.DateTimeFilter<"Term"> | Date | string;
    endDate?: Prisma.DateTimeFilter<"Term"> | Date | string;
    isActive?: Prisma.BoolNullableFilter<"Term"> | boolean | null;
    observation?: Prisma.StringNullableFilter<"Term"> | string | null;
    schoolId?: Prisma.StringFilter<"Term"> | string;
    gradeSheets?: Prisma.GradeSheetListRelationFilter;
    schoolYear?: Prisma.XOR<
      Prisma.SchoolYearScalarRelationFilter,
      Prisma.SchoolYearWhereInput
    >;
    reportCards?: Prisma.ReportCardListRelationFilter;
    assignments?: Prisma.AssignmentListRelationFilter;
    School?: Prisma.XOR<
      Prisma.SchoolScalarRelationFilter,
      Prisma.SchoolWhereInput
    >;
    absences?: Prisma.AbsenceListRelationFilter;
    latenesses?: Prisma.LatenessListRelationFilter;
    exclusions?: Prisma.ExclusionListRelationFilter;
    consignes?: Prisma.ConsigneListRelationFilter;
    chatters?: Prisma.ChatterListRelationFilter;
    convocations?: Prisma.ConvocationListRelationFilter;
    periodicAttendances?: Prisma.PeriodicAttendanceListRelationFilter;
  },
  "id"
>;

export type TermOrderByWithAggregationInput = {
  id?: Prisma.SortOrder;
  name?: Prisma.SortOrder;
  schoolYearId?: Prisma.SortOrder;
  order?: Prisma.SortOrder;
  startDate?: Prisma.SortOrder;
  endDate?: Prisma.SortOrder;
  isActive?: Prisma.SortOrderInput | Prisma.SortOrder;
  observation?: Prisma.SortOrderInput | Prisma.SortOrder;
  schoolId?: Prisma.SortOrder;
  _count?: Prisma.TermCountOrderByAggregateInput;
  _avg?: Prisma.TermAvgOrderByAggregateInput;
  _max?: Prisma.TermMaxOrderByAggregateInput;
  _min?: Prisma.TermMinOrderByAggregateInput;
  _sum?: Prisma.TermSumOrderByAggregateInput;
};

export type TermScalarWhereWithAggregatesInput = {
  AND?:
    | Prisma.TermScalarWhereWithAggregatesInput
    | Prisma.TermScalarWhereWithAggregatesInput[];
  OR?: Prisma.TermScalarWhereWithAggregatesInput[];
  NOT?:
    | Prisma.TermScalarWhereWithAggregatesInput
    | Prisma.TermScalarWhereWithAggregatesInput[];
  id?: Prisma.StringWithAggregatesFilter<"Term"> | string;
  name?: Prisma.StringWithAggregatesFilter<"Term"> | string;
  schoolYearId?: Prisma.StringWithAggregatesFilter<"Term"> | string;
  order?: Prisma.IntWithAggregatesFilter<"Term"> | number;
  startDate?: Prisma.DateTimeWithAggregatesFilter<"Term"> | Date | string;
  endDate?: Prisma.DateTimeWithAggregatesFilter<"Term"> | Date | string;
  isActive?: Prisma.BoolNullableWithAggregatesFilter<"Term"> | boolean | null;
  observation?:
    | Prisma.StringNullableWithAggregatesFilter<"Term">
    | string
    | null;
  schoolId?: Prisma.StringWithAggregatesFilter<"Term"> | string;
};

export type TermCreateInput = {
  id?: string;
  name: string;
  order: number;
  startDate?: Date | string;
  endDate?: Date | string;
  isActive?: boolean | null;
  observation?: string | null;
  gradeSheets?: Prisma.GradeSheetCreateNestedManyWithoutTermInput;
  schoolYear: Prisma.SchoolYearCreateNestedOneWithoutTermsInput;
  reportCards?: Prisma.ReportCardCreateNestedManyWithoutTermInput;
  assignments?: Prisma.AssignmentCreateNestedManyWithoutTermInput;
  School: Prisma.SchoolCreateNestedOneWithoutTermsInput;
  absences?: Prisma.AbsenceCreateNestedManyWithoutTermInput;
  latenesses?: Prisma.LatenessCreateNestedManyWithoutTermInput;
  exclusions?: Prisma.ExclusionCreateNestedManyWithoutTermInput;
  consignes?: Prisma.ConsigneCreateNestedManyWithoutTermInput;
  chatters?: Prisma.ChatterCreateNestedManyWithoutTermInput;
  convocations?: Prisma.ConvocationCreateNestedManyWithoutTermInput;
  periodicAttendances?: Prisma.PeriodicAttendanceCreateNestedManyWithoutTermInput;
};

export type TermUncheckedCreateInput = {
  id?: string;
  name: string;
  schoolYearId: string;
  order: number;
  startDate?: Date | string;
  endDate?: Date | string;
  isActive?: boolean | null;
  observation?: string | null;
  schoolId: string;
  gradeSheets?: Prisma.GradeSheetUncheckedCreateNestedManyWithoutTermInput;
  reportCards?: Prisma.ReportCardUncheckedCreateNestedManyWithoutTermInput;
  assignments?: Prisma.AssignmentUncheckedCreateNestedManyWithoutTermInput;
  absences?: Prisma.AbsenceUncheckedCreateNestedManyWithoutTermInput;
  latenesses?: Prisma.LatenessUncheckedCreateNestedManyWithoutTermInput;
  exclusions?: Prisma.ExclusionUncheckedCreateNestedManyWithoutTermInput;
  consignes?: Prisma.ConsigneUncheckedCreateNestedManyWithoutTermInput;
  chatters?: Prisma.ChatterUncheckedCreateNestedManyWithoutTermInput;
  convocations?: Prisma.ConvocationUncheckedCreateNestedManyWithoutTermInput;
  periodicAttendances?: Prisma.PeriodicAttendanceUncheckedCreateNestedManyWithoutTermInput;
};

export type TermUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  name?: Prisma.StringFieldUpdateOperationsInput | string;
  order?: Prisma.IntFieldUpdateOperationsInput | number;
  startDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  endDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  isActive?: Prisma.NullableBoolFieldUpdateOperationsInput | boolean | null;
  observation?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  gradeSheets?: Prisma.GradeSheetUpdateManyWithoutTermNestedInput;
  schoolYear?: Prisma.SchoolYearUpdateOneRequiredWithoutTermsNestedInput;
  reportCards?: Prisma.ReportCardUpdateManyWithoutTermNestedInput;
  assignments?: Prisma.AssignmentUpdateManyWithoutTermNestedInput;
  School?: Prisma.SchoolUpdateOneRequiredWithoutTermsNestedInput;
  absences?: Prisma.AbsenceUpdateManyWithoutTermNestedInput;
  latenesses?: Prisma.LatenessUpdateManyWithoutTermNestedInput;
  exclusions?: Prisma.ExclusionUpdateManyWithoutTermNestedInput;
  consignes?: Prisma.ConsigneUpdateManyWithoutTermNestedInput;
  chatters?: Prisma.ChatterUpdateManyWithoutTermNestedInput;
  convocations?: Prisma.ConvocationUpdateManyWithoutTermNestedInput;
  periodicAttendances?: Prisma.PeriodicAttendanceUpdateManyWithoutTermNestedInput;
};

export type TermUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  name?: Prisma.StringFieldUpdateOperationsInput | string;
  schoolYearId?: Prisma.StringFieldUpdateOperationsInput | string;
  order?: Prisma.IntFieldUpdateOperationsInput | number;
  startDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  endDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  isActive?: Prisma.NullableBoolFieldUpdateOperationsInput | boolean | null;
  observation?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  schoolId?: Prisma.StringFieldUpdateOperationsInput | string;
  gradeSheets?: Prisma.GradeSheetUncheckedUpdateManyWithoutTermNestedInput;
  reportCards?: Prisma.ReportCardUncheckedUpdateManyWithoutTermNestedInput;
  assignments?: Prisma.AssignmentUncheckedUpdateManyWithoutTermNestedInput;
  absences?: Prisma.AbsenceUncheckedUpdateManyWithoutTermNestedInput;
  latenesses?: Prisma.LatenessUncheckedUpdateManyWithoutTermNestedInput;
  exclusions?: Prisma.ExclusionUncheckedUpdateManyWithoutTermNestedInput;
  consignes?: Prisma.ConsigneUncheckedUpdateManyWithoutTermNestedInput;
  chatters?: Prisma.ChatterUncheckedUpdateManyWithoutTermNestedInput;
  convocations?: Prisma.ConvocationUncheckedUpdateManyWithoutTermNestedInput;
  periodicAttendances?: Prisma.PeriodicAttendanceUncheckedUpdateManyWithoutTermNestedInput;
};

export type TermCreateManyInput = {
  id?: string;
  name: string;
  schoolYearId: string;
  order: number;
  startDate?: Date | string;
  endDate?: Date | string;
  isActive?: boolean | null;
  observation?: string | null;
  schoolId: string;
};

export type TermUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  name?: Prisma.StringFieldUpdateOperationsInput | string;
  order?: Prisma.IntFieldUpdateOperationsInput | number;
  startDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  endDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  isActive?: Prisma.NullableBoolFieldUpdateOperationsInput | boolean | null;
  observation?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
};

export type TermUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  name?: Prisma.StringFieldUpdateOperationsInput | string;
  schoolYearId?: Prisma.StringFieldUpdateOperationsInput | string;
  order?: Prisma.IntFieldUpdateOperationsInput | number;
  startDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  endDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  isActive?: Prisma.NullableBoolFieldUpdateOperationsInput | boolean | null;
  observation?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  schoolId?: Prisma.StringFieldUpdateOperationsInput | string;
};

export type TermScalarRelationFilter = {
  is?: Prisma.TermWhereInput;
  isNot?: Prisma.TermWhereInput;
};

export type TermCountOrderByAggregateInput = {
  id?: Prisma.SortOrder;
  name?: Prisma.SortOrder;
  schoolYearId?: Prisma.SortOrder;
  order?: Prisma.SortOrder;
  startDate?: Prisma.SortOrder;
  endDate?: Prisma.SortOrder;
  isActive?: Prisma.SortOrder;
  observation?: Prisma.SortOrder;
  schoolId?: Prisma.SortOrder;
};

export type TermAvgOrderByAggregateInput = {
  order?: Prisma.SortOrder;
};

export type TermMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder;
  name?: Prisma.SortOrder;
  schoolYearId?: Prisma.SortOrder;
  order?: Prisma.SortOrder;
  startDate?: Prisma.SortOrder;
  endDate?: Prisma.SortOrder;
  isActive?: Prisma.SortOrder;
  observation?: Prisma.SortOrder;
  schoolId?: Prisma.SortOrder;
};

export type TermMinOrderByAggregateInput = {
  id?: Prisma.SortOrder;
  name?: Prisma.SortOrder;
  schoolYearId?: Prisma.SortOrder;
  order?: Prisma.SortOrder;
  startDate?: Prisma.SortOrder;
  endDate?: Prisma.SortOrder;
  isActive?: Prisma.SortOrder;
  observation?: Prisma.SortOrder;
  schoolId?: Prisma.SortOrder;
};

export type TermSumOrderByAggregateInput = {
  order?: Prisma.SortOrder;
};

export type TermListRelationFilter = {
  every?: Prisma.TermWhereInput;
  some?: Prisma.TermWhereInput;
  none?: Prisma.TermWhereInput;
};

export type TermOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder;
};

export type TermCreateNestedOneWithoutAbsencesInput = {
  create?: Prisma.XOR<
    Prisma.TermCreateWithoutAbsencesInput,
    Prisma.TermUncheckedCreateWithoutAbsencesInput
  >;
  connectOrCreate?: Prisma.TermCreateOrConnectWithoutAbsencesInput;
  connect?: Prisma.TermWhereUniqueInput;
};

export type TermUpdateOneRequiredWithoutAbsencesNestedInput = {
  create?: Prisma.XOR<
    Prisma.TermCreateWithoutAbsencesInput,
    Prisma.TermUncheckedCreateWithoutAbsencesInput
  >;
  connectOrCreate?: Prisma.TermCreateOrConnectWithoutAbsencesInput;
  upsert?: Prisma.TermUpsertWithoutAbsencesInput;
  connect?: Prisma.TermWhereUniqueInput;
  update?: Prisma.XOR<
    Prisma.XOR<
      Prisma.TermUpdateToOneWithWhereWithoutAbsencesInput,
      Prisma.TermUpdateWithoutAbsencesInput
    >,
    Prisma.TermUncheckedUpdateWithoutAbsencesInput
  >;
};

export type TermCreateNestedOneWithoutLatenessesInput = {
  create?: Prisma.XOR<
    Prisma.TermCreateWithoutLatenessesInput,
    Prisma.TermUncheckedCreateWithoutLatenessesInput
  >;
  connectOrCreate?: Prisma.TermCreateOrConnectWithoutLatenessesInput;
  connect?: Prisma.TermWhereUniqueInput;
};

export type TermUpdateOneRequiredWithoutLatenessesNestedInput = {
  create?: Prisma.XOR<
    Prisma.TermCreateWithoutLatenessesInput,
    Prisma.TermUncheckedCreateWithoutLatenessesInput
  >;
  connectOrCreate?: Prisma.TermCreateOrConnectWithoutLatenessesInput;
  upsert?: Prisma.TermUpsertWithoutLatenessesInput;
  connect?: Prisma.TermWhereUniqueInput;
  update?: Prisma.XOR<
    Prisma.XOR<
      Prisma.TermUpdateToOneWithWhereWithoutLatenessesInput,
      Prisma.TermUpdateWithoutLatenessesInput
    >,
    Prisma.TermUncheckedUpdateWithoutLatenessesInput
  >;
};

export type TermCreateNestedOneWithoutChattersInput = {
  create?: Prisma.XOR<
    Prisma.TermCreateWithoutChattersInput,
    Prisma.TermUncheckedCreateWithoutChattersInput
  >;
  connectOrCreate?: Prisma.TermCreateOrConnectWithoutChattersInput;
  connect?: Prisma.TermWhereUniqueInput;
};

export type TermUpdateOneRequiredWithoutChattersNestedInput = {
  create?: Prisma.XOR<
    Prisma.TermCreateWithoutChattersInput,
    Prisma.TermUncheckedCreateWithoutChattersInput
  >;
  connectOrCreate?: Prisma.TermCreateOrConnectWithoutChattersInput;
  upsert?: Prisma.TermUpsertWithoutChattersInput;
  connect?: Prisma.TermWhereUniqueInput;
  update?: Prisma.XOR<
    Prisma.XOR<
      Prisma.TermUpdateToOneWithWhereWithoutChattersInput,
      Prisma.TermUpdateWithoutChattersInput
    >,
    Prisma.TermUncheckedUpdateWithoutChattersInput
  >;
};

export type TermCreateNestedOneWithoutConsignesInput = {
  create?: Prisma.XOR<
    Prisma.TermCreateWithoutConsignesInput,
    Prisma.TermUncheckedCreateWithoutConsignesInput
  >;
  connectOrCreate?: Prisma.TermCreateOrConnectWithoutConsignesInput;
  connect?: Prisma.TermWhereUniqueInput;
};

export type TermUpdateOneRequiredWithoutConsignesNestedInput = {
  create?: Prisma.XOR<
    Prisma.TermCreateWithoutConsignesInput,
    Prisma.TermUncheckedCreateWithoutConsignesInput
  >;
  connectOrCreate?: Prisma.TermCreateOrConnectWithoutConsignesInput;
  upsert?: Prisma.TermUpsertWithoutConsignesInput;
  connect?: Prisma.TermWhereUniqueInput;
  update?: Prisma.XOR<
    Prisma.XOR<
      Prisma.TermUpdateToOneWithWhereWithoutConsignesInput,
      Prisma.TermUpdateWithoutConsignesInput
    >,
    Prisma.TermUncheckedUpdateWithoutConsignesInput
  >;
};

export type TermCreateNestedOneWithoutExclusionsInput = {
  create?: Prisma.XOR<
    Prisma.TermCreateWithoutExclusionsInput,
    Prisma.TermUncheckedCreateWithoutExclusionsInput
  >;
  connectOrCreate?: Prisma.TermCreateOrConnectWithoutExclusionsInput;
  connect?: Prisma.TermWhereUniqueInput;
};

export type TermUpdateOneRequiredWithoutExclusionsNestedInput = {
  create?: Prisma.XOR<
    Prisma.TermCreateWithoutExclusionsInput,
    Prisma.TermUncheckedCreateWithoutExclusionsInput
  >;
  connectOrCreate?: Prisma.TermCreateOrConnectWithoutExclusionsInput;
  upsert?: Prisma.TermUpsertWithoutExclusionsInput;
  connect?: Prisma.TermWhereUniqueInput;
  update?: Prisma.XOR<
    Prisma.XOR<
      Prisma.TermUpdateToOneWithWhereWithoutExclusionsInput,
      Prisma.TermUpdateWithoutExclusionsInput
    >,
    Prisma.TermUncheckedUpdateWithoutExclusionsInput
  >;
};

export type TermCreateNestedOneWithoutConvocationsInput = {
  create?: Prisma.XOR<
    Prisma.TermCreateWithoutConvocationsInput,
    Prisma.TermUncheckedCreateWithoutConvocationsInput
  >;
  connectOrCreate?: Prisma.TermCreateOrConnectWithoutConvocationsInput;
  connect?: Prisma.TermWhereUniqueInput;
};

export type TermUpdateOneRequiredWithoutConvocationsNestedInput = {
  create?: Prisma.XOR<
    Prisma.TermCreateWithoutConvocationsInput,
    Prisma.TermUncheckedCreateWithoutConvocationsInput
  >;
  connectOrCreate?: Prisma.TermCreateOrConnectWithoutConvocationsInput;
  upsert?: Prisma.TermUpsertWithoutConvocationsInput;
  connect?: Prisma.TermWhereUniqueInput;
  update?: Prisma.XOR<
    Prisma.XOR<
      Prisma.TermUpdateToOneWithWhereWithoutConvocationsInput,
      Prisma.TermUpdateWithoutConvocationsInput
    >,
    Prisma.TermUncheckedUpdateWithoutConvocationsInput
  >;
};

export type TermCreateNestedOneWithoutPeriodicAttendancesInput = {
  create?: Prisma.XOR<
    Prisma.TermCreateWithoutPeriodicAttendancesInput,
    Prisma.TermUncheckedCreateWithoutPeriodicAttendancesInput
  >;
  connectOrCreate?: Prisma.TermCreateOrConnectWithoutPeriodicAttendancesInput;
  connect?: Prisma.TermWhereUniqueInput;
};

export type TermUpdateOneRequiredWithoutPeriodicAttendancesNestedInput = {
  create?: Prisma.XOR<
    Prisma.TermCreateWithoutPeriodicAttendancesInput,
    Prisma.TermUncheckedCreateWithoutPeriodicAttendancesInput
  >;
  connectOrCreate?: Prisma.TermCreateOrConnectWithoutPeriodicAttendancesInput;
  upsert?: Prisma.TermUpsertWithoutPeriodicAttendancesInput;
  connect?: Prisma.TermWhereUniqueInput;
  update?: Prisma.XOR<
    Prisma.XOR<
      Prisma.TermUpdateToOneWithWhereWithoutPeriodicAttendancesInput,
      Prisma.TermUpdateWithoutPeriodicAttendancesInput
    >,
    Prisma.TermUncheckedUpdateWithoutPeriodicAttendancesInput
  >;
};

export type TermCreateNestedOneWithoutReportCardsInput = {
  create?: Prisma.XOR<
    Prisma.TermCreateWithoutReportCardsInput,
    Prisma.TermUncheckedCreateWithoutReportCardsInput
  >;
  connectOrCreate?: Prisma.TermCreateOrConnectWithoutReportCardsInput;
  connect?: Prisma.TermWhereUniqueInput;
};

export type TermUpdateOneRequiredWithoutReportCardsNestedInput = {
  create?: Prisma.XOR<
    Prisma.TermCreateWithoutReportCardsInput,
    Prisma.TermUncheckedCreateWithoutReportCardsInput
  >;
  connectOrCreate?: Prisma.TermCreateOrConnectWithoutReportCardsInput;
  upsert?: Prisma.TermUpsertWithoutReportCardsInput;
  connect?: Prisma.TermWhereUniqueInput;
  update?: Prisma.XOR<
    Prisma.XOR<
      Prisma.TermUpdateToOneWithWhereWithoutReportCardsInput,
      Prisma.TermUpdateWithoutReportCardsInput
    >,
    Prisma.TermUncheckedUpdateWithoutReportCardsInput
  >;
};

export type TermCreateNestedOneWithoutGradeSheetsInput = {
  create?: Prisma.XOR<
    Prisma.TermCreateWithoutGradeSheetsInput,
    Prisma.TermUncheckedCreateWithoutGradeSheetsInput
  >;
  connectOrCreate?: Prisma.TermCreateOrConnectWithoutGradeSheetsInput;
  connect?: Prisma.TermWhereUniqueInput;
};

export type TermUpdateOneRequiredWithoutGradeSheetsNestedInput = {
  create?: Prisma.XOR<
    Prisma.TermCreateWithoutGradeSheetsInput,
    Prisma.TermUncheckedCreateWithoutGradeSheetsInput
  >;
  connectOrCreate?: Prisma.TermCreateOrConnectWithoutGradeSheetsInput;
  upsert?: Prisma.TermUpsertWithoutGradeSheetsInput;
  connect?: Prisma.TermWhereUniqueInput;
  update?: Prisma.XOR<
    Prisma.XOR<
      Prisma.TermUpdateToOneWithWhereWithoutGradeSheetsInput,
      Prisma.TermUpdateWithoutGradeSheetsInput
    >,
    Prisma.TermUncheckedUpdateWithoutGradeSheetsInput
  >;
};

export type TermCreateNestedOneWithoutAssignmentsInput = {
  create?: Prisma.XOR<
    Prisma.TermCreateWithoutAssignmentsInput,
    Prisma.TermUncheckedCreateWithoutAssignmentsInput
  >;
  connectOrCreate?: Prisma.TermCreateOrConnectWithoutAssignmentsInput;
  connect?: Prisma.TermWhereUniqueInput;
};

export type TermUpdateOneRequiredWithoutAssignmentsNestedInput = {
  create?: Prisma.XOR<
    Prisma.TermCreateWithoutAssignmentsInput,
    Prisma.TermUncheckedCreateWithoutAssignmentsInput
  >;
  connectOrCreate?: Prisma.TermCreateOrConnectWithoutAssignmentsInput;
  upsert?: Prisma.TermUpsertWithoutAssignmentsInput;
  connect?: Prisma.TermWhereUniqueInput;
  update?: Prisma.XOR<
    Prisma.XOR<
      Prisma.TermUpdateToOneWithWhereWithoutAssignmentsInput,
      Prisma.TermUpdateWithoutAssignmentsInput
    >,
    Prisma.TermUncheckedUpdateWithoutAssignmentsInput
  >;
};

export type TermCreateNestedManyWithoutSchoolInput = {
  create?:
    | Prisma.XOR<
        Prisma.TermCreateWithoutSchoolInput,
        Prisma.TermUncheckedCreateWithoutSchoolInput
      >
    | Prisma.TermCreateWithoutSchoolInput[]
    | Prisma.TermUncheckedCreateWithoutSchoolInput[];
  connectOrCreate?:
    | Prisma.TermCreateOrConnectWithoutSchoolInput
    | Prisma.TermCreateOrConnectWithoutSchoolInput[];
  createMany?: Prisma.TermCreateManySchoolInputEnvelope;
  connect?: Prisma.TermWhereUniqueInput | Prisma.TermWhereUniqueInput[];
};

export type TermUncheckedCreateNestedManyWithoutSchoolInput = {
  create?:
    | Prisma.XOR<
        Prisma.TermCreateWithoutSchoolInput,
        Prisma.TermUncheckedCreateWithoutSchoolInput
      >
    | Prisma.TermCreateWithoutSchoolInput[]
    | Prisma.TermUncheckedCreateWithoutSchoolInput[];
  connectOrCreate?:
    | Prisma.TermCreateOrConnectWithoutSchoolInput
    | Prisma.TermCreateOrConnectWithoutSchoolInput[];
  createMany?: Prisma.TermCreateManySchoolInputEnvelope;
  connect?: Prisma.TermWhereUniqueInput | Prisma.TermWhereUniqueInput[];
};

export type TermUpdateManyWithoutSchoolNestedInput = {
  create?:
    | Prisma.XOR<
        Prisma.TermCreateWithoutSchoolInput,
        Prisma.TermUncheckedCreateWithoutSchoolInput
      >
    | Prisma.TermCreateWithoutSchoolInput[]
    | Prisma.TermUncheckedCreateWithoutSchoolInput[];
  connectOrCreate?:
    | Prisma.TermCreateOrConnectWithoutSchoolInput
    | Prisma.TermCreateOrConnectWithoutSchoolInput[];
  upsert?:
    | Prisma.TermUpsertWithWhereUniqueWithoutSchoolInput
    | Prisma.TermUpsertWithWhereUniqueWithoutSchoolInput[];
  createMany?: Prisma.TermCreateManySchoolInputEnvelope;
  set?: Prisma.TermWhereUniqueInput | Prisma.TermWhereUniqueInput[];
  disconnect?: Prisma.TermWhereUniqueInput | Prisma.TermWhereUniqueInput[];
  delete?: Prisma.TermWhereUniqueInput | Prisma.TermWhereUniqueInput[];
  connect?: Prisma.TermWhereUniqueInput | Prisma.TermWhereUniqueInput[];
  update?:
    | Prisma.TermUpdateWithWhereUniqueWithoutSchoolInput
    | Prisma.TermUpdateWithWhereUniqueWithoutSchoolInput[];
  updateMany?:
    | Prisma.TermUpdateManyWithWhereWithoutSchoolInput
    | Prisma.TermUpdateManyWithWhereWithoutSchoolInput[];
  deleteMany?: Prisma.TermScalarWhereInput | Prisma.TermScalarWhereInput[];
};

export type TermUncheckedUpdateManyWithoutSchoolNestedInput = {
  create?:
    | Prisma.XOR<
        Prisma.TermCreateWithoutSchoolInput,
        Prisma.TermUncheckedCreateWithoutSchoolInput
      >
    | Prisma.TermCreateWithoutSchoolInput[]
    | Prisma.TermUncheckedCreateWithoutSchoolInput[];
  connectOrCreate?:
    | Prisma.TermCreateOrConnectWithoutSchoolInput
    | Prisma.TermCreateOrConnectWithoutSchoolInput[];
  upsert?:
    | Prisma.TermUpsertWithWhereUniqueWithoutSchoolInput
    | Prisma.TermUpsertWithWhereUniqueWithoutSchoolInput[];
  createMany?: Prisma.TermCreateManySchoolInputEnvelope;
  set?: Prisma.TermWhereUniqueInput | Prisma.TermWhereUniqueInput[];
  disconnect?: Prisma.TermWhereUniqueInput | Prisma.TermWhereUniqueInput[];
  delete?: Prisma.TermWhereUniqueInput | Prisma.TermWhereUniqueInput[];
  connect?: Prisma.TermWhereUniqueInput | Prisma.TermWhereUniqueInput[];
  update?:
    | Prisma.TermUpdateWithWhereUniqueWithoutSchoolInput
    | Prisma.TermUpdateWithWhereUniqueWithoutSchoolInput[];
  updateMany?:
    | Prisma.TermUpdateManyWithWhereWithoutSchoolInput
    | Prisma.TermUpdateManyWithWhereWithoutSchoolInput[];
  deleteMany?: Prisma.TermScalarWhereInput | Prisma.TermScalarWhereInput[];
};

export type TermCreateNestedManyWithoutSchoolYearInput = {
  create?:
    | Prisma.XOR<
        Prisma.TermCreateWithoutSchoolYearInput,
        Prisma.TermUncheckedCreateWithoutSchoolYearInput
      >
    | Prisma.TermCreateWithoutSchoolYearInput[]
    | Prisma.TermUncheckedCreateWithoutSchoolYearInput[];
  connectOrCreate?:
    | Prisma.TermCreateOrConnectWithoutSchoolYearInput
    | Prisma.TermCreateOrConnectWithoutSchoolYearInput[];
  createMany?: Prisma.TermCreateManySchoolYearInputEnvelope;
  connect?: Prisma.TermWhereUniqueInput | Prisma.TermWhereUniqueInput[];
};

export type TermUncheckedCreateNestedManyWithoutSchoolYearInput = {
  create?:
    | Prisma.XOR<
        Prisma.TermCreateWithoutSchoolYearInput,
        Prisma.TermUncheckedCreateWithoutSchoolYearInput
      >
    | Prisma.TermCreateWithoutSchoolYearInput[]
    | Prisma.TermUncheckedCreateWithoutSchoolYearInput[];
  connectOrCreate?:
    | Prisma.TermCreateOrConnectWithoutSchoolYearInput
    | Prisma.TermCreateOrConnectWithoutSchoolYearInput[];
  createMany?: Prisma.TermCreateManySchoolYearInputEnvelope;
  connect?: Prisma.TermWhereUniqueInput | Prisma.TermWhereUniqueInput[];
};

export type TermUpdateManyWithoutSchoolYearNestedInput = {
  create?:
    | Prisma.XOR<
        Prisma.TermCreateWithoutSchoolYearInput,
        Prisma.TermUncheckedCreateWithoutSchoolYearInput
      >
    | Prisma.TermCreateWithoutSchoolYearInput[]
    | Prisma.TermUncheckedCreateWithoutSchoolYearInput[];
  connectOrCreate?:
    | Prisma.TermCreateOrConnectWithoutSchoolYearInput
    | Prisma.TermCreateOrConnectWithoutSchoolYearInput[];
  upsert?:
    | Prisma.TermUpsertWithWhereUniqueWithoutSchoolYearInput
    | Prisma.TermUpsertWithWhereUniqueWithoutSchoolYearInput[];
  createMany?: Prisma.TermCreateManySchoolYearInputEnvelope;
  set?: Prisma.TermWhereUniqueInput | Prisma.TermWhereUniqueInput[];
  disconnect?: Prisma.TermWhereUniqueInput | Prisma.TermWhereUniqueInput[];
  delete?: Prisma.TermWhereUniqueInput | Prisma.TermWhereUniqueInput[];
  connect?: Prisma.TermWhereUniqueInput | Prisma.TermWhereUniqueInput[];
  update?:
    | Prisma.TermUpdateWithWhereUniqueWithoutSchoolYearInput
    | Prisma.TermUpdateWithWhereUniqueWithoutSchoolYearInput[];
  updateMany?:
    | Prisma.TermUpdateManyWithWhereWithoutSchoolYearInput
    | Prisma.TermUpdateManyWithWhereWithoutSchoolYearInput[];
  deleteMany?: Prisma.TermScalarWhereInput | Prisma.TermScalarWhereInput[];
};

export type TermUncheckedUpdateManyWithoutSchoolYearNestedInput = {
  create?:
    | Prisma.XOR<
        Prisma.TermCreateWithoutSchoolYearInput,
        Prisma.TermUncheckedCreateWithoutSchoolYearInput
      >
    | Prisma.TermCreateWithoutSchoolYearInput[]
    | Prisma.TermUncheckedCreateWithoutSchoolYearInput[];
  connectOrCreate?:
    | Prisma.TermCreateOrConnectWithoutSchoolYearInput
    | Prisma.TermCreateOrConnectWithoutSchoolYearInput[];
  upsert?:
    | Prisma.TermUpsertWithWhereUniqueWithoutSchoolYearInput
    | Prisma.TermUpsertWithWhereUniqueWithoutSchoolYearInput[];
  createMany?: Prisma.TermCreateManySchoolYearInputEnvelope;
  set?: Prisma.TermWhereUniqueInput | Prisma.TermWhereUniqueInput[];
  disconnect?: Prisma.TermWhereUniqueInput | Prisma.TermWhereUniqueInput[];
  delete?: Prisma.TermWhereUniqueInput | Prisma.TermWhereUniqueInput[];
  connect?: Prisma.TermWhereUniqueInput | Prisma.TermWhereUniqueInput[];
  update?:
    | Prisma.TermUpdateWithWhereUniqueWithoutSchoolYearInput
    | Prisma.TermUpdateWithWhereUniqueWithoutSchoolYearInput[];
  updateMany?:
    | Prisma.TermUpdateManyWithWhereWithoutSchoolYearInput
    | Prisma.TermUpdateManyWithWhereWithoutSchoolYearInput[];
  deleteMany?: Prisma.TermScalarWhereInput | Prisma.TermScalarWhereInput[];
};

export type TermCreateWithoutAbsencesInput = {
  id?: string;
  name: string;
  order: number;
  startDate?: Date | string;
  endDate?: Date | string;
  isActive?: boolean | null;
  observation?: string | null;
  gradeSheets?: Prisma.GradeSheetCreateNestedManyWithoutTermInput;
  schoolYear: Prisma.SchoolYearCreateNestedOneWithoutTermsInput;
  reportCards?: Prisma.ReportCardCreateNestedManyWithoutTermInput;
  assignments?: Prisma.AssignmentCreateNestedManyWithoutTermInput;
  School: Prisma.SchoolCreateNestedOneWithoutTermsInput;
  latenesses?: Prisma.LatenessCreateNestedManyWithoutTermInput;
  exclusions?: Prisma.ExclusionCreateNestedManyWithoutTermInput;
  consignes?: Prisma.ConsigneCreateNestedManyWithoutTermInput;
  chatters?: Prisma.ChatterCreateNestedManyWithoutTermInput;
  convocations?: Prisma.ConvocationCreateNestedManyWithoutTermInput;
  periodicAttendances?: Prisma.PeriodicAttendanceCreateNestedManyWithoutTermInput;
};

export type TermUncheckedCreateWithoutAbsencesInput = {
  id?: string;
  name: string;
  schoolYearId: string;
  order: number;
  startDate?: Date | string;
  endDate?: Date | string;
  isActive?: boolean | null;
  observation?: string | null;
  schoolId: string;
  gradeSheets?: Prisma.GradeSheetUncheckedCreateNestedManyWithoutTermInput;
  reportCards?: Prisma.ReportCardUncheckedCreateNestedManyWithoutTermInput;
  assignments?: Prisma.AssignmentUncheckedCreateNestedManyWithoutTermInput;
  latenesses?: Prisma.LatenessUncheckedCreateNestedManyWithoutTermInput;
  exclusions?: Prisma.ExclusionUncheckedCreateNestedManyWithoutTermInput;
  consignes?: Prisma.ConsigneUncheckedCreateNestedManyWithoutTermInput;
  chatters?: Prisma.ChatterUncheckedCreateNestedManyWithoutTermInput;
  convocations?: Prisma.ConvocationUncheckedCreateNestedManyWithoutTermInput;
  periodicAttendances?: Prisma.PeriodicAttendanceUncheckedCreateNestedManyWithoutTermInput;
};

export type TermCreateOrConnectWithoutAbsencesInput = {
  where: Prisma.TermWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.TermCreateWithoutAbsencesInput,
    Prisma.TermUncheckedCreateWithoutAbsencesInput
  >;
};

export type TermUpsertWithoutAbsencesInput = {
  update: Prisma.XOR<
    Prisma.TermUpdateWithoutAbsencesInput,
    Prisma.TermUncheckedUpdateWithoutAbsencesInput
  >;
  create: Prisma.XOR<
    Prisma.TermCreateWithoutAbsencesInput,
    Prisma.TermUncheckedCreateWithoutAbsencesInput
  >;
  where?: Prisma.TermWhereInput;
};

export type TermUpdateToOneWithWhereWithoutAbsencesInput = {
  where?: Prisma.TermWhereInput;
  data: Prisma.XOR<
    Prisma.TermUpdateWithoutAbsencesInput,
    Prisma.TermUncheckedUpdateWithoutAbsencesInput
  >;
};

export type TermUpdateWithoutAbsencesInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  name?: Prisma.StringFieldUpdateOperationsInput | string;
  order?: Prisma.IntFieldUpdateOperationsInput | number;
  startDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  endDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  isActive?: Prisma.NullableBoolFieldUpdateOperationsInput | boolean | null;
  observation?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  gradeSheets?: Prisma.GradeSheetUpdateManyWithoutTermNestedInput;
  schoolYear?: Prisma.SchoolYearUpdateOneRequiredWithoutTermsNestedInput;
  reportCards?: Prisma.ReportCardUpdateManyWithoutTermNestedInput;
  assignments?: Prisma.AssignmentUpdateManyWithoutTermNestedInput;
  School?: Prisma.SchoolUpdateOneRequiredWithoutTermsNestedInput;
  latenesses?: Prisma.LatenessUpdateManyWithoutTermNestedInput;
  exclusions?: Prisma.ExclusionUpdateManyWithoutTermNestedInput;
  consignes?: Prisma.ConsigneUpdateManyWithoutTermNestedInput;
  chatters?: Prisma.ChatterUpdateManyWithoutTermNestedInput;
  convocations?: Prisma.ConvocationUpdateManyWithoutTermNestedInput;
  periodicAttendances?: Prisma.PeriodicAttendanceUpdateManyWithoutTermNestedInput;
};

export type TermUncheckedUpdateWithoutAbsencesInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  name?: Prisma.StringFieldUpdateOperationsInput | string;
  schoolYearId?: Prisma.StringFieldUpdateOperationsInput | string;
  order?: Prisma.IntFieldUpdateOperationsInput | number;
  startDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  endDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  isActive?: Prisma.NullableBoolFieldUpdateOperationsInput | boolean | null;
  observation?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  schoolId?: Prisma.StringFieldUpdateOperationsInput | string;
  gradeSheets?: Prisma.GradeSheetUncheckedUpdateManyWithoutTermNestedInput;
  reportCards?: Prisma.ReportCardUncheckedUpdateManyWithoutTermNestedInput;
  assignments?: Prisma.AssignmentUncheckedUpdateManyWithoutTermNestedInput;
  latenesses?: Prisma.LatenessUncheckedUpdateManyWithoutTermNestedInput;
  exclusions?: Prisma.ExclusionUncheckedUpdateManyWithoutTermNestedInput;
  consignes?: Prisma.ConsigneUncheckedUpdateManyWithoutTermNestedInput;
  chatters?: Prisma.ChatterUncheckedUpdateManyWithoutTermNestedInput;
  convocations?: Prisma.ConvocationUncheckedUpdateManyWithoutTermNestedInput;
  periodicAttendances?: Prisma.PeriodicAttendanceUncheckedUpdateManyWithoutTermNestedInput;
};

export type TermCreateWithoutLatenessesInput = {
  id?: string;
  name: string;
  order: number;
  startDate?: Date | string;
  endDate?: Date | string;
  isActive?: boolean | null;
  observation?: string | null;
  gradeSheets?: Prisma.GradeSheetCreateNestedManyWithoutTermInput;
  schoolYear: Prisma.SchoolYearCreateNestedOneWithoutTermsInput;
  reportCards?: Prisma.ReportCardCreateNestedManyWithoutTermInput;
  assignments?: Prisma.AssignmentCreateNestedManyWithoutTermInput;
  School: Prisma.SchoolCreateNestedOneWithoutTermsInput;
  absences?: Prisma.AbsenceCreateNestedManyWithoutTermInput;
  exclusions?: Prisma.ExclusionCreateNestedManyWithoutTermInput;
  consignes?: Prisma.ConsigneCreateNestedManyWithoutTermInput;
  chatters?: Prisma.ChatterCreateNestedManyWithoutTermInput;
  convocations?: Prisma.ConvocationCreateNestedManyWithoutTermInput;
  periodicAttendances?: Prisma.PeriodicAttendanceCreateNestedManyWithoutTermInput;
};

export type TermUncheckedCreateWithoutLatenessesInput = {
  id?: string;
  name: string;
  schoolYearId: string;
  order: number;
  startDate?: Date | string;
  endDate?: Date | string;
  isActive?: boolean | null;
  observation?: string | null;
  schoolId: string;
  gradeSheets?: Prisma.GradeSheetUncheckedCreateNestedManyWithoutTermInput;
  reportCards?: Prisma.ReportCardUncheckedCreateNestedManyWithoutTermInput;
  assignments?: Prisma.AssignmentUncheckedCreateNestedManyWithoutTermInput;
  absences?: Prisma.AbsenceUncheckedCreateNestedManyWithoutTermInput;
  exclusions?: Prisma.ExclusionUncheckedCreateNestedManyWithoutTermInput;
  consignes?: Prisma.ConsigneUncheckedCreateNestedManyWithoutTermInput;
  chatters?: Prisma.ChatterUncheckedCreateNestedManyWithoutTermInput;
  convocations?: Prisma.ConvocationUncheckedCreateNestedManyWithoutTermInput;
  periodicAttendances?: Prisma.PeriodicAttendanceUncheckedCreateNestedManyWithoutTermInput;
};

export type TermCreateOrConnectWithoutLatenessesInput = {
  where: Prisma.TermWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.TermCreateWithoutLatenessesInput,
    Prisma.TermUncheckedCreateWithoutLatenessesInput
  >;
};

export type TermUpsertWithoutLatenessesInput = {
  update: Prisma.XOR<
    Prisma.TermUpdateWithoutLatenessesInput,
    Prisma.TermUncheckedUpdateWithoutLatenessesInput
  >;
  create: Prisma.XOR<
    Prisma.TermCreateWithoutLatenessesInput,
    Prisma.TermUncheckedCreateWithoutLatenessesInput
  >;
  where?: Prisma.TermWhereInput;
};

export type TermUpdateToOneWithWhereWithoutLatenessesInput = {
  where?: Prisma.TermWhereInput;
  data: Prisma.XOR<
    Prisma.TermUpdateWithoutLatenessesInput,
    Prisma.TermUncheckedUpdateWithoutLatenessesInput
  >;
};

export type TermUpdateWithoutLatenessesInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  name?: Prisma.StringFieldUpdateOperationsInput | string;
  order?: Prisma.IntFieldUpdateOperationsInput | number;
  startDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  endDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  isActive?: Prisma.NullableBoolFieldUpdateOperationsInput | boolean | null;
  observation?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  gradeSheets?: Prisma.GradeSheetUpdateManyWithoutTermNestedInput;
  schoolYear?: Prisma.SchoolYearUpdateOneRequiredWithoutTermsNestedInput;
  reportCards?: Prisma.ReportCardUpdateManyWithoutTermNestedInput;
  assignments?: Prisma.AssignmentUpdateManyWithoutTermNestedInput;
  School?: Prisma.SchoolUpdateOneRequiredWithoutTermsNestedInput;
  absences?: Prisma.AbsenceUpdateManyWithoutTermNestedInput;
  exclusions?: Prisma.ExclusionUpdateManyWithoutTermNestedInput;
  consignes?: Prisma.ConsigneUpdateManyWithoutTermNestedInput;
  chatters?: Prisma.ChatterUpdateManyWithoutTermNestedInput;
  convocations?: Prisma.ConvocationUpdateManyWithoutTermNestedInput;
  periodicAttendances?: Prisma.PeriodicAttendanceUpdateManyWithoutTermNestedInput;
};

export type TermUncheckedUpdateWithoutLatenessesInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  name?: Prisma.StringFieldUpdateOperationsInput | string;
  schoolYearId?: Prisma.StringFieldUpdateOperationsInput | string;
  order?: Prisma.IntFieldUpdateOperationsInput | number;
  startDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  endDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  isActive?: Prisma.NullableBoolFieldUpdateOperationsInput | boolean | null;
  observation?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  schoolId?: Prisma.StringFieldUpdateOperationsInput | string;
  gradeSheets?: Prisma.GradeSheetUncheckedUpdateManyWithoutTermNestedInput;
  reportCards?: Prisma.ReportCardUncheckedUpdateManyWithoutTermNestedInput;
  assignments?: Prisma.AssignmentUncheckedUpdateManyWithoutTermNestedInput;
  absences?: Prisma.AbsenceUncheckedUpdateManyWithoutTermNestedInput;
  exclusions?: Prisma.ExclusionUncheckedUpdateManyWithoutTermNestedInput;
  consignes?: Prisma.ConsigneUncheckedUpdateManyWithoutTermNestedInput;
  chatters?: Prisma.ChatterUncheckedUpdateManyWithoutTermNestedInput;
  convocations?: Prisma.ConvocationUncheckedUpdateManyWithoutTermNestedInput;
  periodicAttendances?: Prisma.PeriodicAttendanceUncheckedUpdateManyWithoutTermNestedInput;
};

export type TermCreateWithoutChattersInput = {
  id?: string;
  name: string;
  order: number;
  startDate?: Date | string;
  endDate?: Date | string;
  isActive?: boolean | null;
  observation?: string | null;
  gradeSheets?: Prisma.GradeSheetCreateNestedManyWithoutTermInput;
  schoolYear: Prisma.SchoolYearCreateNestedOneWithoutTermsInput;
  reportCards?: Prisma.ReportCardCreateNestedManyWithoutTermInput;
  assignments?: Prisma.AssignmentCreateNestedManyWithoutTermInput;
  School: Prisma.SchoolCreateNestedOneWithoutTermsInput;
  absences?: Prisma.AbsenceCreateNestedManyWithoutTermInput;
  latenesses?: Prisma.LatenessCreateNestedManyWithoutTermInput;
  exclusions?: Prisma.ExclusionCreateNestedManyWithoutTermInput;
  consignes?: Prisma.ConsigneCreateNestedManyWithoutTermInput;
  convocations?: Prisma.ConvocationCreateNestedManyWithoutTermInput;
  periodicAttendances?: Prisma.PeriodicAttendanceCreateNestedManyWithoutTermInput;
};

export type TermUncheckedCreateWithoutChattersInput = {
  id?: string;
  name: string;
  schoolYearId: string;
  order: number;
  startDate?: Date | string;
  endDate?: Date | string;
  isActive?: boolean | null;
  observation?: string | null;
  schoolId: string;
  gradeSheets?: Prisma.GradeSheetUncheckedCreateNestedManyWithoutTermInput;
  reportCards?: Prisma.ReportCardUncheckedCreateNestedManyWithoutTermInput;
  assignments?: Prisma.AssignmentUncheckedCreateNestedManyWithoutTermInput;
  absences?: Prisma.AbsenceUncheckedCreateNestedManyWithoutTermInput;
  latenesses?: Prisma.LatenessUncheckedCreateNestedManyWithoutTermInput;
  exclusions?: Prisma.ExclusionUncheckedCreateNestedManyWithoutTermInput;
  consignes?: Prisma.ConsigneUncheckedCreateNestedManyWithoutTermInput;
  convocations?: Prisma.ConvocationUncheckedCreateNestedManyWithoutTermInput;
  periodicAttendances?: Prisma.PeriodicAttendanceUncheckedCreateNestedManyWithoutTermInput;
};

export type TermCreateOrConnectWithoutChattersInput = {
  where: Prisma.TermWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.TermCreateWithoutChattersInput,
    Prisma.TermUncheckedCreateWithoutChattersInput
  >;
};

export type TermUpsertWithoutChattersInput = {
  update: Prisma.XOR<
    Prisma.TermUpdateWithoutChattersInput,
    Prisma.TermUncheckedUpdateWithoutChattersInput
  >;
  create: Prisma.XOR<
    Prisma.TermCreateWithoutChattersInput,
    Prisma.TermUncheckedCreateWithoutChattersInput
  >;
  where?: Prisma.TermWhereInput;
};

export type TermUpdateToOneWithWhereWithoutChattersInput = {
  where?: Prisma.TermWhereInput;
  data: Prisma.XOR<
    Prisma.TermUpdateWithoutChattersInput,
    Prisma.TermUncheckedUpdateWithoutChattersInput
  >;
};

export type TermUpdateWithoutChattersInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  name?: Prisma.StringFieldUpdateOperationsInput | string;
  order?: Prisma.IntFieldUpdateOperationsInput | number;
  startDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  endDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  isActive?: Prisma.NullableBoolFieldUpdateOperationsInput | boolean | null;
  observation?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  gradeSheets?: Prisma.GradeSheetUpdateManyWithoutTermNestedInput;
  schoolYear?: Prisma.SchoolYearUpdateOneRequiredWithoutTermsNestedInput;
  reportCards?: Prisma.ReportCardUpdateManyWithoutTermNestedInput;
  assignments?: Prisma.AssignmentUpdateManyWithoutTermNestedInput;
  School?: Prisma.SchoolUpdateOneRequiredWithoutTermsNestedInput;
  absences?: Prisma.AbsenceUpdateManyWithoutTermNestedInput;
  latenesses?: Prisma.LatenessUpdateManyWithoutTermNestedInput;
  exclusions?: Prisma.ExclusionUpdateManyWithoutTermNestedInput;
  consignes?: Prisma.ConsigneUpdateManyWithoutTermNestedInput;
  convocations?: Prisma.ConvocationUpdateManyWithoutTermNestedInput;
  periodicAttendances?: Prisma.PeriodicAttendanceUpdateManyWithoutTermNestedInput;
};

export type TermUncheckedUpdateWithoutChattersInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  name?: Prisma.StringFieldUpdateOperationsInput | string;
  schoolYearId?: Prisma.StringFieldUpdateOperationsInput | string;
  order?: Prisma.IntFieldUpdateOperationsInput | number;
  startDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  endDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  isActive?: Prisma.NullableBoolFieldUpdateOperationsInput | boolean | null;
  observation?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  schoolId?: Prisma.StringFieldUpdateOperationsInput | string;
  gradeSheets?: Prisma.GradeSheetUncheckedUpdateManyWithoutTermNestedInput;
  reportCards?: Prisma.ReportCardUncheckedUpdateManyWithoutTermNestedInput;
  assignments?: Prisma.AssignmentUncheckedUpdateManyWithoutTermNestedInput;
  absences?: Prisma.AbsenceUncheckedUpdateManyWithoutTermNestedInput;
  latenesses?: Prisma.LatenessUncheckedUpdateManyWithoutTermNestedInput;
  exclusions?: Prisma.ExclusionUncheckedUpdateManyWithoutTermNestedInput;
  consignes?: Prisma.ConsigneUncheckedUpdateManyWithoutTermNestedInput;
  convocations?: Prisma.ConvocationUncheckedUpdateManyWithoutTermNestedInput;
  periodicAttendances?: Prisma.PeriodicAttendanceUncheckedUpdateManyWithoutTermNestedInput;
};

export type TermCreateWithoutConsignesInput = {
  id?: string;
  name: string;
  order: number;
  startDate?: Date | string;
  endDate?: Date | string;
  isActive?: boolean | null;
  observation?: string | null;
  gradeSheets?: Prisma.GradeSheetCreateNestedManyWithoutTermInput;
  schoolYear: Prisma.SchoolYearCreateNestedOneWithoutTermsInput;
  reportCards?: Prisma.ReportCardCreateNestedManyWithoutTermInput;
  assignments?: Prisma.AssignmentCreateNestedManyWithoutTermInput;
  School: Prisma.SchoolCreateNestedOneWithoutTermsInput;
  absences?: Prisma.AbsenceCreateNestedManyWithoutTermInput;
  latenesses?: Prisma.LatenessCreateNestedManyWithoutTermInput;
  exclusions?: Prisma.ExclusionCreateNestedManyWithoutTermInput;
  chatters?: Prisma.ChatterCreateNestedManyWithoutTermInput;
  convocations?: Prisma.ConvocationCreateNestedManyWithoutTermInput;
  periodicAttendances?: Prisma.PeriodicAttendanceCreateNestedManyWithoutTermInput;
};

export type TermUncheckedCreateWithoutConsignesInput = {
  id?: string;
  name: string;
  schoolYearId: string;
  order: number;
  startDate?: Date | string;
  endDate?: Date | string;
  isActive?: boolean | null;
  observation?: string | null;
  schoolId: string;
  gradeSheets?: Prisma.GradeSheetUncheckedCreateNestedManyWithoutTermInput;
  reportCards?: Prisma.ReportCardUncheckedCreateNestedManyWithoutTermInput;
  assignments?: Prisma.AssignmentUncheckedCreateNestedManyWithoutTermInput;
  absences?: Prisma.AbsenceUncheckedCreateNestedManyWithoutTermInput;
  latenesses?: Prisma.LatenessUncheckedCreateNestedManyWithoutTermInput;
  exclusions?: Prisma.ExclusionUncheckedCreateNestedManyWithoutTermInput;
  chatters?: Prisma.ChatterUncheckedCreateNestedManyWithoutTermInput;
  convocations?: Prisma.ConvocationUncheckedCreateNestedManyWithoutTermInput;
  periodicAttendances?: Prisma.PeriodicAttendanceUncheckedCreateNestedManyWithoutTermInput;
};

export type TermCreateOrConnectWithoutConsignesInput = {
  where: Prisma.TermWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.TermCreateWithoutConsignesInput,
    Prisma.TermUncheckedCreateWithoutConsignesInput
  >;
};

export type TermUpsertWithoutConsignesInput = {
  update: Prisma.XOR<
    Prisma.TermUpdateWithoutConsignesInput,
    Prisma.TermUncheckedUpdateWithoutConsignesInput
  >;
  create: Prisma.XOR<
    Prisma.TermCreateWithoutConsignesInput,
    Prisma.TermUncheckedCreateWithoutConsignesInput
  >;
  where?: Prisma.TermWhereInput;
};

export type TermUpdateToOneWithWhereWithoutConsignesInput = {
  where?: Prisma.TermWhereInput;
  data: Prisma.XOR<
    Prisma.TermUpdateWithoutConsignesInput,
    Prisma.TermUncheckedUpdateWithoutConsignesInput
  >;
};

export type TermUpdateWithoutConsignesInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  name?: Prisma.StringFieldUpdateOperationsInput | string;
  order?: Prisma.IntFieldUpdateOperationsInput | number;
  startDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  endDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  isActive?: Prisma.NullableBoolFieldUpdateOperationsInput | boolean | null;
  observation?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  gradeSheets?: Prisma.GradeSheetUpdateManyWithoutTermNestedInput;
  schoolYear?: Prisma.SchoolYearUpdateOneRequiredWithoutTermsNestedInput;
  reportCards?: Prisma.ReportCardUpdateManyWithoutTermNestedInput;
  assignments?: Prisma.AssignmentUpdateManyWithoutTermNestedInput;
  School?: Prisma.SchoolUpdateOneRequiredWithoutTermsNestedInput;
  absences?: Prisma.AbsenceUpdateManyWithoutTermNestedInput;
  latenesses?: Prisma.LatenessUpdateManyWithoutTermNestedInput;
  exclusions?: Prisma.ExclusionUpdateManyWithoutTermNestedInput;
  chatters?: Prisma.ChatterUpdateManyWithoutTermNestedInput;
  convocations?: Prisma.ConvocationUpdateManyWithoutTermNestedInput;
  periodicAttendances?: Prisma.PeriodicAttendanceUpdateManyWithoutTermNestedInput;
};

export type TermUncheckedUpdateWithoutConsignesInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  name?: Prisma.StringFieldUpdateOperationsInput | string;
  schoolYearId?: Prisma.StringFieldUpdateOperationsInput | string;
  order?: Prisma.IntFieldUpdateOperationsInput | number;
  startDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  endDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  isActive?: Prisma.NullableBoolFieldUpdateOperationsInput | boolean | null;
  observation?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  schoolId?: Prisma.StringFieldUpdateOperationsInput | string;
  gradeSheets?: Prisma.GradeSheetUncheckedUpdateManyWithoutTermNestedInput;
  reportCards?: Prisma.ReportCardUncheckedUpdateManyWithoutTermNestedInput;
  assignments?: Prisma.AssignmentUncheckedUpdateManyWithoutTermNestedInput;
  absences?: Prisma.AbsenceUncheckedUpdateManyWithoutTermNestedInput;
  latenesses?: Prisma.LatenessUncheckedUpdateManyWithoutTermNestedInput;
  exclusions?: Prisma.ExclusionUncheckedUpdateManyWithoutTermNestedInput;
  chatters?: Prisma.ChatterUncheckedUpdateManyWithoutTermNestedInput;
  convocations?: Prisma.ConvocationUncheckedUpdateManyWithoutTermNestedInput;
  periodicAttendances?: Prisma.PeriodicAttendanceUncheckedUpdateManyWithoutTermNestedInput;
};

export type TermCreateWithoutExclusionsInput = {
  id?: string;
  name: string;
  order: number;
  startDate?: Date | string;
  endDate?: Date | string;
  isActive?: boolean | null;
  observation?: string | null;
  gradeSheets?: Prisma.GradeSheetCreateNestedManyWithoutTermInput;
  schoolYear: Prisma.SchoolYearCreateNestedOneWithoutTermsInput;
  reportCards?: Prisma.ReportCardCreateNestedManyWithoutTermInput;
  assignments?: Prisma.AssignmentCreateNestedManyWithoutTermInput;
  School: Prisma.SchoolCreateNestedOneWithoutTermsInput;
  absences?: Prisma.AbsenceCreateNestedManyWithoutTermInput;
  latenesses?: Prisma.LatenessCreateNestedManyWithoutTermInput;
  consignes?: Prisma.ConsigneCreateNestedManyWithoutTermInput;
  chatters?: Prisma.ChatterCreateNestedManyWithoutTermInput;
  convocations?: Prisma.ConvocationCreateNestedManyWithoutTermInput;
  periodicAttendances?: Prisma.PeriodicAttendanceCreateNestedManyWithoutTermInput;
};

export type TermUncheckedCreateWithoutExclusionsInput = {
  id?: string;
  name: string;
  schoolYearId: string;
  order: number;
  startDate?: Date | string;
  endDate?: Date | string;
  isActive?: boolean | null;
  observation?: string | null;
  schoolId: string;
  gradeSheets?: Prisma.GradeSheetUncheckedCreateNestedManyWithoutTermInput;
  reportCards?: Prisma.ReportCardUncheckedCreateNestedManyWithoutTermInput;
  assignments?: Prisma.AssignmentUncheckedCreateNestedManyWithoutTermInput;
  absences?: Prisma.AbsenceUncheckedCreateNestedManyWithoutTermInput;
  latenesses?: Prisma.LatenessUncheckedCreateNestedManyWithoutTermInput;
  consignes?: Prisma.ConsigneUncheckedCreateNestedManyWithoutTermInput;
  chatters?: Prisma.ChatterUncheckedCreateNestedManyWithoutTermInput;
  convocations?: Prisma.ConvocationUncheckedCreateNestedManyWithoutTermInput;
  periodicAttendances?: Prisma.PeriodicAttendanceUncheckedCreateNestedManyWithoutTermInput;
};

export type TermCreateOrConnectWithoutExclusionsInput = {
  where: Prisma.TermWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.TermCreateWithoutExclusionsInput,
    Prisma.TermUncheckedCreateWithoutExclusionsInput
  >;
};

export type TermUpsertWithoutExclusionsInput = {
  update: Prisma.XOR<
    Prisma.TermUpdateWithoutExclusionsInput,
    Prisma.TermUncheckedUpdateWithoutExclusionsInput
  >;
  create: Prisma.XOR<
    Prisma.TermCreateWithoutExclusionsInput,
    Prisma.TermUncheckedCreateWithoutExclusionsInput
  >;
  where?: Prisma.TermWhereInput;
};

export type TermUpdateToOneWithWhereWithoutExclusionsInput = {
  where?: Prisma.TermWhereInput;
  data: Prisma.XOR<
    Prisma.TermUpdateWithoutExclusionsInput,
    Prisma.TermUncheckedUpdateWithoutExclusionsInput
  >;
};

export type TermUpdateWithoutExclusionsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  name?: Prisma.StringFieldUpdateOperationsInput | string;
  order?: Prisma.IntFieldUpdateOperationsInput | number;
  startDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  endDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  isActive?: Prisma.NullableBoolFieldUpdateOperationsInput | boolean | null;
  observation?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  gradeSheets?: Prisma.GradeSheetUpdateManyWithoutTermNestedInput;
  schoolYear?: Prisma.SchoolYearUpdateOneRequiredWithoutTermsNestedInput;
  reportCards?: Prisma.ReportCardUpdateManyWithoutTermNestedInput;
  assignments?: Prisma.AssignmentUpdateManyWithoutTermNestedInput;
  School?: Prisma.SchoolUpdateOneRequiredWithoutTermsNestedInput;
  absences?: Prisma.AbsenceUpdateManyWithoutTermNestedInput;
  latenesses?: Prisma.LatenessUpdateManyWithoutTermNestedInput;
  consignes?: Prisma.ConsigneUpdateManyWithoutTermNestedInput;
  chatters?: Prisma.ChatterUpdateManyWithoutTermNestedInput;
  convocations?: Prisma.ConvocationUpdateManyWithoutTermNestedInput;
  periodicAttendances?: Prisma.PeriodicAttendanceUpdateManyWithoutTermNestedInput;
};

export type TermUncheckedUpdateWithoutExclusionsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  name?: Prisma.StringFieldUpdateOperationsInput | string;
  schoolYearId?: Prisma.StringFieldUpdateOperationsInput | string;
  order?: Prisma.IntFieldUpdateOperationsInput | number;
  startDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  endDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  isActive?: Prisma.NullableBoolFieldUpdateOperationsInput | boolean | null;
  observation?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  schoolId?: Prisma.StringFieldUpdateOperationsInput | string;
  gradeSheets?: Prisma.GradeSheetUncheckedUpdateManyWithoutTermNestedInput;
  reportCards?: Prisma.ReportCardUncheckedUpdateManyWithoutTermNestedInput;
  assignments?: Prisma.AssignmentUncheckedUpdateManyWithoutTermNestedInput;
  absences?: Prisma.AbsenceUncheckedUpdateManyWithoutTermNestedInput;
  latenesses?: Prisma.LatenessUncheckedUpdateManyWithoutTermNestedInput;
  consignes?: Prisma.ConsigneUncheckedUpdateManyWithoutTermNestedInput;
  chatters?: Prisma.ChatterUncheckedUpdateManyWithoutTermNestedInput;
  convocations?: Prisma.ConvocationUncheckedUpdateManyWithoutTermNestedInput;
  periodicAttendances?: Prisma.PeriodicAttendanceUncheckedUpdateManyWithoutTermNestedInput;
};

export type TermCreateWithoutConvocationsInput = {
  id?: string;
  name: string;
  order: number;
  startDate?: Date | string;
  endDate?: Date | string;
  isActive?: boolean | null;
  observation?: string | null;
  gradeSheets?: Prisma.GradeSheetCreateNestedManyWithoutTermInput;
  schoolYear: Prisma.SchoolYearCreateNestedOneWithoutTermsInput;
  reportCards?: Prisma.ReportCardCreateNestedManyWithoutTermInput;
  assignments?: Prisma.AssignmentCreateNestedManyWithoutTermInput;
  School: Prisma.SchoolCreateNestedOneWithoutTermsInput;
  absences?: Prisma.AbsenceCreateNestedManyWithoutTermInput;
  latenesses?: Prisma.LatenessCreateNestedManyWithoutTermInput;
  exclusions?: Prisma.ExclusionCreateNestedManyWithoutTermInput;
  consignes?: Prisma.ConsigneCreateNestedManyWithoutTermInput;
  chatters?: Prisma.ChatterCreateNestedManyWithoutTermInput;
  periodicAttendances?: Prisma.PeriodicAttendanceCreateNestedManyWithoutTermInput;
};

export type TermUncheckedCreateWithoutConvocationsInput = {
  id?: string;
  name: string;
  schoolYearId: string;
  order: number;
  startDate?: Date | string;
  endDate?: Date | string;
  isActive?: boolean | null;
  observation?: string | null;
  schoolId: string;
  gradeSheets?: Prisma.GradeSheetUncheckedCreateNestedManyWithoutTermInput;
  reportCards?: Prisma.ReportCardUncheckedCreateNestedManyWithoutTermInput;
  assignments?: Prisma.AssignmentUncheckedCreateNestedManyWithoutTermInput;
  absences?: Prisma.AbsenceUncheckedCreateNestedManyWithoutTermInput;
  latenesses?: Prisma.LatenessUncheckedCreateNestedManyWithoutTermInput;
  exclusions?: Prisma.ExclusionUncheckedCreateNestedManyWithoutTermInput;
  consignes?: Prisma.ConsigneUncheckedCreateNestedManyWithoutTermInput;
  chatters?: Prisma.ChatterUncheckedCreateNestedManyWithoutTermInput;
  periodicAttendances?: Prisma.PeriodicAttendanceUncheckedCreateNestedManyWithoutTermInput;
};

export type TermCreateOrConnectWithoutConvocationsInput = {
  where: Prisma.TermWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.TermCreateWithoutConvocationsInput,
    Prisma.TermUncheckedCreateWithoutConvocationsInput
  >;
};

export type TermUpsertWithoutConvocationsInput = {
  update: Prisma.XOR<
    Prisma.TermUpdateWithoutConvocationsInput,
    Prisma.TermUncheckedUpdateWithoutConvocationsInput
  >;
  create: Prisma.XOR<
    Prisma.TermCreateWithoutConvocationsInput,
    Prisma.TermUncheckedCreateWithoutConvocationsInput
  >;
  where?: Prisma.TermWhereInput;
};

export type TermUpdateToOneWithWhereWithoutConvocationsInput = {
  where?: Prisma.TermWhereInput;
  data: Prisma.XOR<
    Prisma.TermUpdateWithoutConvocationsInput,
    Prisma.TermUncheckedUpdateWithoutConvocationsInput
  >;
};

export type TermUpdateWithoutConvocationsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  name?: Prisma.StringFieldUpdateOperationsInput | string;
  order?: Prisma.IntFieldUpdateOperationsInput | number;
  startDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  endDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  isActive?: Prisma.NullableBoolFieldUpdateOperationsInput | boolean | null;
  observation?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  gradeSheets?: Prisma.GradeSheetUpdateManyWithoutTermNestedInput;
  schoolYear?: Prisma.SchoolYearUpdateOneRequiredWithoutTermsNestedInput;
  reportCards?: Prisma.ReportCardUpdateManyWithoutTermNestedInput;
  assignments?: Prisma.AssignmentUpdateManyWithoutTermNestedInput;
  School?: Prisma.SchoolUpdateOneRequiredWithoutTermsNestedInput;
  absences?: Prisma.AbsenceUpdateManyWithoutTermNestedInput;
  latenesses?: Prisma.LatenessUpdateManyWithoutTermNestedInput;
  exclusions?: Prisma.ExclusionUpdateManyWithoutTermNestedInput;
  consignes?: Prisma.ConsigneUpdateManyWithoutTermNestedInput;
  chatters?: Prisma.ChatterUpdateManyWithoutTermNestedInput;
  periodicAttendances?: Prisma.PeriodicAttendanceUpdateManyWithoutTermNestedInput;
};

export type TermUncheckedUpdateWithoutConvocationsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  name?: Prisma.StringFieldUpdateOperationsInput | string;
  schoolYearId?: Prisma.StringFieldUpdateOperationsInput | string;
  order?: Prisma.IntFieldUpdateOperationsInput | number;
  startDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  endDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  isActive?: Prisma.NullableBoolFieldUpdateOperationsInput | boolean | null;
  observation?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  schoolId?: Prisma.StringFieldUpdateOperationsInput | string;
  gradeSheets?: Prisma.GradeSheetUncheckedUpdateManyWithoutTermNestedInput;
  reportCards?: Prisma.ReportCardUncheckedUpdateManyWithoutTermNestedInput;
  assignments?: Prisma.AssignmentUncheckedUpdateManyWithoutTermNestedInput;
  absences?: Prisma.AbsenceUncheckedUpdateManyWithoutTermNestedInput;
  latenesses?: Prisma.LatenessUncheckedUpdateManyWithoutTermNestedInput;
  exclusions?: Prisma.ExclusionUncheckedUpdateManyWithoutTermNestedInput;
  consignes?: Prisma.ConsigneUncheckedUpdateManyWithoutTermNestedInput;
  chatters?: Prisma.ChatterUncheckedUpdateManyWithoutTermNestedInput;
  periodicAttendances?: Prisma.PeriodicAttendanceUncheckedUpdateManyWithoutTermNestedInput;
};

export type TermCreateWithoutPeriodicAttendancesInput = {
  id?: string;
  name: string;
  order: number;
  startDate?: Date | string;
  endDate?: Date | string;
  isActive?: boolean | null;
  observation?: string | null;
  gradeSheets?: Prisma.GradeSheetCreateNestedManyWithoutTermInput;
  schoolYear: Prisma.SchoolYearCreateNestedOneWithoutTermsInput;
  reportCards?: Prisma.ReportCardCreateNestedManyWithoutTermInput;
  assignments?: Prisma.AssignmentCreateNestedManyWithoutTermInput;
  School: Prisma.SchoolCreateNestedOneWithoutTermsInput;
  absences?: Prisma.AbsenceCreateNestedManyWithoutTermInput;
  latenesses?: Prisma.LatenessCreateNestedManyWithoutTermInput;
  exclusions?: Prisma.ExclusionCreateNestedManyWithoutTermInput;
  consignes?: Prisma.ConsigneCreateNestedManyWithoutTermInput;
  chatters?: Prisma.ChatterCreateNestedManyWithoutTermInput;
  convocations?: Prisma.ConvocationCreateNestedManyWithoutTermInput;
};

export type TermUncheckedCreateWithoutPeriodicAttendancesInput = {
  id?: string;
  name: string;
  schoolYearId: string;
  order: number;
  startDate?: Date | string;
  endDate?: Date | string;
  isActive?: boolean | null;
  observation?: string | null;
  schoolId: string;
  gradeSheets?: Prisma.GradeSheetUncheckedCreateNestedManyWithoutTermInput;
  reportCards?: Prisma.ReportCardUncheckedCreateNestedManyWithoutTermInput;
  assignments?: Prisma.AssignmentUncheckedCreateNestedManyWithoutTermInput;
  absences?: Prisma.AbsenceUncheckedCreateNestedManyWithoutTermInput;
  latenesses?: Prisma.LatenessUncheckedCreateNestedManyWithoutTermInput;
  exclusions?: Prisma.ExclusionUncheckedCreateNestedManyWithoutTermInput;
  consignes?: Prisma.ConsigneUncheckedCreateNestedManyWithoutTermInput;
  chatters?: Prisma.ChatterUncheckedCreateNestedManyWithoutTermInput;
  convocations?: Prisma.ConvocationUncheckedCreateNestedManyWithoutTermInput;
};

export type TermCreateOrConnectWithoutPeriodicAttendancesInput = {
  where: Prisma.TermWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.TermCreateWithoutPeriodicAttendancesInput,
    Prisma.TermUncheckedCreateWithoutPeriodicAttendancesInput
  >;
};

export type TermUpsertWithoutPeriodicAttendancesInput = {
  update: Prisma.XOR<
    Prisma.TermUpdateWithoutPeriodicAttendancesInput,
    Prisma.TermUncheckedUpdateWithoutPeriodicAttendancesInput
  >;
  create: Prisma.XOR<
    Prisma.TermCreateWithoutPeriodicAttendancesInput,
    Prisma.TermUncheckedCreateWithoutPeriodicAttendancesInput
  >;
  where?: Prisma.TermWhereInput;
};

export type TermUpdateToOneWithWhereWithoutPeriodicAttendancesInput = {
  where?: Prisma.TermWhereInput;
  data: Prisma.XOR<
    Prisma.TermUpdateWithoutPeriodicAttendancesInput,
    Prisma.TermUncheckedUpdateWithoutPeriodicAttendancesInput
  >;
};

export type TermUpdateWithoutPeriodicAttendancesInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  name?: Prisma.StringFieldUpdateOperationsInput | string;
  order?: Prisma.IntFieldUpdateOperationsInput | number;
  startDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  endDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  isActive?: Prisma.NullableBoolFieldUpdateOperationsInput | boolean | null;
  observation?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  gradeSheets?: Prisma.GradeSheetUpdateManyWithoutTermNestedInput;
  schoolYear?: Prisma.SchoolYearUpdateOneRequiredWithoutTermsNestedInput;
  reportCards?: Prisma.ReportCardUpdateManyWithoutTermNestedInput;
  assignments?: Prisma.AssignmentUpdateManyWithoutTermNestedInput;
  School?: Prisma.SchoolUpdateOneRequiredWithoutTermsNestedInput;
  absences?: Prisma.AbsenceUpdateManyWithoutTermNestedInput;
  latenesses?: Prisma.LatenessUpdateManyWithoutTermNestedInput;
  exclusions?: Prisma.ExclusionUpdateManyWithoutTermNestedInput;
  consignes?: Prisma.ConsigneUpdateManyWithoutTermNestedInput;
  chatters?: Prisma.ChatterUpdateManyWithoutTermNestedInput;
  convocations?: Prisma.ConvocationUpdateManyWithoutTermNestedInput;
};

export type TermUncheckedUpdateWithoutPeriodicAttendancesInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  name?: Prisma.StringFieldUpdateOperationsInput | string;
  schoolYearId?: Prisma.StringFieldUpdateOperationsInput | string;
  order?: Prisma.IntFieldUpdateOperationsInput | number;
  startDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  endDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  isActive?: Prisma.NullableBoolFieldUpdateOperationsInput | boolean | null;
  observation?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  schoolId?: Prisma.StringFieldUpdateOperationsInput | string;
  gradeSheets?: Prisma.GradeSheetUncheckedUpdateManyWithoutTermNestedInput;
  reportCards?: Prisma.ReportCardUncheckedUpdateManyWithoutTermNestedInput;
  assignments?: Prisma.AssignmentUncheckedUpdateManyWithoutTermNestedInput;
  absences?: Prisma.AbsenceUncheckedUpdateManyWithoutTermNestedInput;
  latenesses?: Prisma.LatenessUncheckedUpdateManyWithoutTermNestedInput;
  exclusions?: Prisma.ExclusionUncheckedUpdateManyWithoutTermNestedInput;
  consignes?: Prisma.ConsigneUncheckedUpdateManyWithoutTermNestedInput;
  chatters?: Prisma.ChatterUncheckedUpdateManyWithoutTermNestedInput;
  convocations?: Prisma.ConvocationUncheckedUpdateManyWithoutTermNestedInput;
};

export type TermCreateWithoutReportCardsInput = {
  id?: string;
  name: string;
  order: number;
  startDate?: Date | string;
  endDate?: Date | string;
  isActive?: boolean | null;
  observation?: string | null;
  gradeSheets?: Prisma.GradeSheetCreateNestedManyWithoutTermInput;
  schoolYear: Prisma.SchoolYearCreateNestedOneWithoutTermsInput;
  assignments?: Prisma.AssignmentCreateNestedManyWithoutTermInput;
  School: Prisma.SchoolCreateNestedOneWithoutTermsInput;
  absences?: Prisma.AbsenceCreateNestedManyWithoutTermInput;
  latenesses?: Prisma.LatenessCreateNestedManyWithoutTermInput;
  exclusions?: Prisma.ExclusionCreateNestedManyWithoutTermInput;
  consignes?: Prisma.ConsigneCreateNestedManyWithoutTermInput;
  chatters?: Prisma.ChatterCreateNestedManyWithoutTermInput;
  convocations?: Prisma.ConvocationCreateNestedManyWithoutTermInput;
  periodicAttendances?: Prisma.PeriodicAttendanceCreateNestedManyWithoutTermInput;
};

export type TermUncheckedCreateWithoutReportCardsInput = {
  id?: string;
  name: string;
  schoolYearId: string;
  order: number;
  startDate?: Date | string;
  endDate?: Date | string;
  isActive?: boolean | null;
  observation?: string | null;
  schoolId: string;
  gradeSheets?: Prisma.GradeSheetUncheckedCreateNestedManyWithoutTermInput;
  assignments?: Prisma.AssignmentUncheckedCreateNestedManyWithoutTermInput;
  absences?: Prisma.AbsenceUncheckedCreateNestedManyWithoutTermInput;
  latenesses?: Prisma.LatenessUncheckedCreateNestedManyWithoutTermInput;
  exclusions?: Prisma.ExclusionUncheckedCreateNestedManyWithoutTermInput;
  consignes?: Prisma.ConsigneUncheckedCreateNestedManyWithoutTermInput;
  chatters?: Prisma.ChatterUncheckedCreateNestedManyWithoutTermInput;
  convocations?: Prisma.ConvocationUncheckedCreateNestedManyWithoutTermInput;
  periodicAttendances?: Prisma.PeriodicAttendanceUncheckedCreateNestedManyWithoutTermInput;
};

export type TermCreateOrConnectWithoutReportCardsInput = {
  where: Prisma.TermWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.TermCreateWithoutReportCardsInput,
    Prisma.TermUncheckedCreateWithoutReportCardsInput
  >;
};

export type TermUpsertWithoutReportCardsInput = {
  update: Prisma.XOR<
    Prisma.TermUpdateWithoutReportCardsInput,
    Prisma.TermUncheckedUpdateWithoutReportCardsInput
  >;
  create: Prisma.XOR<
    Prisma.TermCreateWithoutReportCardsInput,
    Prisma.TermUncheckedCreateWithoutReportCardsInput
  >;
  where?: Prisma.TermWhereInput;
};

export type TermUpdateToOneWithWhereWithoutReportCardsInput = {
  where?: Prisma.TermWhereInput;
  data: Prisma.XOR<
    Prisma.TermUpdateWithoutReportCardsInput,
    Prisma.TermUncheckedUpdateWithoutReportCardsInput
  >;
};

export type TermUpdateWithoutReportCardsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  name?: Prisma.StringFieldUpdateOperationsInput | string;
  order?: Prisma.IntFieldUpdateOperationsInput | number;
  startDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  endDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  isActive?: Prisma.NullableBoolFieldUpdateOperationsInput | boolean | null;
  observation?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  gradeSheets?: Prisma.GradeSheetUpdateManyWithoutTermNestedInput;
  schoolYear?: Prisma.SchoolYearUpdateOneRequiredWithoutTermsNestedInput;
  assignments?: Prisma.AssignmentUpdateManyWithoutTermNestedInput;
  School?: Prisma.SchoolUpdateOneRequiredWithoutTermsNestedInput;
  absences?: Prisma.AbsenceUpdateManyWithoutTermNestedInput;
  latenesses?: Prisma.LatenessUpdateManyWithoutTermNestedInput;
  exclusions?: Prisma.ExclusionUpdateManyWithoutTermNestedInput;
  consignes?: Prisma.ConsigneUpdateManyWithoutTermNestedInput;
  chatters?: Prisma.ChatterUpdateManyWithoutTermNestedInput;
  convocations?: Prisma.ConvocationUpdateManyWithoutTermNestedInput;
  periodicAttendances?: Prisma.PeriodicAttendanceUpdateManyWithoutTermNestedInput;
};

export type TermUncheckedUpdateWithoutReportCardsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  name?: Prisma.StringFieldUpdateOperationsInput | string;
  schoolYearId?: Prisma.StringFieldUpdateOperationsInput | string;
  order?: Prisma.IntFieldUpdateOperationsInput | number;
  startDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  endDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  isActive?: Prisma.NullableBoolFieldUpdateOperationsInput | boolean | null;
  observation?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  schoolId?: Prisma.StringFieldUpdateOperationsInput | string;
  gradeSheets?: Prisma.GradeSheetUncheckedUpdateManyWithoutTermNestedInput;
  assignments?: Prisma.AssignmentUncheckedUpdateManyWithoutTermNestedInput;
  absences?: Prisma.AbsenceUncheckedUpdateManyWithoutTermNestedInput;
  latenesses?: Prisma.LatenessUncheckedUpdateManyWithoutTermNestedInput;
  exclusions?: Prisma.ExclusionUncheckedUpdateManyWithoutTermNestedInput;
  consignes?: Prisma.ConsigneUncheckedUpdateManyWithoutTermNestedInput;
  chatters?: Prisma.ChatterUncheckedUpdateManyWithoutTermNestedInput;
  convocations?: Prisma.ConvocationUncheckedUpdateManyWithoutTermNestedInput;
  periodicAttendances?: Prisma.PeriodicAttendanceUncheckedUpdateManyWithoutTermNestedInput;
};

export type TermCreateWithoutGradeSheetsInput = {
  id?: string;
  name: string;
  order: number;
  startDate?: Date | string;
  endDate?: Date | string;
  isActive?: boolean | null;
  observation?: string | null;
  schoolYear: Prisma.SchoolYearCreateNestedOneWithoutTermsInput;
  reportCards?: Prisma.ReportCardCreateNestedManyWithoutTermInput;
  assignments?: Prisma.AssignmentCreateNestedManyWithoutTermInput;
  School: Prisma.SchoolCreateNestedOneWithoutTermsInput;
  absences?: Prisma.AbsenceCreateNestedManyWithoutTermInput;
  latenesses?: Prisma.LatenessCreateNestedManyWithoutTermInput;
  exclusions?: Prisma.ExclusionCreateNestedManyWithoutTermInput;
  consignes?: Prisma.ConsigneCreateNestedManyWithoutTermInput;
  chatters?: Prisma.ChatterCreateNestedManyWithoutTermInput;
  convocations?: Prisma.ConvocationCreateNestedManyWithoutTermInput;
  periodicAttendances?: Prisma.PeriodicAttendanceCreateNestedManyWithoutTermInput;
};

export type TermUncheckedCreateWithoutGradeSheetsInput = {
  id?: string;
  name: string;
  schoolYearId: string;
  order: number;
  startDate?: Date | string;
  endDate?: Date | string;
  isActive?: boolean | null;
  observation?: string | null;
  schoolId: string;
  reportCards?: Prisma.ReportCardUncheckedCreateNestedManyWithoutTermInput;
  assignments?: Prisma.AssignmentUncheckedCreateNestedManyWithoutTermInput;
  absences?: Prisma.AbsenceUncheckedCreateNestedManyWithoutTermInput;
  latenesses?: Prisma.LatenessUncheckedCreateNestedManyWithoutTermInput;
  exclusions?: Prisma.ExclusionUncheckedCreateNestedManyWithoutTermInput;
  consignes?: Prisma.ConsigneUncheckedCreateNestedManyWithoutTermInput;
  chatters?: Prisma.ChatterUncheckedCreateNestedManyWithoutTermInput;
  convocations?: Prisma.ConvocationUncheckedCreateNestedManyWithoutTermInput;
  periodicAttendances?: Prisma.PeriodicAttendanceUncheckedCreateNestedManyWithoutTermInput;
};

export type TermCreateOrConnectWithoutGradeSheetsInput = {
  where: Prisma.TermWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.TermCreateWithoutGradeSheetsInput,
    Prisma.TermUncheckedCreateWithoutGradeSheetsInput
  >;
};

export type TermUpsertWithoutGradeSheetsInput = {
  update: Prisma.XOR<
    Prisma.TermUpdateWithoutGradeSheetsInput,
    Prisma.TermUncheckedUpdateWithoutGradeSheetsInput
  >;
  create: Prisma.XOR<
    Prisma.TermCreateWithoutGradeSheetsInput,
    Prisma.TermUncheckedCreateWithoutGradeSheetsInput
  >;
  where?: Prisma.TermWhereInput;
};

export type TermUpdateToOneWithWhereWithoutGradeSheetsInput = {
  where?: Prisma.TermWhereInput;
  data: Prisma.XOR<
    Prisma.TermUpdateWithoutGradeSheetsInput,
    Prisma.TermUncheckedUpdateWithoutGradeSheetsInput
  >;
};

export type TermUpdateWithoutGradeSheetsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  name?: Prisma.StringFieldUpdateOperationsInput | string;
  order?: Prisma.IntFieldUpdateOperationsInput | number;
  startDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  endDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  isActive?: Prisma.NullableBoolFieldUpdateOperationsInput | boolean | null;
  observation?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  schoolYear?: Prisma.SchoolYearUpdateOneRequiredWithoutTermsNestedInput;
  reportCards?: Prisma.ReportCardUpdateManyWithoutTermNestedInput;
  assignments?: Prisma.AssignmentUpdateManyWithoutTermNestedInput;
  School?: Prisma.SchoolUpdateOneRequiredWithoutTermsNestedInput;
  absences?: Prisma.AbsenceUpdateManyWithoutTermNestedInput;
  latenesses?: Prisma.LatenessUpdateManyWithoutTermNestedInput;
  exclusions?: Prisma.ExclusionUpdateManyWithoutTermNestedInput;
  consignes?: Prisma.ConsigneUpdateManyWithoutTermNestedInput;
  chatters?: Prisma.ChatterUpdateManyWithoutTermNestedInput;
  convocations?: Prisma.ConvocationUpdateManyWithoutTermNestedInput;
  periodicAttendances?: Prisma.PeriodicAttendanceUpdateManyWithoutTermNestedInput;
};

export type TermUncheckedUpdateWithoutGradeSheetsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  name?: Prisma.StringFieldUpdateOperationsInput | string;
  schoolYearId?: Prisma.StringFieldUpdateOperationsInput | string;
  order?: Prisma.IntFieldUpdateOperationsInput | number;
  startDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  endDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  isActive?: Prisma.NullableBoolFieldUpdateOperationsInput | boolean | null;
  observation?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  schoolId?: Prisma.StringFieldUpdateOperationsInput | string;
  reportCards?: Prisma.ReportCardUncheckedUpdateManyWithoutTermNestedInput;
  assignments?: Prisma.AssignmentUncheckedUpdateManyWithoutTermNestedInput;
  absences?: Prisma.AbsenceUncheckedUpdateManyWithoutTermNestedInput;
  latenesses?: Prisma.LatenessUncheckedUpdateManyWithoutTermNestedInput;
  exclusions?: Prisma.ExclusionUncheckedUpdateManyWithoutTermNestedInput;
  consignes?: Prisma.ConsigneUncheckedUpdateManyWithoutTermNestedInput;
  chatters?: Prisma.ChatterUncheckedUpdateManyWithoutTermNestedInput;
  convocations?: Prisma.ConvocationUncheckedUpdateManyWithoutTermNestedInput;
  periodicAttendances?: Prisma.PeriodicAttendanceUncheckedUpdateManyWithoutTermNestedInput;
};

export type TermCreateWithoutAssignmentsInput = {
  id?: string;
  name: string;
  order: number;
  startDate?: Date | string;
  endDate?: Date | string;
  isActive?: boolean | null;
  observation?: string | null;
  gradeSheets?: Prisma.GradeSheetCreateNestedManyWithoutTermInput;
  schoolYear: Prisma.SchoolYearCreateNestedOneWithoutTermsInput;
  reportCards?: Prisma.ReportCardCreateNestedManyWithoutTermInput;
  School: Prisma.SchoolCreateNestedOneWithoutTermsInput;
  absences?: Prisma.AbsenceCreateNestedManyWithoutTermInput;
  latenesses?: Prisma.LatenessCreateNestedManyWithoutTermInput;
  exclusions?: Prisma.ExclusionCreateNestedManyWithoutTermInput;
  consignes?: Prisma.ConsigneCreateNestedManyWithoutTermInput;
  chatters?: Prisma.ChatterCreateNestedManyWithoutTermInput;
  convocations?: Prisma.ConvocationCreateNestedManyWithoutTermInput;
  periodicAttendances?: Prisma.PeriodicAttendanceCreateNestedManyWithoutTermInput;
};

export type TermUncheckedCreateWithoutAssignmentsInput = {
  id?: string;
  name: string;
  schoolYearId: string;
  order: number;
  startDate?: Date | string;
  endDate?: Date | string;
  isActive?: boolean | null;
  observation?: string | null;
  schoolId: string;
  gradeSheets?: Prisma.GradeSheetUncheckedCreateNestedManyWithoutTermInput;
  reportCards?: Prisma.ReportCardUncheckedCreateNestedManyWithoutTermInput;
  absences?: Prisma.AbsenceUncheckedCreateNestedManyWithoutTermInput;
  latenesses?: Prisma.LatenessUncheckedCreateNestedManyWithoutTermInput;
  exclusions?: Prisma.ExclusionUncheckedCreateNestedManyWithoutTermInput;
  consignes?: Prisma.ConsigneUncheckedCreateNestedManyWithoutTermInput;
  chatters?: Prisma.ChatterUncheckedCreateNestedManyWithoutTermInput;
  convocations?: Prisma.ConvocationUncheckedCreateNestedManyWithoutTermInput;
  periodicAttendances?: Prisma.PeriodicAttendanceUncheckedCreateNestedManyWithoutTermInput;
};

export type TermCreateOrConnectWithoutAssignmentsInput = {
  where: Prisma.TermWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.TermCreateWithoutAssignmentsInput,
    Prisma.TermUncheckedCreateWithoutAssignmentsInput
  >;
};

export type TermUpsertWithoutAssignmentsInput = {
  update: Prisma.XOR<
    Prisma.TermUpdateWithoutAssignmentsInput,
    Prisma.TermUncheckedUpdateWithoutAssignmentsInput
  >;
  create: Prisma.XOR<
    Prisma.TermCreateWithoutAssignmentsInput,
    Prisma.TermUncheckedCreateWithoutAssignmentsInput
  >;
  where?: Prisma.TermWhereInput;
};

export type TermUpdateToOneWithWhereWithoutAssignmentsInput = {
  where?: Prisma.TermWhereInput;
  data: Prisma.XOR<
    Prisma.TermUpdateWithoutAssignmentsInput,
    Prisma.TermUncheckedUpdateWithoutAssignmentsInput
  >;
};

export type TermUpdateWithoutAssignmentsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  name?: Prisma.StringFieldUpdateOperationsInput | string;
  order?: Prisma.IntFieldUpdateOperationsInput | number;
  startDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  endDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  isActive?: Prisma.NullableBoolFieldUpdateOperationsInput | boolean | null;
  observation?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  gradeSheets?: Prisma.GradeSheetUpdateManyWithoutTermNestedInput;
  schoolYear?: Prisma.SchoolYearUpdateOneRequiredWithoutTermsNestedInput;
  reportCards?: Prisma.ReportCardUpdateManyWithoutTermNestedInput;
  School?: Prisma.SchoolUpdateOneRequiredWithoutTermsNestedInput;
  absences?: Prisma.AbsenceUpdateManyWithoutTermNestedInput;
  latenesses?: Prisma.LatenessUpdateManyWithoutTermNestedInput;
  exclusions?: Prisma.ExclusionUpdateManyWithoutTermNestedInput;
  consignes?: Prisma.ConsigneUpdateManyWithoutTermNestedInput;
  chatters?: Prisma.ChatterUpdateManyWithoutTermNestedInput;
  convocations?: Prisma.ConvocationUpdateManyWithoutTermNestedInput;
  periodicAttendances?: Prisma.PeriodicAttendanceUpdateManyWithoutTermNestedInput;
};

export type TermUncheckedUpdateWithoutAssignmentsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  name?: Prisma.StringFieldUpdateOperationsInput | string;
  schoolYearId?: Prisma.StringFieldUpdateOperationsInput | string;
  order?: Prisma.IntFieldUpdateOperationsInput | number;
  startDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  endDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  isActive?: Prisma.NullableBoolFieldUpdateOperationsInput | boolean | null;
  observation?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  schoolId?: Prisma.StringFieldUpdateOperationsInput | string;
  gradeSheets?: Prisma.GradeSheetUncheckedUpdateManyWithoutTermNestedInput;
  reportCards?: Prisma.ReportCardUncheckedUpdateManyWithoutTermNestedInput;
  absences?: Prisma.AbsenceUncheckedUpdateManyWithoutTermNestedInput;
  latenesses?: Prisma.LatenessUncheckedUpdateManyWithoutTermNestedInput;
  exclusions?: Prisma.ExclusionUncheckedUpdateManyWithoutTermNestedInput;
  consignes?: Prisma.ConsigneUncheckedUpdateManyWithoutTermNestedInput;
  chatters?: Prisma.ChatterUncheckedUpdateManyWithoutTermNestedInput;
  convocations?: Prisma.ConvocationUncheckedUpdateManyWithoutTermNestedInput;
  periodicAttendances?: Prisma.PeriodicAttendanceUncheckedUpdateManyWithoutTermNestedInput;
};

export type TermCreateWithoutSchoolInput = {
  id?: string;
  name: string;
  order: number;
  startDate?: Date | string;
  endDate?: Date | string;
  isActive?: boolean | null;
  observation?: string | null;
  gradeSheets?: Prisma.GradeSheetCreateNestedManyWithoutTermInput;
  schoolYear: Prisma.SchoolYearCreateNestedOneWithoutTermsInput;
  reportCards?: Prisma.ReportCardCreateNestedManyWithoutTermInput;
  assignments?: Prisma.AssignmentCreateNestedManyWithoutTermInput;
  absences?: Prisma.AbsenceCreateNestedManyWithoutTermInput;
  latenesses?: Prisma.LatenessCreateNestedManyWithoutTermInput;
  exclusions?: Prisma.ExclusionCreateNestedManyWithoutTermInput;
  consignes?: Prisma.ConsigneCreateNestedManyWithoutTermInput;
  chatters?: Prisma.ChatterCreateNestedManyWithoutTermInput;
  convocations?: Prisma.ConvocationCreateNestedManyWithoutTermInput;
  periodicAttendances?: Prisma.PeriodicAttendanceCreateNestedManyWithoutTermInput;
};

export type TermUncheckedCreateWithoutSchoolInput = {
  id?: string;
  name: string;
  schoolYearId: string;
  order: number;
  startDate?: Date | string;
  endDate?: Date | string;
  isActive?: boolean | null;
  observation?: string | null;
  gradeSheets?: Prisma.GradeSheetUncheckedCreateNestedManyWithoutTermInput;
  reportCards?: Prisma.ReportCardUncheckedCreateNestedManyWithoutTermInput;
  assignments?: Prisma.AssignmentUncheckedCreateNestedManyWithoutTermInput;
  absences?: Prisma.AbsenceUncheckedCreateNestedManyWithoutTermInput;
  latenesses?: Prisma.LatenessUncheckedCreateNestedManyWithoutTermInput;
  exclusions?: Prisma.ExclusionUncheckedCreateNestedManyWithoutTermInput;
  consignes?: Prisma.ConsigneUncheckedCreateNestedManyWithoutTermInput;
  chatters?: Prisma.ChatterUncheckedCreateNestedManyWithoutTermInput;
  convocations?: Prisma.ConvocationUncheckedCreateNestedManyWithoutTermInput;
  periodicAttendances?: Prisma.PeriodicAttendanceUncheckedCreateNestedManyWithoutTermInput;
};

export type TermCreateOrConnectWithoutSchoolInput = {
  where: Prisma.TermWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.TermCreateWithoutSchoolInput,
    Prisma.TermUncheckedCreateWithoutSchoolInput
  >;
};

export type TermCreateManySchoolInputEnvelope = {
  data: Prisma.TermCreateManySchoolInput | Prisma.TermCreateManySchoolInput[];
  skipDuplicates?: boolean;
};

export type TermUpsertWithWhereUniqueWithoutSchoolInput = {
  where: Prisma.TermWhereUniqueInput;
  update: Prisma.XOR<
    Prisma.TermUpdateWithoutSchoolInput,
    Prisma.TermUncheckedUpdateWithoutSchoolInput
  >;
  create: Prisma.XOR<
    Prisma.TermCreateWithoutSchoolInput,
    Prisma.TermUncheckedCreateWithoutSchoolInput
  >;
};

export type TermUpdateWithWhereUniqueWithoutSchoolInput = {
  where: Prisma.TermWhereUniqueInput;
  data: Prisma.XOR<
    Prisma.TermUpdateWithoutSchoolInput,
    Prisma.TermUncheckedUpdateWithoutSchoolInput
  >;
};

export type TermUpdateManyWithWhereWithoutSchoolInput = {
  where: Prisma.TermScalarWhereInput;
  data: Prisma.XOR<
    Prisma.TermUpdateManyMutationInput,
    Prisma.TermUncheckedUpdateManyWithoutSchoolInput
  >;
};

export type TermScalarWhereInput = {
  AND?: Prisma.TermScalarWhereInput | Prisma.TermScalarWhereInput[];
  OR?: Prisma.TermScalarWhereInput[];
  NOT?: Prisma.TermScalarWhereInput | Prisma.TermScalarWhereInput[];
  id?: Prisma.StringFilter<"Term"> | string;
  name?: Prisma.StringFilter<"Term"> | string;
  schoolYearId?: Prisma.StringFilter<"Term"> | string;
  order?: Prisma.IntFilter<"Term"> | number;
  startDate?: Prisma.DateTimeFilter<"Term"> | Date | string;
  endDate?: Prisma.DateTimeFilter<"Term"> | Date | string;
  isActive?: Prisma.BoolNullableFilter<"Term"> | boolean | null;
  observation?: Prisma.StringNullableFilter<"Term"> | string | null;
  schoolId?: Prisma.StringFilter<"Term"> | string;
};

export type TermCreateWithoutSchoolYearInput = {
  id?: string;
  name: string;
  order: number;
  startDate?: Date | string;
  endDate?: Date | string;
  isActive?: boolean | null;
  observation?: string | null;
  gradeSheets?: Prisma.GradeSheetCreateNestedManyWithoutTermInput;
  reportCards?: Prisma.ReportCardCreateNestedManyWithoutTermInput;
  assignments?: Prisma.AssignmentCreateNestedManyWithoutTermInput;
  School: Prisma.SchoolCreateNestedOneWithoutTermsInput;
  absences?: Prisma.AbsenceCreateNestedManyWithoutTermInput;
  latenesses?: Prisma.LatenessCreateNestedManyWithoutTermInput;
  exclusions?: Prisma.ExclusionCreateNestedManyWithoutTermInput;
  consignes?: Prisma.ConsigneCreateNestedManyWithoutTermInput;
  chatters?: Prisma.ChatterCreateNestedManyWithoutTermInput;
  convocations?: Prisma.ConvocationCreateNestedManyWithoutTermInput;
  periodicAttendances?: Prisma.PeriodicAttendanceCreateNestedManyWithoutTermInput;
};

export type TermUncheckedCreateWithoutSchoolYearInput = {
  id?: string;
  name: string;
  order: number;
  startDate?: Date | string;
  endDate?: Date | string;
  isActive?: boolean | null;
  observation?: string | null;
  schoolId: string;
  gradeSheets?: Prisma.GradeSheetUncheckedCreateNestedManyWithoutTermInput;
  reportCards?: Prisma.ReportCardUncheckedCreateNestedManyWithoutTermInput;
  assignments?: Prisma.AssignmentUncheckedCreateNestedManyWithoutTermInput;
  absences?: Prisma.AbsenceUncheckedCreateNestedManyWithoutTermInput;
  latenesses?: Prisma.LatenessUncheckedCreateNestedManyWithoutTermInput;
  exclusions?: Prisma.ExclusionUncheckedCreateNestedManyWithoutTermInput;
  consignes?: Prisma.ConsigneUncheckedCreateNestedManyWithoutTermInput;
  chatters?: Prisma.ChatterUncheckedCreateNestedManyWithoutTermInput;
  convocations?: Prisma.ConvocationUncheckedCreateNestedManyWithoutTermInput;
  periodicAttendances?: Prisma.PeriodicAttendanceUncheckedCreateNestedManyWithoutTermInput;
};

export type TermCreateOrConnectWithoutSchoolYearInput = {
  where: Prisma.TermWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.TermCreateWithoutSchoolYearInput,
    Prisma.TermUncheckedCreateWithoutSchoolYearInput
  >;
};

export type TermCreateManySchoolYearInputEnvelope = {
  data:
    | Prisma.TermCreateManySchoolYearInput
    | Prisma.TermCreateManySchoolYearInput[];
  skipDuplicates?: boolean;
};

export type TermUpsertWithWhereUniqueWithoutSchoolYearInput = {
  where: Prisma.TermWhereUniqueInput;
  update: Prisma.XOR<
    Prisma.TermUpdateWithoutSchoolYearInput,
    Prisma.TermUncheckedUpdateWithoutSchoolYearInput
  >;
  create: Prisma.XOR<
    Prisma.TermCreateWithoutSchoolYearInput,
    Prisma.TermUncheckedCreateWithoutSchoolYearInput
  >;
};

export type TermUpdateWithWhereUniqueWithoutSchoolYearInput = {
  where: Prisma.TermWhereUniqueInput;
  data: Prisma.XOR<
    Prisma.TermUpdateWithoutSchoolYearInput,
    Prisma.TermUncheckedUpdateWithoutSchoolYearInput
  >;
};

export type TermUpdateManyWithWhereWithoutSchoolYearInput = {
  where: Prisma.TermScalarWhereInput;
  data: Prisma.XOR<
    Prisma.TermUpdateManyMutationInput,
    Prisma.TermUncheckedUpdateManyWithoutSchoolYearInput
  >;
};

export type TermCreateManySchoolInput = {
  id?: string;
  name: string;
  schoolYearId: string;
  order: number;
  startDate?: Date | string;
  endDate?: Date | string;
  isActive?: boolean | null;
  observation?: string | null;
};

export type TermUpdateWithoutSchoolInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  name?: Prisma.StringFieldUpdateOperationsInput | string;
  order?: Prisma.IntFieldUpdateOperationsInput | number;
  startDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  endDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  isActive?: Prisma.NullableBoolFieldUpdateOperationsInput | boolean | null;
  observation?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  gradeSheets?: Prisma.GradeSheetUpdateManyWithoutTermNestedInput;
  schoolYear?: Prisma.SchoolYearUpdateOneRequiredWithoutTermsNestedInput;
  reportCards?: Prisma.ReportCardUpdateManyWithoutTermNestedInput;
  assignments?: Prisma.AssignmentUpdateManyWithoutTermNestedInput;
  absences?: Prisma.AbsenceUpdateManyWithoutTermNestedInput;
  latenesses?: Prisma.LatenessUpdateManyWithoutTermNestedInput;
  exclusions?: Prisma.ExclusionUpdateManyWithoutTermNestedInput;
  consignes?: Prisma.ConsigneUpdateManyWithoutTermNestedInput;
  chatters?: Prisma.ChatterUpdateManyWithoutTermNestedInput;
  convocations?: Prisma.ConvocationUpdateManyWithoutTermNestedInput;
  periodicAttendances?: Prisma.PeriodicAttendanceUpdateManyWithoutTermNestedInput;
};

export type TermUncheckedUpdateWithoutSchoolInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  name?: Prisma.StringFieldUpdateOperationsInput | string;
  schoolYearId?: Prisma.StringFieldUpdateOperationsInput | string;
  order?: Prisma.IntFieldUpdateOperationsInput | number;
  startDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  endDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  isActive?: Prisma.NullableBoolFieldUpdateOperationsInput | boolean | null;
  observation?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  gradeSheets?: Prisma.GradeSheetUncheckedUpdateManyWithoutTermNestedInput;
  reportCards?: Prisma.ReportCardUncheckedUpdateManyWithoutTermNestedInput;
  assignments?: Prisma.AssignmentUncheckedUpdateManyWithoutTermNestedInput;
  absences?: Prisma.AbsenceUncheckedUpdateManyWithoutTermNestedInput;
  latenesses?: Prisma.LatenessUncheckedUpdateManyWithoutTermNestedInput;
  exclusions?: Prisma.ExclusionUncheckedUpdateManyWithoutTermNestedInput;
  consignes?: Prisma.ConsigneUncheckedUpdateManyWithoutTermNestedInput;
  chatters?: Prisma.ChatterUncheckedUpdateManyWithoutTermNestedInput;
  convocations?: Prisma.ConvocationUncheckedUpdateManyWithoutTermNestedInput;
  periodicAttendances?: Prisma.PeriodicAttendanceUncheckedUpdateManyWithoutTermNestedInput;
};

export type TermUncheckedUpdateManyWithoutSchoolInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  name?: Prisma.StringFieldUpdateOperationsInput | string;
  schoolYearId?: Prisma.StringFieldUpdateOperationsInput | string;
  order?: Prisma.IntFieldUpdateOperationsInput | number;
  startDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  endDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  isActive?: Prisma.NullableBoolFieldUpdateOperationsInput | boolean | null;
  observation?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
};

export type TermCreateManySchoolYearInput = {
  id?: string;
  name: string;
  order: number;
  startDate?: Date | string;
  endDate?: Date | string;
  isActive?: boolean | null;
  observation?: string | null;
  schoolId: string;
};

export type TermUpdateWithoutSchoolYearInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  name?: Prisma.StringFieldUpdateOperationsInput | string;
  order?: Prisma.IntFieldUpdateOperationsInput | number;
  startDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  endDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  isActive?: Prisma.NullableBoolFieldUpdateOperationsInput | boolean | null;
  observation?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  gradeSheets?: Prisma.GradeSheetUpdateManyWithoutTermNestedInput;
  reportCards?: Prisma.ReportCardUpdateManyWithoutTermNestedInput;
  assignments?: Prisma.AssignmentUpdateManyWithoutTermNestedInput;
  School?: Prisma.SchoolUpdateOneRequiredWithoutTermsNestedInput;
  absences?: Prisma.AbsenceUpdateManyWithoutTermNestedInput;
  latenesses?: Prisma.LatenessUpdateManyWithoutTermNestedInput;
  exclusions?: Prisma.ExclusionUpdateManyWithoutTermNestedInput;
  consignes?: Prisma.ConsigneUpdateManyWithoutTermNestedInput;
  chatters?: Prisma.ChatterUpdateManyWithoutTermNestedInput;
  convocations?: Prisma.ConvocationUpdateManyWithoutTermNestedInput;
  periodicAttendances?: Prisma.PeriodicAttendanceUpdateManyWithoutTermNestedInput;
};

export type TermUncheckedUpdateWithoutSchoolYearInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  name?: Prisma.StringFieldUpdateOperationsInput | string;
  order?: Prisma.IntFieldUpdateOperationsInput | number;
  startDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  endDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  isActive?: Prisma.NullableBoolFieldUpdateOperationsInput | boolean | null;
  observation?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  schoolId?: Prisma.StringFieldUpdateOperationsInput | string;
  gradeSheets?: Prisma.GradeSheetUncheckedUpdateManyWithoutTermNestedInput;
  reportCards?: Prisma.ReportCardUncheckedUpdateManyWithoutTermNestedInput;
  assignments?: Prisma.AssignmentUncheckedUpdateManyWithoutTermNestedInput;
  absences?: Prisma.AbsenceUncheckedUpdateManyWithoutTermNestedInput;
  latenesses?: Prisma.LatenessUncheckedUpdateManyWithoutTermNestedInput;
  exclusions?: Prisma.ExclusionUncheckedUpdateManyWithoutTermNestedInput;
  consignes?: Prisma.ConsigneUncheckedUpdateManyWithoutTermNestedInput;
  chatters?: Prisma.ChatterUncheckedUpdateManyWithoutTermNestedInput;
  convocations?: Prisma.ConvocationUncheckedUpdateManyWithoutTermNestedInput;
  periodicAttendances?: Prisma.PeriodicAttendanceUncheckedUpdateManyWithoutTermNestedInput;
};

export type TermUncheckedUpdateManyWithoutSchoolYearInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  name?: Prisma.StringFieldUpdateOperationsInput | string;
  order?: Prisma.IntFieldUpdateOperationsInput | number;
  startDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  endDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  isActive?: Prisma.NullableBoolFieldUpdateOperationsInput | boolean | null;
  observation?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  schoolId?: Prisma.StringFieldUpdateOperationsInput | string;
};

/**
 * Count Type TermCountOutputType
 */

export type TermCountOutputType = {
  gradeSheets: number;
  reportCards: number;
  assignments: number;
  absences: number;
  latenesses: number;
  exclusions: number;
  consignes: number;
  chatters: number;
  convocations: number;
  periodicAttendances: number;
};

export type TermCountOutputTypeSelect<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  gradeSheets?: boolean | TermCountOutputTypeCountGradeSheetsArgs;
  reportCards?: boolean | TermCountOutputTypeCountReportCardsArgs;
  assignments?: boolean | TermCountOutputTypeCountAssignmentsArgs;
  absences?: boolean | TermCountOutputTypeCountAbsencesArgs;
  latenesses?: boolean | TermCountOutputTypeCountLatenessesArgs;
  exclusions?: boolean | TermCountOutputTypeCountExclusionsArgs;
  consignes?: boolean | TermCountOutputTypeCountConsignesArgs;
  chatters?: boolean | TermCountOutputTypeCountChattersArgs;
  convocations?: boolean | TermCountOutputTypeCountConvocationsArgs;
  periodicAttendances?:
    | boolean
    | TermCountOutputTypeCountPeriodicAttendancesArgs;
};

/**
 * TermCountOutputType without action
 */
export type TermCountOutputTypeDefaultArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the TermCountOutputType
   */
  select?: Prisma.TermCountOutputTypeSelect<ExtArgs> | null;
};

/**
 * TermCountOutputType without action
 */
export type TermCountOutputTypeCountGradeSheetsArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  where?: Prisma.GradeSheetWhereInput;
};

/**
 * TermCountOutputType without action
 */
export type TermCountOutputTypeCountReportCardsArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  where?: Prisma.ReportCardWhereInput;
};

/**
 * TermCountOutputType without action
 */
export type TermCountOutputTypeCountAssignmentsArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  where?: Prisma.AssignmentWhereInput;
};

/**
 * TermCountOutputType without action
 */
export type TermCountOutputTypeCountAbsencesArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  where?: Prisma.AbsenceWhereInput;
};

/**
 * TermCountOutputType without action
 */
export type TermCountOutputTypeCountLatenessesArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  where?: Prisma.LatenessWhereInput;
};

/**
 * TermCountOutputType without action
 */
export type TermCountOutputTypeCountExclusionsArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  where?: Prisma.ExclusionWhereInput;
};

/**
 * TermCountOutputType without action
 */
export type TermCountOutputTypeCountConsignesArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  where?: Prisma.ConsigneWhereInput;
};

/**
 * TermCountOutputType without action
 */
export type TermCountOutputTypeCountChattersArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  where?: Prisma.ChatterWhereInput;
};

/**
 * TermCountOutputType without action
 */
export type TermCountOutputTypeCountConvocationsArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  where?: Prisma.ConvocationWhereInput;
};

/**
 * TermCountOutputType without action
 */
export type TermCountOutputTypeCountPeriodicAttendancesArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  where?: Prisma.PeriodicAttendanceWhereInput;
};

export type TermSelect<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
  {
    id?: boolean;
    name?: boolean;
    schoolYearId?: boolean;
    order?: boolean;
    startDate?: boolean;
    endDate?: boolean;
    isActive?: boolean;
    observation?: boolean;
    schoolId?: boolean;
    gradeSheets?: boolean | Prisma.Term$gradeSheetsArgs<ExtArgs>;
    schoolYear?: boolean | Prisma.SchoolYearDefaultArgs<ExtArgs>;
    reportCards?: boolean | Prisma.Term$reportCardsArgs<ExtArgs>;
    assignments?: boolean | Prisma.Term$assignmentsArgs<ExtArgs>;
    School?: boolean | Prisma.SchoolDefaultArgs<ExtArgs>;
    absences?: boolean | Prisma.Term$absencesArgs<ExtArgs>;
    latenesses?: boolean | Prisma.Term$latenessesArgs<ExtArgs>;
    exclusions?: boolean | Prisma.Term$exclusionsArgs<ExtArgs>;
    consignes?: boolean | Prisma.Term$consignesArgs<ExtArgs>;
    chatters?: boolean | Prisma.Term$chattersArgs<ExtArgs>;
    convocations?: boolean | Prisma.Term$convocationsArgs<ExtArgs>;
    periodicAttendances?:
      | boolean
      | Prisma.Term$periodicAttendancesArgs<ExtArgs>;
    _count?: boolean | Prisma.TermCountOutputTypeDefaultArgs<ExtArgs>;
  },
  ExtArgs["result"]["term"]
>;

export type TermSelectCreateManyAndReturn<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
  {
    id?: boolean;
    name?: boolean;
    schoolYearId?: boolean;
    order?: boolean;
    startDate?: boolean;
    endDate?: boolean;
    isActive?: boolean;
    observation?: boolean;
    schoolId?: boolean;
    schoolYear?: boolean | Prisma.SchoolYearDefaultArgs<ExtArgs>;
    School?: boolean | Prisma.SchoolDefaultArgs<ExtArgs>;
  },
  ExtArgs["result"]["term"]
>;

export type TermSelectUpdateManyAndReturn<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
  {
    id?: boolean;
    name?: boolean;
    schoolYearId?: boolean;
    order?: boolean;
    startDate?: boolean;
    endDate?: boolean;
    isActive?: boolean;
    observation?: boolean;
    schoolId?: boolean;
    schoolYear?: boolean | Prisma.SchoolYearDefaultArgs<ExtArgs>;
    School?: boolean | Prisma.SchoolDefaultArgs<ExtArgs>;
  },
  ExtArgs["result"]["term"]
>;

export type TermSelectScalar = {
  id?: boolean;
  name?: boolean;
  schoolYearId?: boolean;
  order?: boolean;
  startDate?: boolean;
  endDate?: boolean;
  isActive?: boolean;
  observation?: boolean;
  schoolId?: boolean;
};

export type TermOmit<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetOmit<
  | "id"
  | "name"
  | "schoolYearId"
  | "order"
  | "startDate"
  | "endDate"
  | "isActive"
  | "observation"
  | "schoolId",
  ExtArgs["result"]["term"]
>;
export type TermInclude<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  gradeSheets?: boolean | Prisma.Term$gradeSheetsArgs<ExtArgs>;
  schoolYear?: boolean | Prisma.SchoolYearDefaultArgs<ExtArgs>;
  reportCards?: boolean | Prisma.Term$reportCardsArgs<ExtArgs>;
  assignments?: boolean | Prisma.Term$assignmentsArgs<ExtArgs>;
  School?: boolean | Prisma.SchoolDefaultArgs<ExtArgs>;
  absences?: boolean | Prisma.Term$absencesArgs<ExtArgs>;
  latenesses?: boolean | Prisma.Term$latenessesArgs<ExtArgs>;
  exclusions?: boolean | Prisma.Term$exclusionsArgs<ExtArgs>;
  consignes?: boolean | Prisma.Term$consignesArgs<ExtArgs>;
  chatters?: boolean | Prisma.Term$chattersArgs<ExtArgs>;
  convocations?: boolean | Prisma.Term$convocationsArgs<ExtArgs>;
  periodicAttendances?: boolean | Prisma.Term$periodicAttendancesArgs<ExtArgs>;
  _count?: boolean | Prisma.TermCountOutputTypeDefaultArgs<ExtArgs>;
};
export type TermIncludeCreateManyAndReturn<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  schoolYear?: boolean | Prisma.SchoolYearDefaultArgs<ExtArgs>;
  School?: boolean | Prisma.SchoolDefaultArgs<ExtArgs>;
};
export type TermIncludeUpdateManyAndReturn<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  schoolYear?: boolean | Prisma.SchoolYearDefaultArgs<ExtArgs>;
  School?: boolean | Prisma.SchoolDefaultArgs<ExtArgs>;
};

export type $TermPayload<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  name: "Term";
  objects: {
    gradeSheets: Prisma.$GradeSheetPayload<ExtArgs>[];
    schoolYear: Prisma.$SchoolYearPayload<ExtArgs>;
    reportCards: Prisma.$ReportCardPayload<ExtArgs>[];
    assignments: Prisma.$AssignmentPayload<ExtArgs>[];
    School: Prisma.$SchoolPayload<ExtArgs>;
    absences: Prisma.$AbsencePayload<ExtArgs>[];
    latenesses: Prisma.$LatenessPayload<ExtArgs>[];
    exclusions: Prisma.$ExclusionPayload<ExtArgs>[];
    consignes: Prisma.$ConsignePayload<ExtArgs>[];
    chatters: Prisma.$ChatterPayload<ExtArgs>[];
    convocations: Prisma.$ConvocationPayload<ExtArgs>[];
    periodicAttendances: Prisma.$PeriodicAttendancePayload<ExtArgs>[];
  };
  scalars: runtime.Types.Extensions.GetPayloadResult<
    {
      id: string;
      name: string;
      schoolYearId: string;
      order: number;
      startDate: Date;
      endDate: Date;
      isActive: boolean | null;
      observation: string | null;
      schoolId: string;
    },
    ExtArgs["result"]["term"]
  >;
  composites: {};
};

export type TermGetPayload<
  S extends boolean | null | undefined | TermDefaultArgs,
> = runtime.Types.Result.GetResult<Prisma.$TermPayload, S>;

export type TermCountArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = Omit<TermFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
  select?: TermCountAggregateInputType | true;
};

export interface TermDelegate<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
  GlobalOmitOptions = {},
> {
  [K: symbol]: {
    types: Prisma.TypeMap<ExtArgs>["model"]["Term"];
    meta: { name: "Term" };
  };
  /**
   * Find zero or one Term that matches the filter.
   * @param {TermFindUniqueArgs} args - Arguments to find a Term
   * @example
   * // Get one Term
   * const term = await prisma.term.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends TermFindUniqueArgs>(
    args: Prisma.SelectSubset<T, TermFindUniqueArgs<ExtArgs>>,
  ): Prisma.Prisma__TermClient<
    runtime.Types.Result.GetResult<
      Prisma.$TermPayload<ExtArgs>,
      T,
      "findUnique",
      GlobalOmitOptions
    > | null,
    null,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Find one Term that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {TermFindUniqueOrThrowArgs} args - Arguments to find a Term
   * @example
   * // Get one Term
   * const term = await prisma.term.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends TermFindUniqueOrThrowArgs>(
    args: Prisma.SelectSubset<T, TermFindUniqueOrThrowArgs<ExtArgs>>,
  ): Prisma.Prisma__TermClient<
    runtime.Types.Result.GetResult<
      Prisma.$TermPayload<ExtArgs>,
      T,
      "findUniqueOrThrow",
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Find the first Term that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {TermFindFirstArgs} args - Arguments to find a Term
   * @example
   * // Get one Term
   * const term = await prisma.term.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends TermFindFirstArgs>(
    args?: Prisma.SelectSubset<T, TermFindFirstArgs<ExtArgs>>,
  ): Prisma.Prisma__TermClient<
    runtime.Types.Result.GetResult<
      Prisma.$TermPayload<ExtArgs>,
      T,
      "findFirst",
      GlobalOmitOptions
    > | null,
    null,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Find the first Term that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {TermFindFirstOrThrowArgs} args - Arguments to find a Term
   * @example
   * // Get one Term
   * const term = await prisma.term.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends TermFindFirstOrThrowArgs>(
    args?: Prisma.SelectSubset<T, TermFindFirstOrThrowArgs<ExtArgs>>,
  ): Prisma.Prisma__TermClient<
    runtime.Types.Result.GetResult<
      Prisma.$TermPayload<ExtArgs>,
      T,
      "findFirstOrThrow",
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Find zero or more Terms that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {TermFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Terms
   * const terms = await prisma.term.findMany()
   *
   * // Get first 10 Terms
   * const terms = await prisma.term.findMany({ take: 10 })
   *
   * // Only select the `id`
   * const termWithIdOnly = await prisma.term.findMany({ select: { id: true } })
   *
   */
  findMany<T extends TermFindManyArgs>(
    args?: Prisma.SelectSubset<T, TermFindManyArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<
    runtime.Types.Result.GetResult<
      Prisma.$TermPayload<ExtArgs>,
      T,
      "findMany",
      GlobalOmitOptions
    >
  >;

  /**
   * Create a Term.
   * @param {TermCreateArgs} args - Arguments to create a Term.
   * @example
   * // Create one Term
   * const Term = await prisma.term.create({
   *   data: {
   *     // ... data to create a Term
   *   }
   * })
   *
   */
  create<T extends TermCreateArgs>(
    args: Prisma.SelectSubset<T, TermCreateArgs<ExtArgs>>,
  ): Prisma.Prisma__TermClient<
    runtime.Types.Result.GetResult<
      Prisma.$TermPayload<ExtArgs>,
      T,
      "create",
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Create many Terms.
   * @param {TermCreateManyArgs} args - Arguments to create many Terms.
   * @example
   * // Create many Terms
   * const term = await prisma.term.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *
   */
  createMany<T extends TermCreateManyArgs>(
    args?: Prisma.SelectSubset<T, TermCreateManyArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<Prisma.BatchPayload>;

  /**
   * Create many Terms and returns the data saved in the database.
   * @param {TermCreateManyAndReturnArgs} args - Arguments to create many Terms.
   * @example
   * // Create many Terms
   * const term = await prisma.term.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *
   * // Create many Terms and only return the `id`
   * const termWithIdOnly = await prisma.term.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   *
   */
  createManyAndReturn<T extends TermCreateManyAndReturnArgs>(
    args?: Prisma.SelectSubset<T, TermCreateManyAndReturnArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<
    runtime.Types.Result.GetResult<
      Prisma.$TermPayload<ExtArgs>,
      T,
      "createManyAndReturn",
      GlobalOmitOptions
    >
  >;

  /**
   * Delete a Term.
   * @param {TermDeleteArgs} args - Arguments to delete one Term.
   * @example
   * // Delete one Term
   * const Term = await prisma.term.delete({
   *   where: {
   *     // ... filter to delete one Term
   *   }
   * })
   *
   */
  delete<T extends TermDeleteArgs>(
    args: Prisma.SelectSubset<T, TermDeleteArgs<ExtArgs>>,
  ): Prisma.Prisma__TermClient<
    runtime.Types.Result.GetResult<
      Prisma.$TermPayload<ExtArgs>,
      T,
      "delete",
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Update one Term.
   * @param {TermUpdateArgs} args - Arguments to update one Term.
   * @example
   * // Update one Term
   * const term = await prisma.term.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   *
   */
  update<T extends TermUpdateArgs>(
    args: Prisma.SelectSubset<T, TermUpdateArgs<ExtArgs>>,
  ): Prisma.Prisma__TermClient<
    runtime.Types.Result.GetResult<
      Prisma.$TermPayload<ExtArgs>,
      T,
      "update",
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Delete zero or more Terms.
   * @param {TermDeleteManyArgs} args - Arguments to filter Terms to delete.
   * @example
   * // Delete a few Terms
   * const { count } = await prisma.term.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   *
   */
  deleteMany<T extends TermDeleteManyArgs>(
    args?: Prisma.SelectSubset<T, TermDeleteManyArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<Prisma.BatchPayload>;

  /**
   * Update zero or more Terms.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {TermUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Terms
   * const term = await prisma.term.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   *
   */
  updateMany<T extends TermUpdateManyArgs>(
    args: Prisma.SelectSubset<T, TermUpdateManyArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<Prisma.BatchPayload>;

  /**
   * Update zero or more Terms and returns the data updated in the database.
   * @param {TermUpdateManyAndReturnArgs} args - Arguments to update many Terms.
   * @example
   * // Update many Terms
   * const term = await prisma.term.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *
   * // Update zero or more Terms and only return the `id`
   * const termWithIdOnly = await prisma.term.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   *
   */
  updateManyAndReturn<T extends TermUpdateManyAndReturnArgs>(
    args: Prisma.SelectSubset<T, TermUpdateManyAndReturnArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<
    runtime.Types.Result.GetResult<
      Prisma.$TermPayload<ExtArgs>,
      T,
      "updateManyAndReturn",
      GlobalOmitOptions
    >
  >;

  /**
   * Create or update one Term.
   * @param {TermUpsertArgs} args - Arguments to update or create a Term.
   * @example
   * // Update or create a Term
   * const term = await prisma.term.upsert({
   *   create: {
   *     // ... data to create a Term
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Term we want to update
   *   }
   * })
   */
  upsert<T extends TermUpsertArgs>(
    args: Prisma.SelectSubset<T, TermUpsertArgs<ExtArgs>>,
  ): Prisma.Prisma__TermClient<
    runtime.Types.Result.GetResult<
      Prisma.$TermPayload<ExtArgs>,
      T,
      "upsert",
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Count the number of Terms.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {TermCountArgs} args - Arguments to filter Terms to count.
   * @example
   * // Count the number of Terms
   * const count = await prisma.term.count({
   *   where: {
   *     // ... the filter for the Terms we want to count
   *   }
   * })
   **/
  count<T extends TermCountArgs>(
    args?: Prisma.Subset<T, TermCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<"select", any>
      ? T["select"] extends true
        ? number
        : Prisma.GetScalarType<T["select"], TermCountAggregateOutputType>
      : number
  >;

  /**
   * Allows you to perform aggregations operations on a Term.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {TermAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
   **/
  aggregate<T extends TermAggregateArgs>(
    args: Prisma.Subset<T, TermAggregateArgs>,
  ): Prisma.PrismaPromise<GetTermAggregateType<T>>;

  /**
   * Group by Term.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {TermGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   *
   **/
  groupBy<
    T extends TermGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<"skip", Prisma.Keys<T>>,
      Prisma.Extends<"take", Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: TermGroupByArgs["orderBy"] }
      : { orderBy?: TermGroupByArgs["orderBy"] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<
      Prisma.Keys<Prisma.MaybeTupleToUnion<T["orderBy"]>>
    >,
    ByFields extends Prisma.MaybeTupleToUnion<T["by"]>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T["having"]>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T["by"] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
      ? `Error: "by" must not be empty.`
      : HavingValid extends Prisma.False
        ? {
            [P in HavingFields]: P extends ByFields
              ? never
              : P extends string
                ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                : [
                    Error,
                    "Field ",
                    P,
                    ` in "having" needs to be provided in "by"`,
                  ];
          }[HavingFields]
        : "take" extends Prisma.Keys<T>
          ? "orderBy" extends Prisma.Keys<T>
            ? ByValid extends Prisma.True
              ? {}
              : {
                  [P in OrderFields]: P extends ByFields
                    ? never
                    : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                }[OrderFields]
            : 'Error: If you provide "take", you also need to provide "orderBy"'
          : "skip" extends Prisma.Keys<T>
            ? "orderBy" extends Prisma.Keys<T>
              ? ByValid extends Prisma.True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "skip", you also need to provide "orderBy"'
            : ByValid extends Prisma.True
              ? {}
              : {
                  [P in OrderFields]: P extends ByFields
                    ? never
                    : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                }[OrderFields],
  >(
    args: Prisma.SubsetIntersection<T, TermGroupByArgs, OrderByArg> &
      InputErrors,
  ): {} extends InputErrors
    ? GetTermGroupByPayload<T>
    : Prisma.PrismaPromise<InputErrors>;
  /**
   * Fields of the Term model
   */
  readonly fields: TermFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for Term.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__TermClient<
  T,
  Null = never,
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
  GlobalOmitOptions = {},
> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise";
  gradeSheets<T extends Prisma.Term$gradeSheetsArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.Term$gradeSheetsArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<
    | runtime.Types.Result.GetResult<
        Prisma.$GradeSheetPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    | Null
  >;
  schoolYear<T extends Prisma.SchoolYearDefaultArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.SchoolYearDefaultArgs<ExtArgs>>,
  ): Prisma.Prisma__SchoolYearClient<
    | runtime.Types.Result.GetResult<
        Prisma.$SchoolYearPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >
    | Null,
    Null,
    ExtArgs,
    GlobalOmitOptions
  >;
  reportCards<T extends Prisma.Term$reportCardsArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.Term$reportCardsArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<
    | runtime.Types.Result.GetResult<
        Prisma.$ReportCardPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    | Null
  >;
  assignments<T extends Prisma.Term$assignmentsArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.Term$assignmentsArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<
    | runtime.Types.Result.GetResult<
        Prisma.$AssignmentPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    | Null
  >;
  School<T extends Prisma.SchoolDefaultArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.SchoolDefaultArgs<ExtArgs>>,
  ): Prisma.Prisma__SchoolClient<
    | runtime.Types.Result.GetResult<
        Prisma.$SchoolPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >
    | Null,
    Null,
    ExtArgs,
    GlobalOmitOptions
  >;
  absences<T extends Prisma.Term$absencesArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.Term$absencesArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<
    | runtime.Types.Result.GetResult<
        Prisma.$AbsencePayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    | Null
  >;
  latenesses<T extends Prisma.Term$latenessesArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.Term$latenessesArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<
    | runtime.Types.Result.GetResult<
        Prisma.$LatenessPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    | Null
  >;
  exclusions<T extends Prisma.Term$exclusionsArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.Term$exclusionsArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<
    | runtime.Types.Result.GetResult<
        Prisma.$ExclusionPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    | Null
  >;
  consignes<T extends Prisma.Term$consignesArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.Term$consignesArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<
    | runtime.Types.Result.GetResult<
        Prisma.$ConsignePayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    | Null
  >;
  chatters<T extends Prisma.Term$chattersArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.Term$chattersArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<
    | runtime.Types.Result.GetResult<
        Prisma.$ChatterPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    | Null
  >;
  convocations<T extends Prisma.Term$convocationsArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.Term$convocationsArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<
    | runtime.Types.Result.GetResult<
        Prisma.$ConvocationPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    | Null
  >;
  periodicAttendances<
    T extends Prisma.Term$periodicAttendancesArgs<ExtArgs> = {},
  >(
    args?: Prisma.Subset<T, Prisma.Term$periodicAttendancesArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<
    | runtime.Types.Result.GetResult<
        Prisma.$PeriodicAttendancePayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    | Null
  >;
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(
    onfulfilled?:
      | ((value: T) => TResult1 | PromiseLike<TResult1>)
      | undefined
      | null,
    onrejected?:
      | ((reason: any) => TResult2 | PromiseLike<TResult2>)
      | undefined
      | null,
  ): runtime.Types.Utils.JsPromise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(
    onrejected?:
      | ((reason: any) => TResult | PromiseLike<TResult>)
      | undefined
      | null,
  ): runtime.Types.Utils.JsPromise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(
    onfinally?: (() => void) | undefined | null,
  ): runtime.Types.Utils.JsPromise<T>;
}

/**
 * Fields of the Term model
 */
export interface TermFieldRefs {
  readonly id: Prisma.FieldRef<"Term", "String">;
  readonly name: Prisma.FieldRef<"Term", "String">;
  readonly schoolYearId: Prisma.FieldRef<"Term", "String">;
  readonly order: Prisma.FieldRef<"Term", "Int">;
  readonly startDate: Prisma.FieldRef<"Term", "DateTime">;
  readonly endDate: Prisma.FieldRef<"Term", "DateTime">;
  readonly isActive: Prisma.FieldRef<"Term", "Boolean">;
  readonly observation: Prisma.FieldRef<"Term", "String">;
  readonly schoolId: Prisma.FieldRef<"Term", "String">;
}

// Custom InputTypes
/**
 * Term findUnique
 */
export type TermFindUniqueArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Term
   */
  select?: Prisma.TermSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Term
   */
  omit?: Prisma.TermOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TermInclude<ExtArgs> | null;
  /**
   * Filter, which Term to fetch.
   */
  where: Prisma.TermWhereUniqueInput;
};

/**
 * Term findUniqueOrThrow
 */
export type TermFindUniqueOrThrowArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Term
   */
  select?: Prisma.TermSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Term
   */
  omit?: Prisma.TermOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TermInclude<ExtArgs> | null;
  /**
   * Filter, which Term to fetch.
   */
  where: Prisma.TermWhereUniqueInput;
};

/**
 * Term findFirst
 */
export type TermFindFirstArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Term
   */
  select?: Prisma.TermSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Term
   */
  omit?: Prisma.TermOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TermInclude<ExtArgs> | null;
  /**
   * Filter, which Term to fetch.
   */
  where?: Prisma.TermWhereInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   *
   * Determine the order of Terms to fetch.
   */
  orderBy?:
    | Prisma.TermOrderByWithRelationInput
    | Prisma.TermOrderByWithRelationInput[];
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   *
   * Sets the position for searching for Terms.
   */
  cursor?: Prisma.TermWhereUniqueInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Take `Â±n` Terms from the position of the cursor.
   */
  take?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Skip the first `n` Terms.
   */
  skip?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   *
   * Filter by unique combinations of Terms.
   */
  distinct?: Prisma.TermScalarFieldEnum | Prisma.TermScalarFieldEnum[];
};

/**
 * Term findFirstOrThrow
 */
export type TermFindFirstOrThrowArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Term
   */
  select?: Prisma.TermSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Term
   */
  omit?: Prisma.TermOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TermInclude<ExtArgs> | null;
  /**
   * Filter, which Term to fetch.
   */
  where?: Prisma.TermWhereInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   *
   * Determine the order of Terms to fetch.
   */
  orderBy?:
    | Prisma.TermOrderByWithRelationInput
    | Prisma.TermOrderByWithRelationInput[];
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   *
   * Sets the position for searching for Terms.
   */
  cursor?: Prisma.TermWhereUniqueInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Take `Â±n` Terms from the position of the cursor.
   */
  take?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Skip the first `n` Terms.
   */
  skip?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   *
   * Filter by unique combinations of Terms.
   */
  distinct?: Prisma.TermScalarFieldEnum | Prisma.TermScalarFieldEnum[];
};

/**
 * Term findMany
 */
export type TermFindManyArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Term
   */
  select?: Prisma.TermSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Term
   */
  omit?: Prisma.TermOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TermInclude<ExtArgs> | null;
  /**
   * Filter, which Terms to fetch.
   */
  where?: Prisma.TermWhereInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   *
   * Determine the order of Terms to fetch.
   */
  orderBy?:
    | Prisma.TermOrderByWithRelationInput
    | Prisma.TermOrderByWithRelationInput[];
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   *
   * Sets the position for listing Terms.
   */
  cursor?: Prisma.TermWhereUniqueInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Take `Â±n` Terms from the position of the cursor.
   */
  take?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Skip the first `n` Terms.
   */
  skip?: number;
  distinct?: Prisma.TermScalarFieldEnum | Prisma.TermScalarFieldEnum[];
};

/**
 * Term create
 */
export type TermCreateArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Term
   */
  select?: Prisma.TermSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Term
   */
  omit?: Prisma.TermOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TermInclude<ExtArgs> | null;
  /**
   * The data needed to create a Term.
   */
  data: Prisma.XOR<Prisma.TermCreateInput, Prisma.TermUncheckedCreateInput>;
};

/**
 * Term createMany
 */
export type TermCreateManyArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * The data used to create many Terms.
   */
  data: Prisma.TermCreateManyInput | Prisma.TermCreateManyInput[];
  skipDuplicates?: boolean;
};

/**
 * Term createManyAndReturn
 */
export type TermCreateManyAndReturnArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Term
   */
  select?: Prisma.TermSelectCreateManyAndReturn<ExtArgs> | null;
  /**
   * Omit specific fields from the Term
   */
  omit?: Prisma.TermOmit<ExtArgs> | null;
  /**
   * The data used to create many Terms.
   */
  data: Prisma.TermCreateManyInput | Prisma.TermCreateManyInput[];
  skipDuplicates?: boolean;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TermIncludeCreateManyAndReturn<ExtArgs> | null;
};

/**
 * Term update
 */
export type TermUpdateArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Term
   */
  select?: Prisma.TermSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Term
   */
  omit?: Prisma.TermOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TermInclude<ExtArgs> | null;
  /**
   * The data needed to update a Term.
   */
  data: Prisma.XOR<Prisma.TermUpdateInput, Prisma.TermUncheckedUpdateInput>;
  /**
   * Choose, which Term to update.
   */
  where: Prisma.TermWhereUniqueInput;
};

/**
 * Term updateMany
 */
export type TermUpdateManyArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * The data used to update Terms.
   */
  data: Prisma.XOR<
    Prisma.TermUpdateManyMutationInput,
    Prisma.TermUncheckedUpdateManyInput
  >;
  /**
   * Filter which Terms to update
   */
  where?: Prisma.TermWhereInput;
  /**
   * Limit how many Terms to update.
   */
  limit?: number;
};

/**
 * Term updateManyAndReturn
 */
export type TermUpdateManyAndReturnArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Term
   */
  select?: Prisma.TermSelectUpdateManyAndReturn<ExtArgs> | null;
  /**
   * Omit specific fields from the Term
   */
  omit?: Prisma.TermOmit<ExtArgs> | null;
  /**
   * The data used to update Terms.
   */
  data: Prisma.XOR<
    Prisma.TermUpdateManyMutationInput,
    Prisma.TermUncheckedUpdateManyInput
  >;
  /**
   * Filter which Terms to update
   */
  where?: Prisma.TermWhereInput;
  /**
   * Limit how many Terms to update.
   */
  limit?: number;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TermIncludeUpdateManyAndReturn<ExtArgs> | null;
};

/**
 * Term upsert
 */
export type TermUpsertArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Term
   */
  select?: Prisma.TermSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Term
   */
  omit?: Prisma.TermOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TermInclude<ExtArgs> | null;
  /**
   * The filter to search for the Term to update in case it exists.
   */
  where: Prisma.TermWhereUniqueInput;
  /**
   * In case the Term found by the `where` argument doesn't exist, create a new Term with this data.
   */
  create: Prisma.XOR<Prisma.TermCreateInput, Prisma.TermUncheckedCreateInput>;
  /**
   * In case the Term was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.TermUpdateInput, Prisma.TermUncheckedUpdateInput>;
};

/**
 * Term delete
 */
export type TermDeleteArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Term
   */
  select?: Prisma.TermSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Term
   */
  omit?: Prisma.TermOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TermInclude<ExtArgs> | null;
  /**
   * Filter which Term to delete.
   */
  where: Prisma.TermWhereUniqueInput;
};

/**
 * Term deleteMany
 */
export type TermDeleteManyArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Filter which Terms to delete
   */
  where?: Prisma.TermWhereInput;
  /**
   * Limit how many Terms to delete.
   */
  limit?: number;
};

/**
 * Term.gradeSheets
 */
export type Term$gradeSheetsArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the GradeSheet
   */
  select?: Prisma.GradeSheetSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the GradeSheet
   */
  omit?: Prisma.GradeSheetOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GradeSheetInclude<ExtArgs> | null;
  where?: Prisma.GradeSheetWhereInput;
  orderBy?:
    | Prisma.GradeSheetOrderByWithRelationInput
    | Prisma.GradeSheetOrderByWithRelationInput[];
  cursor?: Prisma.GradeSheetWhereUniqueInput;
  take?: number;
  skip?: number;
  distinct?:
    | Prisma.GradeSheetScalarFieldEnum
    | Prisma.GradeSheetScalarFieldEnum[];
};

/**
 * Term.reportCards
 */
export type Term$reportCardsArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the ReportCard
   */
  select?: Prisma.ReportCardSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the ReportCard
   */
  omit?: Prisma.ReportCardOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ReportCardInclude<ExtArgs> | null;
  where?: Prisma.ReportCardWhereInput;
  orderBy?:
    | Prisma.ReportCardOrderByWithRelationInput
    | Prisma.ReportCardOrderByWithRelationInput[];
  cursor?: Prisma.ReportCardWhereUniqueInput;
  take?: number;
  skip?: number;
  distinct?:
    | Prisma.ReportCardScalarFieldEnum
    | Prisma.ReportCardScalarFieldEnum[];
};

/**
 * Term.assignments
 */
export type Term$assignmentsArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Assignment
   */
  select?: Prisma.AssignmentSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Assignment
   */
  omit?: Prisma.AssignmentOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.AssignmentInclude<ExtArgs> | null;
  where?: Prisma.AssignmentWhereInput;
  orderBy?:
    | Prisma.AssignmentOrderByWithRelationInput
    | Prisma.AssignmentOrderByWithRelationInput[];
  cursor?: Prisma.AssignmentWhereUniqueInput;
  take?: number;
  skip?: number;
  distinct?:
    | Prisma.AssignmentScalarFieldEnum
    | Prisma.AssignmentScalarFieldEnum[];
};

/**
 * Term.absences
 */
export type Term$absencesArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Absence
   */
  select?: Prisma.AbsenceSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Absence
   */
  omit?: Prisma.AbsenceOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.AbsenceInclude<ExtArgs> | null;
  where?: Prisma.AbsenceWhereInput;
  orderBy?:
    | Prisma.AbsenceOrderByWithRelationInput
    | Prisma.AbsenceOrderByWithRelationInput[];
  cursor?: Prisma.AbsenceWhereUniqueInput;
  take?: number;
  skip?: number;
  distinct?: Prisma.AbsenceScalarFieldEnum | Prisma.AbsenceScalarFieldEnum[];
};

/**
 * Term.latenesses
 */
export type Term$latenessesArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Lateness
   */
  select?: Prisma.LatenessSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Lateness
   */
  omit?: Prisma.LatenessOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.LatenessInclude<ExtArgs> | null;
  where?: Prisma.LatenessWhereInput;
  orderBy?:
    | Prisma.LatenessOrderByWithRelationInput
    | Prisma.LatenessOrderByWithRelationInput[];
  cursor?: Prisma.LatenessWhereUniqueInput;
  take?: number;
  skip?: number;
  distinct?: Prisma.LatenessScalarFieldEnum | Prisma.LatenessScalarFieldEnum[];
};

/**
 * Term.exclusions
 */
export type Term$exclusionsArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Exclusion
   */
  select?: Prisma.ExclusionSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Exclusion
   */
  omit?: Prisma.ExclusionOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ExclusionInclude<ExtArgs> | null;
  where?: Prisma.ExclusionWhereInput;
  orderBy?:
    | Prisma.ExclusionOrderByWithRelationInput
    | Prisma.ExclusionOrderByWithRelationInput[];
  cursor?: Prisma.ExclusionWhereUniqueInput;
  take?: number;
  skip?: number;
  distinct?:
    | Prisma.ExclusionScalarFieldEnum
    | Prisma.ExclusionScalarFieldEnum[];
};

/**
 * Term.consignes
 */
export type Term$consignesArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Consigne
   */
  select?: Prisma.ConsigneSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Consigne
   */
  omit?: Prisma.ConsigneOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ConsigneInclude<ExtArgs> | null;
  where?: Prisma.ConsigneWhereInput;
  orderBy?:
    | Prisma.ConsigneOrderByWithRelationInput
    | Prisma.ConsigneOrderByWithRelationInput[];
  cursor?: Prisma.ConsigneWhereUniqueInput;
  take?: number;
  skip?: number;
  distinct?: Prisma.ConsigneScalarFieldEnum | Prisma.ConsigneScalarFieldEnum[];
};

/**
 * Term.chatters
 */
export type Term$chattersArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Chatter
   */
  select?: Prisma.ChatterSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Chatter
   */
  omit?: Prisma.ChatterOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ChatterInclude<ExtArgs> | null;
  where?: Prisma.ChatterWhereInput;
  orderBy?:
    | Prisma.ChatterOrderByWithRelationInput
    | Prisma.ChatterOrderByWithRelationInput[];
  cursor?: Prisma.ChatterWhereUniqueInput;
  take?: number;
  skip?: number;
  distinct?: Prisma.ChatterScalarFieldEnum | Prisma.ChatterScalarFieldEnum[];
};

/**
 * Term.convocations
 */
export type Term$convocationsArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Convocation
   */
  select?: Prisma.ConvocationSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Convocation
   */
  omit?: Prisma.ConvocationOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ConvocationInclude<ExtArgs> | null;
  where?: Prisma.ConvocationWhereInput;
  orderBy?:
    | Prisma.ConvocationOrderByWithRelationInput
    | Prisma.ConvocationOrderByWithRelationInput[];
  cursor?: Prisma.ConvocationWhereUniqueInput;
  take?: number;
  skip?: number;
  distinct?:
    | Prisma.ConvocationScalarFieldEnum
    | Prisma.ConvocationScalarFieldEnum[];
};

/**
 * Term.periodicAttendances
 */
export type Term$periodicAttendancesArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the PeriodicAttendance
   */
  select?: Prisma.PeriodicAttendanceSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the PeriodicAttendance
   */
  omit?: Prisma.PeriodicAttendanceOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PeriodicAttendanceInclude<ExtArgs> | null;
  where?: Prisma.PeriodicAttendanceWhereInput;
  orderBy?:
    | Prisma.PeriodicAttendanceOrderByWithRelationInput
    | Prisma.PeriodicAttendanceOrderByWithRelationInput[];
  cursor?: Prisma.PeriodicAttendanceWhereUniqueInput;
  take?: number;
  skip?: number;
  distinct?:
    | Prisma.PeriodicAttendanceScalarFieldEnum
    | Prisma.PeriodicAttendanceScalarFieldEnum[];
};

/**
 * Term without action
 */
export type TermDefaultArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Term
   */
  select?: Prisma.TermSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Term
   */
  omit?: Prisma.TermOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TermInclude<ExtArgs> | null;
};
