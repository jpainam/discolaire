enum NotificationSourceType {
    GRADES_UPDATES
    ABSENCE_ALERTS
    PAYMENT_REMINDERS
    EVENT_NOTIFICATIONS
    WEEKLY_SUMMARIES
}

enum NotificationStatus {
    PENDING
    SENT
    FAILED
    CANCELED
    SKIPPED
}

enum NotificationChannel {
    EMAIL
    SMS
    WHATSAPP
    IN_APP
}

enum NotificationRecipientProfile {
    STUDENT
    CONTACT
    STAFF
}

// One record per (school, entity) — links a staff/student/contact to the notification system.
model NotificationRecipient {
    id            String                       @id @default(cuid())
    schoolId      String
    profile       NotificationRecipientProfile
    entityId      String // foreign key to Staff.id / Student.id / Contact.id
    userId        String?
    primaryEmail  String?
    primaryPhone  String?
    createdAt     DateTime                     @default(now())
    updatedAt     DateTime                     @updatedAt
    school        School                       @relation(fields: [schoolId], references: [id], onDelete: Cascade)
    user          User?                        @relation(fields: [userId], references: [id], onDelete: SetNull)
    notifications Notification[]
    preferences   NotificationPreference[]
    subscriptions NotificationSubscription[]

    @@unique([schoolId, profile, entityId])
    @@index([schoolId, profile])
    @@index([userId])
}

// One record per (recipient, sourceType, sourceId).
// The unique constraint acts as a deduplication guard — creating a Notification
// for an already-recorded source event is a no-op (or idempotent upsert).
model Notification {
    id          String                 @id @default(cuid())
    schoolId    String
    recipientId String
    recipient   NotificationRecipient  @relation(fields: [recipientId], references: [id], onDelete: Cascade)
    sourceType  NotificationSourceType
    sourceId    String // e.g., absence record id, invoice id, grade id
    // Optional contextual data used when rendering the hardcoded message content.
    context     Json?
    createdAt   DateTime               @default(now())
    deliveries  NotificationDelivery[]

    @@unique([schoolId, recipientId, sourceType, sourceId])
    @@index([schoolId, recipientId, createdAt])
    @@index([schoolId, sourceType, sourceId])
}

// One record per (notification, channel).
// Tracks whether a channel delivery was attempted, succeeded, failed, or skipped.
model NotificationDelivery {
    id             String              @id @default(cuid())
    notificationId String
    channel        NotificationChannel
    status         NotificationStatus  @default(PENDING)
    provider       String? // "twilio", "ses", "whatsapp"
    providerMsgId  String? // message id from the external provider
    error          String?
    attemptCount   Int                 @default(0)
    skipReason     String? // populated when status=SKIPPED (e.g., "channel_disabled")
    sentAt         DateTime?
    createdAt      DateTime            @default(now())
    updatedAt      DateTime            @updatedAt
    notification   Notification        @relation(fields: [notificationId], references: [id], onDelete: Cascade)
    events         NotificationEvent[]

    @@unique([notificationId, channel])
    @@index([notificationId, channel])
    @@index([status, channel])
}

// Webhook / provider callback events appended to a delivery timeline.
model NotificationEvent {
    id         String               @id @default(cuid())
    deliveryId String
    type       String // "REQUESTED" | "PROVIDER_ACCEPTED" | "DELIVERED" | "BOUNCED" | ...
    data       Json?
    createdAt  DateTime             @default(now())
    delivery   NotificationDelivery @relation(fields: [deliveryId], references: [id], onDelete: Cascade)

    @@index([deliveryId, createdAt])
}

// Per-recipient, per-source-type, per-channel opt-in/out.
// EMAIL and IN_APP rows are seeded with enabled=true for every new recipient (free).
// SMS and WHATSAPP rows are seeded with enabled=false — the recipient must opt in
// AND have an active NotificationSubscription with sufficient balance for those channels.
//
// Dispatch gate: preference.enabled = true AND (channel is free OR subscription.balance > 0)
model NotificationPreference {
    id          String                 @id @default(cuid())
    recipientId String
    recipient   NotificationRecipient  @relation(fields: [recipientId], references: [id], onDelete: Cascade)
    sourceType  NotificationSourceType
    channel     NotificationChannel
    enabled     Boolean                @default(true)
    createdAt   DateTime               @default(now())
    updatedAt   DateTime               @updatedAt

    @@unique([recipientId, sourceType, channel])
    @@index([recipientId])
}

enum SubscriptionStatus {
    ACTIVE
    PAUSED
    CANCELED
}

// Credit-based access to paid channels (SMS, WHATSAPP).
// EMAIL and IN_APP do not need a subscription — they are always available.
// One subscription per (recipient, channel). Balance is decremented on each sent message.
model NotificationSubscription {
    id          String                @id @default(cuid())
    schoolId    String
    recipientId String
    channel     NotificationChannel   // typically SMS or WHATSAPP
    status      SubscriptionStatus    @default(ACTIVE)
    balance     Int                   // remaining message credits
    plan        String?               // e.g., "sms_50", "whatsapp_100"
    comment     String?
    createdAt   DateTime              @default(now())
    updatedAt   DateTime              @updatedAt
    createdById String
    school      School                @relation(fields: [schoolId], references: [id], onDelete: Cascade)
    recipient   NotificationRecipient @relation(fields: [recipientId], references: [id], onDelete: Cascade)
    createdBy   User                  @relation("CreatedSubscriptions", fields: [createdById], references: [id], onUpdate: Cascade)

    creditLogs  NotificationCreditLog[]

    @@unique([recipientId, channel])
    @@index([recipientId, channel, status])
    @@index([schoolId, channel, status])
}

// Groups notification templates for display in the admin UI.
// Replaces the hardcoded EMAIL_CATEGORIES list.
model NotificationCategory {
    id        String               @id @default(cuid())
    schoolId  String
    school    School               @relation(fields: [schoolId], references: [id], onDelete: Cascade)
    key       String               // stable slug, e.g. "attendance"
    label     String               // display name, e.g. "Attendance"
    order     Int                  @default(0)
    configs   NotificationConfig[]
    createdAt DateTime             @default(now())
    updatedAt DateTime             @updatedAt

    @@unique([schoolId, key])
    @@index([schoolId, order])
}

// Canonical registry of notification templates, one row per (school, templateKey, channel).
// This is the source of truth for what emails exist, how they are named, and who can receive them.
// Sending code checks enabled + allowStaff/allowStudent/allowContact before dispatching.
model NotificationConfig {
    id           String                @id @default(cuid())
    schoolId     String
    school       School                @relation(fields: [schoolId], references: [id], onDelete: Cascade)
    categoryId   String?
    category     NotificationCategory? @relation(fields: [categoryId], references: [id], onDelete: SetNull)
    templateKey  String                // stable slug, e.g. "att-001" or "attendance-summary"
    channel      NotificationChannel   @default(EMAIL)
    name         String                // display name, e.g. "Absence Notification"
    description  String                // short description shown in admin UI
    enabled      Boolean               @default(true)
    allowStaff   Boolean               @default(true)
    allowStudent Boolean               @default(true)
    allowContact Boolean               @default(true)
    updatedById  String?
    updatedBy    User?                 @relation("NotificationConfigUpdatedBy", fields: [updatedById], references: [id], onDelete: SetNull)
    createdAt    DateTime              @default(now())
    updatedAt    DateTime              @updatedAt

    @@unique([schoolId, templateKey, channel])
    @@index([schoolId, channel])
    @@index([schoolId, categoryId])
}

// Immutable log of every credit change on a subscription.
// Allows auditing top-ups, deductions, and refunds.
model NotificationCreditLog {
    id             String                   @id @default(cuid())
    subscriptionId String
    subscription   NotificationSubscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)
    delta          Int    // positive = top-up, negative = deduction
    balanceAfter   Int    // snapshot of balance after this operation
    reason         String // "TOP_UP" | "MESSAGE_SENT" | "REFUND" | "ADJUSTMENT"
    notificationId String? // set when reason = MESSAGE_SENT
    createdById    String?
    createdBy      User?                    @relation("CreditLogCreatedBy", fields: [createdById], references: [id], onDelete: SetNull)
    createdAt      DateTime                 @default(now())

    @@index([subscriptionId, createdAt])
}
